#!/usr/bin/env node

/**
 * This script generates TypeScript interfaces from Prisma schema
 * to ensure type safety when working with database models.
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const prismaDir = path.join(__dirname, '..', 'prisma');
const typeOutputDir = path.join(__dirname, '..', 'src', 'types', 'prisma');

// Ensure output directory exists
if (!fs.existsSync(typeOutputDir)) {
  fs.mkdirSync(typeOutputDir, { recursive: true });
}

// Function to generate TypeScript interfaces
function generateTypeInterfaces() {
  console.log('üîç Analyzing Prisma schema...');
  
  try {
    // Run Prisma generate to ensure the client is up-to-date
    execSync('npx prisma generate', { stdio: 'inherit' });
    
    console.log('‚úÖ Prisma client generated successfully');
    
    // Extract model info from the schema file
    const schemaPath = path.join(prismaDir, 'schema.prisma');
    const schemaContent = fs.readFileSync(schemaPath, 'utf8');
    
    // Regular expression to extract models
    const modelRegex = /model\s+(\w+)\s+\{([^}]+)\}/g;
    const enumRegex = /enum\s+(\w+)\s+\{([^}]+)\}/g;
    
    let modelMatch;
    let models = [];
    
    // Extract all models
    while ((modelMatch = modelRegex.exec(schemaContent)) !== null) {
      const modelName = modelMatch[1];
      const modelBody = modelMatch[2];
      
      // Parse fields
      const fieldLines = modelBody.split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('//') && !line.startsWith('@@'));
      
      const fields = fieldLines.map(line => {
        // Basic field parsing - in a real implementation, this would be more robust
        const parts = line.split(/\s+/);
        const name = parts[0];
        let type = parts[1]?.replace('?', '');
        const isOptional = line.includes('?');
        const isArray = line.includes('[]');
        
        // Map Prisma types to TypeScript types
        if (type) {
          switch (type) {
            case 'String':
              type = 'string';
              break;
            case 'Int':
            case 'Float':
            case 'Decimal':
              type = 'number';
              break;
            case 'Boolean':
              type = 'boolean';
              break;
            case 'DateTime':
              type = 'Date';
              break;
            case 'Json':
              type = 'Record<string, any>';
              break;
          }
          
          // Handle arrays
          if (isArray) {
            type = `${type}[]`;
          }
          
          // Handle optional fields
          if (isOptional) {
            type = `${type} | null`;
          }
        }
        
        return { name, type, isOptional, isArray };
      });
      
      models.push({ name: modelName, fields });
    }
    
    // Extract enums
    let enums = [];
    let enumMatch;
    
    while ((enumMatch = enumRegex.exec(schemaContent)) !== null) {
      const enumName = enumMatch[1];
      const enumBody = enumMatch[2];
      
      // Parse enum values
      const values = enumBody.split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('//'))
        .map(line => line.replace(/\s+.+$/, '')); // Remove any comments after the value
      
      enums.push({ name: enumName, values });
    }
    
    // Generate TypeScript interfaces
    let interfaceContent = `// Auto-generated TypeScript interfaces from Prisma schema
// Do not edit this file manually
// Generated on ${new Date().toISOString()}

`;
    
    // Add enums
    enums.forEach(enumDef => {
      interfaceContent += `export enum ${enumDef.name} {\n`;
      enumDef.values.forEach(value => {
        interfaceContent += `  ${value} = "${value}",\n`;
      });
      interfaceContent += `}\n\n`;
    });
    
    // Add model interfaces
    models.forEach(model => {
      interfaceContent += `export interface ${model.name} {\n`;
      model.fields.forEach(field => {
        interfaceContent += `  ${field.name}${field.isOptional ? '?' : ''}: ${field.type};\n`;
      });
      interfaceContent += `}\n\n`;
      
      // Add Create/Update input types
      interfaceContent += `export interface ${model.name}CreateInput {\n`;
      model.fields
        .filter(field => !field.name.includes('Id') && field.name !== 'id' && 
                field.name !== 'createdAt' && field.name !== 'updatedAt')
        .forEach(field => {
          interfaceContent += `  ${field.name}${field.isOptional ? '?' : ''}: ${field.type};\n`;
        });
      interfaceContent += `}\n\n`;
      
      interfaceContent += `export interface ${model.name}UpdateInput {\n`;
      model.fields
        .filter(field => !field.name.includes('Id') && field.name !== 'id' && 
                field.name !== 'createdAt' && field.name !== 'updatedAt')
        .forEach(field => {
          interfaceContent += `  ${field.name}?: ${field.type};\n`;
        });
      interfaceContent += `}\n\n`;
    });
    
    // Write to file
    const outputFile = path.join(typeOutputDir, 'index.ts');
    fs.writeFileSync(outputFile, interfaceContent);
    
    console.log(`‚úÖ Generated TypeScript interfaces in ${outputFile}`);
  } catch (error) {
    console.error('‚ùå Error generating TypeScript interfaces:', error);
    process.exit(1);
  }
}

generateTypeInterfaces(); 