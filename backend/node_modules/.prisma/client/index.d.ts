
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "User"
  objects: {
    projects: ProjectPayload<ExtArgs>[]
    ownedProjects: ProjectPayload<ExtArgs>[]
    tasks: TaskPayload<ExtArgs>[]
    createdTasks: TaskPayload<ExtArgs>[]
    messages: MessagePayload<ExtArgs>[]
    documents: DocumentPayload<ExtArgs>[]
    campaigns: CampaignPayload<ExtArgs>[]
    managedAgents: AIAgentPayload<ExtArgs>[]
    feedback: FeedbackPayload<ExtArgs>[]
    personalizationProfile: PersonalizationProfilePayload<ExtArgs> | null
    outreachResponses: OutreachTaskPayload<ExtArgs>[]
    createdContent: GeneratedContentPayload<ExtArgs>[]
    integrationCredentials: IntegrationCredentialPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    email: string
    name: string
    password: string
    role: Role
    avatar: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type ProjectPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Project"
  objects: {
    owner: UserPayload<ExtArgs>
    members: UserPayload<ExtArgs>[]
    tasks: TaskPayload<ExtArgs>[]
    messages: MessagePayload<ExtArgs>[]
    documents: DocumentPayload<ExtArgs>[]
    campaigns: CampaignPayload<ExtArgs>[]
    aiAgents: AIAgentPayload<ExtArgs>[]
    metrics: MetricPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    ownerId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["project"]>
  composites: {}
}

/**
 * Model Project
 * 
 */
export type Project = runtime.Types.DefaultSelection<ProjectPayload>
export type TaskPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Task"
  objects: {
    project: ProjectPayload<ExtArgs>
    assignee: UserPayload<ExtArgs> | null
    creator: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    title: string
    description: string | null
    status: TaskStatus
    priority: Priority
    dueDate: Date | null
    projectId: string
    assigneeId: string | null
    creatorId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["task"]>
  composites: {}
}

/**
 * Model Task
 * 
 */
export type Task = runtime.Types.DefaultSelection<TaskPayload>
export type MessagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Message"
  objects: {
    project: ProjectPayload<ExtArgs>
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    content: string
    projectId: string
    userId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["message"]>
  composites: {}
}

/**
 * Model Message
 * 
 */
export type Message = runtime.Types.DefaultSelection<MessagePayload>
export type DocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Document"
  objects: {
    project: ProjectPayload<ExtArgs>
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    projectId: string
    userId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["document"]>
  composites: {}
}

/**
 * Model Document
 * 
 */
export type Document = runtime.Types.DefaultSelection<DocumentPayload>
export type AIAgentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "AIAgent"
  objects: {
    project: ProjectPayload<ExtArgs>
    manager: UserPayload<ExtArgs>
    generatedContent: GeneratedContentPayload<ExtArgs>[]
    campaigns: CampaignPayload<ExtArgs>[]
    trendSignals: TrendSignalPayload<ExtArgs>[]
    executionSessions: AgentExecutionSessionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    agentType: AgentType
    configuration: Prisma.JsonValue
    lastRunAt: Date | null
    nextRunAt: Date | null
    scheduleExpression: string | null
    scheduleEnabled: boolean
    status: AgentStatus
    projectId: string
    managerId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["aIAgent"]>
  composites: {}
}

/**
 * Model AIAgent
 * 
 */
export type AIAgent = runtime.Types.DefaultSelection<AIAgentPayload>
export type AgentExecutionSessionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "AgentExecutionSession"
  objects: {
    agent: AIAgentPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    agentId: string
    startedAt: Date
    completedAt: Date | null
    success: boolean | null
    duration: number | null
    outputSummary: string | null
    logs: Prisma.JsonValue | null
    context: Prisma.JsonValue | null
    metrics: Prisma.JsonValue | null
    errorMessage: string | null
    createdAt: Date
  }, ExtArgs["result"]["agentExecutionSession"]>
  composites: {}
}

/**
 * Model AgentExecutionSession
 * 
 */
export type AgentExecutionSession = runtime.Types.DefaultSelection<AgentExecutionSessionPayload>
export type CampaignPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Campaign"
  objects: {
    owner: UserPayload<ExtArgs>
    project: ProjectPayload<ExtArgs>
    agents: AIAgentPayload<ExtArgs>[]
    generatedContent: GeneratedContentPayload<ExtArgs>[]
    outreachTasks: OutreachTaskPayload<ExtArgs>[]
    metrics: MetricPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    status: CampaignStatus
    campaignType: CampaignType
    goals: Prisma.JsonValue
    targeting: Prisma.JsonValue
    budget: number | null
    startDate: Date | null
    endDate: Date | null
    ownerId: string
    projectId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["campaign"]>
  composites: {}
}

/**
 * Model Campaign
 * 
 */
export type Campaign = runtime.Types.DefaultSelection<CampaignPayload>
export type GeneratedContentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "GeneratedContent"
  objects: {
    agent: AIAgentPayload<ExtArgs>
    campaign: CampaignPayload<ExtArgs> | null
    creator: UserPayload<ExtArgs> | null
    feedback: FeedbackPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    title: string
    content: string
    contentType: ContentType
    platform: Platform | null
    status: ContentStatus
    metadata: Prisma.JsonValue | null
    agentId: string
    campaignId: string | null
    creatorId: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["generatedContent"]>
  composites: {}
}

/**
 * Model GeneratedContent
 * 
 */
export type GeneratedContent = runtime.Types.DefaultSelection<GeneratedContentPayload>
export type OutreachTaskPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OutreachTask"
  objects: {
    responseHandler: UserPayload<ExtArgs> | null
    campaign: CampaignPayload<ExtArgs>
    feedback: FeedbackPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    title: string
    description: string | null
    outreachType: OutreachType
    status: OutreachStatus
    leadInfo: Prisma.JsonValue
    contactMethod: ContactMethod
    aiResponse: string | null
    responseHandlerId: string | null
    campaignId: string
    scheduledAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["outreachTask"]>
  composites: {}
}

/**
 * Model OutreachTask
 * 
 */
export type OutreachTask = runtime.Types.DefaultSelection<OutreachTaskPayload>
export type TrendSignalPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "TrendSignal"
  objects: {
    agent: AIAgentPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    title: string
    description: string
    source: string
    signalType: SignalType
    confidence: number
    rawData: Prisma.JsonValue | null
    impact: TrendImpact
    agentId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["trendSignal"]>
  composites: {}
}

/**
 * Model TrendSignal
 * 
 */
export type TrendSignal = runtime.Types.DefaultSelection<TrendSignalPayload>
export type IntegrationCredentialPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "IntegrationCredential"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    platform: string
    accountIdentifier: string | null
    authToken: string
    refreshToken: string | null
    tokenType: string | null
    expiry: Date | null
    scopes: string[]
    metadata: Prisma.JsonValue | null
    userId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["integrationCredential"]>
  composites: {}
}

/**
 * Model IntegrationCredential
 * 
 */
export type IntegrationCredential = runtime.Types.DefaultSelection<IntegrationCredentialPayload>
export type MetricPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Metric"
  objects: {
    campaign: CampaignPayload<ExtArgs> | null
    project: ProjectPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    source: string
    value: number
    unit: string | null
    dimension: string | null
    campaignId: string | null
    projectId: string | null
    timestamp: Date
    metadata: Prisma.JsonValue | null
  }, ExtArgs["result"]["metric"]>
  composites: {}
}

/**
 * Model Metric
 * 
 */
export type Metric = runtime.Types.DefaultSelection<MetricPayload>
export type PersonalizationProfilePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PersonalizationProfile"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    behaviorCluster: string
    interestAffinity: Prisma.JsonValue
    engagementScore: number
    contentPreferences: Prisma.JsonValue
    activeHours: Prisma.JsonValue | null
    devicePreference: string | null
    clickPatterns: Prisma.JsonValue | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["personalizationProfile"]>
  composites: {}
}

/**
 * Model PersonalizationProfile
 * 
 */
export type PersonalizationProfile = runtime.Types.DefaultSelection<PersonalizationProfilePayload>
export type FeedbackPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Feedback"
  objects: {
    user: UserPayload<ExtArgs>
    content_rel: GeneratedContentPayload<ExtArgs> | null
    outreachTask: OutreachTaskPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    userId: string
    contentId: string | null
    outreachTaskId: string | null
    createdAt: Date
  }, ExtArgs["result"]["feedback"]>
  composites: {}
}

/**
 * Model Feedback
 * 
 */
export type Feedback = runtime.Types.DefaultSelection<FeedbackPayload>

/**
 * Enums
 */

export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const TaskStatus: {
  TODO: 'TODO',
  IN_PROGRESS: 'IN_PROGRESS',
  REVIEW: 'REVIEW',
  DONE: 'DONE'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const AgentType: {
  CONTENT_CREATOR: 'CONTENT_CREATOR',
  TREND_ANALYZER: 'TREND_ANALYZER',
  OUTREACH_MANAGER: 'OUTREACH_MANAGER',
  PERFORMANCE_OPTIMIZER: 'PERFORMANCE_OPTIMIZER',
  AUDIENCE_RESEARCHER: 'AUDIENCE_RESEARCHER',
  COPYWRITER: 'COPYWRITER',
  SOCIAL_MEDIA_MANAGER: 'SOCIAL_MEDIA_MANAGER',
  EMAIL_MARKETER: 'EMAIL_MARKETER',
  SEO_SPECIALIST: 'SEO_SPECIALIST',
  CUSTOMER_SUPPORT: 'CUSTOMER_SUPPORT'
};

export type AgentType = (typeof AgentType)[keyof typeof AgentType]


export const AgentStatus: {
  IDLE: 'IDLE',
  RUNNING: 'RUNNING',
  ERROR: 'ERROR',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED'
};

export type AgentStatus = (typeof AgentStatus)[keyof typeof AgentStatus]


export const CampaignStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  ARCHIVED: 'ARCHIVED'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]


export const CampaignType: {
  SOCIAL_MEDIA: 'SOCIAL_MEDIA',
  EMAIL: 'EMAIL',
  CONTENT_MARKETING: 'CONTENT_MARKETING',
  SEO: 'SEO',
  PPC: 'PPC',
  INFLUENCER: 'INFLUENCER',
  AFFILIATE: 'AFFILIATE',
  EVENT: 'EVENT',
  PR: 'PR',
  INTEGRATED: 'INTEGRATED'
};

export type CampaignType = (typeof CampaignType)[keyof typeof CampaignType]


export const ContentType: {
  BLOG_POST: 'BLOG_POST',
  SOCIAL_POST: 'SOCIAL_POST',
  EMAIL: 'EMAIL',
  AD_COPY: 'AD_COPY',
  LANDING_PAGE: 'LANDING_PAGE',
  VIDEO_SCRIPT: 'VIDEO_SCRIPT',
  PRODUCT_DESCRIPTION: 'PRODUCT_DESCRIPTION',
  PRESS_RELEASE: 'PRESS_RELEASE',
  NEWSLETTER: 'NEWSLETTER',
  INFOGRAPHIC: 'INFOGRAPHIC'
};

export type ContentType = (typeof ContentType)[keyof typeof ContentType]


export const Platform: {
  FACEBOOK: 'FACEBOOK',
  INSTAGRAM: 'INSTAGRAM',
  TWITTER: 'TWITTER',
  LINKEDIN: 'LINKEDIN',
  TIKTOK: 'TIKTOK',
  YOUTUBE: 'YOUTUBE',
  WEBSITE: 'WEBSITE',
  EMAIL: 'EMAIL',
  GOOGLE: 'GOOGLE',
  PINTEREST: 'PINTEREST'
};

export type Platform = (typeof Platform)[keyof typeof Platform]


export const ContentStatus: {
  DRAFT: 'DRAFT',
  REVIEW: 'REVIEW',
  APPROVED: 'APPROVED',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED',
  REJECTED: 'REJECTED'
};

export type ContentStatus = (typeof ContentStatus)[keyof typeof ContentStatus]


export const OutreachType: {
  COLD_EMAIL: 'COLD_EMAIL',
  SOCIAL_OUTREACH: 'SOCIAL_OUTREACH',
  FOLLOW_UP: 'FOLLOW_UP',
  DEMO_REQUEST: 'DEMO_REQUEST',
  PARTNERSHIP: 'PARTNERSHIP',
  INFLUENCER_OUTREACH: 'INFLUENCER_OUTREACH',
  CUSTOMER_REENGAGEMENT: 'CUSTOMER_REENGAGEMENT',
  LEAD_QUALIFICATION: 'LEAD_QUALIFICATION'
};

export type OutreachType = (typeof OutreachType)[keyof typeof OutreachType]


export const OutreachStatus: {
  PENDING: 'PENDING',
  SCHEDULED: 'SCHEDULED',
  SENT: 'SENT',
  RESPONDED: 'RESPONDED',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type OutreachStatus = (typeof OutreachStatus)[keyof typeof OutreachStatus]


export const ContactMethod: {
  EMAIL: 'EMAIL',
  LINKEDIN: 'LINKEDIN',
  TWITTER: 'TWITTER',
  PHONE: 'PHONE',
  INSTAGRAM: 'INSTAGRAM',
  FACEBOOK: 'FACEBOOK',
  IN_PERSON: 'IN_PERSON',
  OTHER: 'OTHER'
};

export type ContactMethod = (typeof ContactMethod)[keyof typeof ContactMethod]


export const SignalType: {
  KEYWORD_TREND: 'KEYWORD_TREND',
  TOPIC_EMERGENCE: 'TOPIC_EMERGENCE',
  SENTIMENT_SHIFT: 'SENTIMENT_SHIFT',
  COMPETITION_MOVE: 'COMPETITION_MOVE',
  INDUSTRY_NEWS: 'INDUSTRY_NEWS',
  REGULATORY_CHANGE: 'REGULATORY_CHANGE',
  VIRAL_CONTENT: 'VIRAL_CONTENT',
  MARKET_OPPORTUNITY: 'MARKET_OPPORTUNITY'
};

export type SignalType = (typeof SignalType)[keyof typeof SignalType]


export const TrendImpact: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type TrendImpact = (typeof TrendImpact)[keyof typeof TrendImpact]


export const FeedbackChannel: {
  IN_APP: 'IN_APP',
  EMAIL: 'EMAIL',
  SURVEY: 'SURVEY',
  SOCIAL_MEDIA: 'SOCIAL_MEDIA',
  CUSTOMER_SUPPORT: 'CUSTOMER_SUPPORT',
  REVIEW: 'REVIEW'
};

export type FeedbackChannel = (typeof FeedbackChannel)[keyof typeof FeedbackChannel]


export const Sentiment: {
  VERY_NEGATIVE: 'VERY_NEGATIVE',
  NEGATIVE: 'NEGATIVE',
  NEUTRAL: 'NEUTRAL',
  POSITIVE: 'POSITIVE',
  VERY_POSITIVE: 'VERY_POSITIVE'
};

export type Sentiment = (typeof Sentiment)[keyof typeof Sentiment]


export const FeedbackSource: {
  CONTENT: 'CONTENT',
  OUTREACH: 'OUTREACH',
  CAMPAIGN: 'CAMPAIGN',
  PLATFORM: 'PLATFORM',
  AGENT: 'AGENT'
};

export type FeedbackSource = (typeof FeedbackSource)[keyof typeof FeedbackSource]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.aIAgent`: Exposes CRUD operations for the **AIAgent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIAgents
    * const aIAgents = await prisma.aIAgent.findMany()
    * ```
    */
  get aIAgent(): Prisma.AIAgentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.agentExecutionSession`: Exposes CRUD operations for the **AgentExecutionSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentExecutionSessions
    * const agentExecutionSessions = await prisma.agentExecutionSession.findMany()
    * ```
    */
  get agentExecutionSession(): Prisma.AgentExecutionSessionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.generatedContent`: Exposes CRUD operations for the **GeneratedContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeneratedContents
    * const generatedContents = await prisma.generatedContent.findMany()
    * ```
    */
  get generatedContent(): Prisma.GeneratedContentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.outreachTask`: Exposes CRUD operations for the **OutreachTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutreachTasks
    * const outreachTasks = await prisma.outreachTask.findMany()
    * ```
    */
  get outreachTask(): Prisma.OutreachTaskDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.trendSignal`: Exposes CRUD operations for the **TrendSignal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrendSignals
    * const trendSignals = await prisma.trendSignal.findMany()
    * ```
    */
  get trendSignal(): Prisma.TrendSignalDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.integrationCredential`: Exposes CRUD operations for the **IntegrationCredential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntegrationCredentials
    * const integrationCredentials = await prisma.integrationCredential.findMany()
    * ```
    */
  get integrationCredential(): Prisma.IntegrationCredentialDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.metric`: Exposes CRUD operations for the **Metric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metrics
    * const metrics = await prisma.metric.findMany()
    * ```
    */
  get metric(): Prisma.MetricDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.personalizationProfile`: Exposes CRUD operations for the **PersonalizationProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalizationProfiles
    * const personalizationProfiles = await prisma.personalizationProfile.findMany()
    * ```
    */
  get personalizationProfile(): Prisma.PersonalizationProfileDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Project: 'Project',
    Task: 'Task',
    Message: 'Message',
    Document: 'Document',
    AIAgent: 'AIAgent',
    AgentExecutionSession: 'AgentExecutionSession',
    Campaign: 'Campaign',
    GeneratedContent: 'GeneratedContent',
    OutreachTask: 'OutreachTask',
    TrendSignal: 'TrendSignal',
    IntegrationCredential: 'IntegrationCredential',
    Metric: 'Metric',
    PersonalizationProfile: 'PersonalizationProfile',
    Feedback: 'Feedback'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'project' | 'task' | 'message' | 'document' | 'aIAgent' | 'agentExecutionSession' | 'campaign' | 'generatedContent' | 'outreachTask' | 'trendSignal' | 'integrationCredential' | 'metric' | 'personalizationProfile' | 'feedback'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: UserPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: ProjectPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>,
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: TaskPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>,
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: MessagePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: DocumentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      AIAgent: {
        payload: AIAgentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AIAgentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIAgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIAgentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIAgentPayload>
          }
          findFirst: {
            args: Prisma.AIAgentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIAgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIAgentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIAgentPayload>
          }
          findMany: {
            args: Prisma.AIAgentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIAgentPayload>[]
          }
          create: {
            args: Prisma.AIAgentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIAgentPayload>
          }
          createMany: {
            args: Prisma.AIAgentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AIAgentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIAgentPayload>
          }
          update: {
            args: Prisma.AIAgentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIAgentPayload>
          }
          deleteMany: {
            args: Prisma.AIAgentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AIAgentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AIAgentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AIAgentPayload>
          }
          aggregate: {
            args: Prisma.AIAgentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAIAgent>
          }
          groupBy: {
            args: Prisma.AIAgentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AIAgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIAgentCountArgs<ExtArgs>,
            result: $Utils.Optional<AIAgentCountAggregateOutputType> | number
          }
        }
      }
      AgentExecutionSession: {
        payload: AgentExecutionSessionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AgentExecutionSessionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentExecutionSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentExecutionSessionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentExecutionSessionPayload>
          }
          findFirst: {
            args: Prisma.AgentExecutionSessionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentExecutionSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentExecutionSessionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentExecutionSessionPayload>
          }
          findMany: {
            args: Prisma.AgentExecutionSessionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentExecutionSessionPayload>[]
          }
          create: {
            args: Prisma.AgentExecutionSessionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentExecutionSessionPayload>
          }
          createMany: {
            args: Prisma.AgentExecutionSessionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AgentExecutionSessionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentExecutionSessionPayload>
          }
          update: {
            args: Prisma.AgentExecutionSessionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentExecutionSessionPayload>
          }
          deleteMany: {
            args: Prisma.AgentExecutionSessionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgentExecutionSessionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgentExecutionSessionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgentExecutionSessionPayload>
          }
          aggregate: {
            args: Prisma.AgentExecutionSessionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgentExecutionSession>
          }
          groupBy: {
            args: Prisma.AgentExecutionSessionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgentExecutionSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentExecutionSessionCountArgs<ExtArgs>,
            result: $Utils.Optional<AgentExecutionSessionCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: CampaignPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>,
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      GeneratedContent: {
        payload: GeneratedContentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.GeneratedContentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GeneratedContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeneratedContentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GeneratedContentPayload>
          }
          findFirst: {
            args: Prisma.GeneratedContentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GeneratedContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeneratedContentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GeneratedContentPayload>
          }
          findMany: {
            args: Prisma.GeneratedContentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GeneratedContentPayload>[]
          }
          create: {
            args: Prisma.GeneratedContentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GeneratedContentPayload>
          }
          createMany: {
            args: Prisma.GeneratedContentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GeneratedContentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GeneratedContentPayload>
          }
          update: {
            args: Prisma.GeneratedContentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GeneratedContentPayload>
          }
          deleteMany: {
            args: Prisma.GeneratedContentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GeneratedContentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GeneratedContentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GeneratedContentPayload>
          }
          aggregate: {
            args: Prisma.GeneratedContentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGeneratedContent>
          }
          groupBy: {
            args: Prisma.GeneratedContentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GeneratedContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeneratedContentCountArgs<ExtArgs>,
            result: $Utils.Optional<GeneratedContentCountAggregateOutputType> | number
          }
        }
      }
      OutreachTask: {
        payload: OutreachTaskPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.OutreachTaskFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutreachTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutreachTaskFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutreachTaskPayload>
          }
          findFirst: {
            args: Prisma.OutreachTaskFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutreachTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutreachTaskFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutreachTaskPayload>
          }
          findMany: {
            args: Prisma.OutreachTaskFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutreachTaskPayload>[]
          }
          create: {
            args: Prisma.OutreachTaskCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutreachTaskPayload>
          }
          createMany: {
            args: Prisma.OutreachTaskCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OutreachTaskDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutreachTaskPayload>
          }
          update: {
            args: Prisma.OutreachTaskUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutreachTaskPayload>
          }
          deleteMany: {
            args: Prisma.OutreachTaskDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OutreachTaskUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OutreachTaskUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutreachTaskPayload>
          }
          aggregate: {
            args: Prisma.OutreachTaskAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOutreachTask>
          }
          groupBy: {
            args: Prisma.OutreachTaskGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OutreachTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutreachTaskCountArgs<ExtArgs>,
            result: $Utils.Optional<OutreachTaskCountAggregateOutputType> | number
          }
        }
      }
      TrendSignal: {
        payload: TrendSignalPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TrendSignalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrendSignalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrendSignalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrendSignalPayload>
          }
          findFirst: {
            args: Prisma.TrendSignalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrendSignalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrendSignalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrendSignalPayload>
          }
          findMany: {
            args: Prisma.TrendSignalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrendSignalPayload>[]
          }
          create: {
            args: Prisma.TrendSignalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrendSignalPayload>
          }
          createMany: {
            args: Prisma.TrendSignalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TrendSignalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrendSignalPayload>
          }
          update: {
            args: Prisma.TrendSignalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrendSignalPayload>
          }
          deleteMany: {
            args: Prisma.TrendSignalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TrendSignalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TrendSignalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrendSignalPayload>
          }
          aggregate: {
            args: Prisma.TrendSignalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTrendSignal>
          }
          groupBy: {
            args: Prisma.TrendSignalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrendSignalGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrendSignalCountArgs<ExtArgs>,
            result: $Utils.Optional<TrendSignalCountAggregateOutputType> | number
          }
        }
      }
      IntegrationCredential: {
        payload: IntegrationCredentialPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.IntegrationCredentialFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<IntegrationCredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationCredentialFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<IntegrationCredentialPayload>
          }
          findFirst: {
            args: Prisma.IntegrationCredentialFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<IntegrationCredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationCredentialFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<IntegrationCredentialPayload>
          }
          findMany: {
            args: Prisma.IntegrationCredentialFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<IntegrationCredentialPayload>[]
          }
          create: {
            args: Prisma.IntegrationCredentialCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<IntegrationCredentialPayload>
          }
          createMany: {
            args: Prisma.IntegrationCredentialCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.IntegrationCredentialDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<IntegrationCredentialPayload>
          }
          update: {
            args: Prisma.IntegrationCredentialUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<IntegrationCredentialPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationCredentialDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationCredentialUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IntegrationCredentialUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<IntegrationCredentialPayload>
          }
          aggregate: {
            args: Prisma.IntegrationCredentialAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIntegrationCredential>
          }
          groupBy: {
            args: Prisma.IntegrationCredentialGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IntegrationCredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationCredentialCountArgs<ExtArgs>,
            result: $Utils.Optional<IntegrationCredentialCountAggregateOutputType> | number
          }
        }
      }
      Metric: {
        payload: MetricPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.MetricFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetricFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MetricPayload>
          }
          findFirst: {
            args: Prisma.MetricFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetricFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MetricPayload>
          }
          findMany: {
            args: Prisma.MetricFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MetricPayload>[]
          }
          create: {
            args: Prisma.MetricCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MetricPayload>
          }
          createMany: {
            args: Prisma.MetricCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MetricDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MetricPayload>
          }
          update: {
            args: Prisma.MetricUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MetricPayload>
          }
          deleteMany: {
            args: Prisma.MetricDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MetricUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MetricUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MetricPayload>
          }
          aggregate: {
            args: Prisma.MetricAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMetric>
          }
          groupBy: {
            args: Prisma.MetricGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetricCountArgs<ExtArgs>,
            result: $Utils.Optional<MetricCountAggregateOutputType> | number
          }
        }
      }
      PersonalizationProfile: {
        payload: PersonalizationProfilePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PersonalizationProfileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalizationProfileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationProfilePayload>
          }
          findFirst: {
            args: Prisma.PersonalizationProfileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalizationProfileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationProfilePayload>
          }
          findMany: {
            args: Prisma.PersonalizationProfileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationProfilePayload>[]
          }
          create: {
            args: Prisma.PersonalizationProfileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationProfilePayload>
          }
          createMany: {
            args: Prisma.PersonalizationProfileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PersonalizationProfileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationProfilePayload>
          }
          update: {
            args: Prisma.PersonalizationProfileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationProfilePayload>
          }
          deleteMany: {
            args: Prisma.PersonalizationProfileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalizationProfileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PersonalizationProfileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationProfilePayload>
          }
          aggregate: {
            args: Prisma.PersonalizationProfileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePersonalizationProfile>
          }
          groupBy: {
            args: Prisma.PersonalizationProfileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PersonalizationProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalizationProfileCountArgs<ExtArgs>,
            result: $Utils.Optional<PersonalizationProfileCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: FeedbackPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    projects: number
    ownedProjects: number
    tasks: number
    createdTasks: number
    messages: number
    documents: number
    campaigns: number
    managedAgents: number
    feedback: number
    outreachResponses: number
    createdContent: number
    integrationCredentials: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    ownedProjects?: boolean | UserCountOutputTypeCountOwnedProjectsArgs
    tasks?: boolean | UserCountOutputTypeCountTasksArgs
    createdTasks?: boolean | UserCountOutputTypeCountCreatedTasksArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    campaigns?: boolean | UserCountOutputTypeCountCampaignsArgs
    managedAgents?: boolean | UserCountOutputTypeCountManagedAgentsArgs
    feedback?: boolean | UserCountOutputTypeCountFeedbackArgs
    outreachResponses?: boolean | UserCountOutputTypeCountOutreachResponsesArgs
    createdContent?: boolean | UserCountOutputTypeCountCreatedContentArgs
    integrationCredentials?: boolean | UserCountOutputTypeCountIntegrationCredentialsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedProjectsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTasksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManagedAgentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AIAgentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOutreachResponsesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OutreachTaskWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedContentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GeneratedContentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIntegrationCredentialsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: IntegrationCredentialWhereInput
  }



  /**
   * Count Type ProjectCountOutputType
   */


  export type ProjectCountOutputType = {
    members: number
    tasks: number
    messages: number
    documents: number
    campaigns: number
    aiAgents: number
    metrics: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs
    messages?: boolean | ProjectCountOutputTypeCountMessagesArgs
    documents?: boolean | ProjectCountOutputTypeCountDocumentsArgs
    campaigns?: boolean | ProjectCountOutputTypeCountCampaignsArgs
    aiAgents?: boolean | ProjectCountOutputTypeCountAiAgentsArgs
    metrics?: boolean | ProjectCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAiAgentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AIAgentWhereInput
  }


  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MetricWhereInput
  }



  /**
   * Count Type AIAgentCountOutputType
   */


  export type AIAgentCountOutputType = {
    generatedContent: number
    campaigns: number
    trendSignals: number
    executionSessions: number
  }

  export type AIAgentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    generatedContent?: boolean | AIAgentCountOutputTypeCountGeneratedContentArgs
    campaigns?: boolean | AIAgentCountOutputTypeCountCampaignsArgs
    trendSignals?: boolean | AIAgentCountOutputTypeCountTrendSignalsArgs
    executionSessions?: boolean | AIAgentCountOutputTypeCountExecutionSessionsArgs
  }

  // Custom InputTypes

  /**
   * AIAgentCountOutputType without action
   */
  export type AIAgentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentCountOutputType
     */
    select?: AIAgentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AIAgentCountOutputType without action
   */
  export type AIAgentCountOutputTypeCountGeneratedContentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GeneratedContentWhereInput
  }


  /**
   * AIAgentCountOutputType without action
   */
  export type AIAgentCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * AIAgentCountOutputType without action
   */
  export type AIAgentCountOutputTypeCountTrendSignalsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TrendSignalWhereInput
  }


  /**
   * AIAgentCountOutputType without action
   */
  export type AIAgentCountOutputTypeCountExecutionSessionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AgentExecutionSessionWhereInput
  }



  /**
   * Count Type CampaignCountOutputType
   */


  export type CampaignCountOutputType = {
    agents: number
    generatedContent: number
    outreachTasks: number
    metrics: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    agents?: boolean | CampaignCountOutputTypeCountAgentsArgs
    generatedContent?: boolean | CampaignCountOutputTypeCountGeneratedContentArgs
    outreachTasks?: boolean | CampaignCountOutputTypeCountOutreachTasksArgs
    metrics?: boolean | CampaignCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AIAgentWhereInput
  }


  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountGeneratedContentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GeneratedContentWhereInput
  }


  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountOutreachTasksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OutreachTaskWhereInput
  }


  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MetricWhereInput
  }



  /**
   * Count Type GeneratedContentCountOutputType
   */


  export type GeneratedContentCountOutputType = {
    feedback: number
  }

  export type GeneratedContentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    feedback?: boolean | GeneratedContentCountOutputTypeCountFeedbackArgs
  }

  // Custom InputTypes

  /**
   * GeneratedContentCountOutputType without action
   */
  export type GeneratedContentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContentCountOutputType
     */
    select?: GeneratedContentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GeneratedContentCountOutputType without action
   */
  export type GeneratedContentCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }



  /**
   * Count Type OutreachTaskCountOutputType
   */


  export type OutreachTaskCountOutputType = {
    feedback: number
  }

  export type OutreachTaskCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    feedback?: boolean | OutreachTaskCountOutputTypeCountFeedbackArgs
  }

  // Custom InputTypes

  /**
   * OutreachTaskCountOutputType without action
   */
  export type OutreachTaskCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutreachTaskCountOutputType
     */
    select?: OutreachTaskCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OutreachTaskCountOutputType without action
   */
  export type OutreachTaskCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: Role | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: Role | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    role: number
    avatar: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    role: Role
    avatar: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projects?: boolean | User$projectsArgs<ExtArgs>
    ownedProjects?: boolean | User$ownedProjectsArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    createdTasks?: boolean | User$createdTasksArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    managedAgents?: boolean | User$managedAgentsArgs<ExtArgs>
    feedback?: boolean | User$feedbackArgs<ExtArgs>
    personalizationProfile?: boolean | PersonalizationProfileArgs<ExtArgs>
    outreachResponses?: boolean | User$outreachResponsesArgs<ExtArgs>
    createdContent?: boolean | User$createdContentArgs<ExtArgs>
    integrationCredentials?: boolean | User$integrationCredentialsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    projects?: boolean | User$projectsArgs<ExtArgs>
    ownedProjects?: boolean | User$ownedProjectsArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    createdTasks?: boolean | User$createdTasksArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    managedAgents?: boolean | User$managedAgentsArgs<ExtArgs>
    feedback?: boolean | User$feedbackArgs<ExtArgs>
    personalizationProfile?: boolean | PersonalizationProfileArgs<ExtArgs>
    outreachResponses?: boolean | User$outreachResponsesArgs<ExtArgs>
    createdContent?: boolean | User$createdContentArgs<ExtArgs>
    integrationCredentials?: boolean | User$integrationCredentialsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findMany', never>| Null>;

    ownedProjects<T extends User$ownedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findMany', never>| Null>;

    tasks<T extends User$tasksArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TaskPayload<ExtArgs>, T, 'findMany', never>| Null>;

    createdTasks<T extends User$createdTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TaskPayload<ExtArgs>, T, 'findMany', never>| Null>;

    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findMany', never>| Null>;

    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    campaigns<T extends User$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'findMany', never>| Null>;

    managedAgents<T extends User$managedAgentsArgs<ExtArgs> = {}>(args?: Subset<T, User$managedAgentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    feedback<T extends User$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'findMany', never>| Null>;

    personalizationProfile<T extends PersonalizationProfileArgs<ExtArgs> = {}>(args?: Subset<T, PersonalizationProfileArgs<ExtArgs>>): Prisma__PersonalizationProfileClient<$Types.GetResult<PersonalizationProfilePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    outreachResponses<T extends User$outreachResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$outreachResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'findMany', never>| Null>;

    createdContent<T extends User$createdContentArgs<ExtArgs> = {}>(args?: Subset<T, User$createdContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    integrationCredentials<T extends User$integrationCredentialsArgs<ExtArgs> = {}>(args?: Subset<T, User$integrationCredentialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<IntegrationCredentialPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * User.ownedProjects
   */
  export type User$ownedProjectsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * User.tasks
   */
  export type User$tasksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: Enumerable<TaskOrderByWithRelationInput>
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TaskScalarFieldEnum>
  }


  /**
   * User.createdTasks
   */
  export type User$createdTasksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: Enumerable<TaskOrderByWithRelationInput>
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TaskScalarFieldEnum>
  }


  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * User.campaigns
   */
  export type User$campaignsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }


  /**
   * User.managedAgents
   */
  export type User$managedAgentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIAgentInclude<ExtArgs> | null
    where?: AIAgentWhereInput
    orderBy?: Enumerable<AIAgentOrderByWithRelationInput>
    cursor?: AIAgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AIAgentScalarFieldEnum>
  }


  /**
   * User.feedback
   */
  export type User$feedbackArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: Enumerable<FeedbackOrderByWithRelationInput>
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FeedbackScalarFieldEnum>
  }


  /**
   * User.outreachResponses
   */
  export type User$outreachResponsesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutreachTask
     */
    select?: OutreachTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutreachTaskInclude<ExtArgs> | null
    where?: OutreachTaskWhereInput
    orderBy?: Enumerable<OutreachTaskOrderByWithRelationInput>
    cursor?: OutreachTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OutreachTaskScalarFieldEnum>
  }


  /**
   * User.createdContent
   */
  export type User$createdContentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContent
     */
    select?: GeneratedContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GeneratedContentInclude<ExtArgs> | null
    where?: GeneratedContentWhereInput
    orderBy?: Enumerable<GeneratedContentOrderByWithRelationInput>
    cursor?: GeneratedContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GeneratedContentScalarFieldEnum>
  }


  /**
   * User.integrationCredentials
   */
  export type User$integrationCredentialsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCredential
     */
    select?: IntegrationCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IntegrationCredentialInclude<ExtArgs> | null
    where?: IntegrationCredentialWhereInput
    orderBy?: Enumerable<IntegrationCredentialOrderByWithRelationInput>
    cursor?: IntegrationCredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<IntegrationCredentialScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Project
   */


  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: Enumerable<ProjectOrderByWithAggregationInput>
    by: ProjectScalarFieldEnum[]
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }


  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    ownerId: string
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    messages?: boolean | Project$messagesArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    campaigns?: boolean | Project$campaignsArgs<ExtArgs>
    aiAgents?: boolean | Project$aiAgentsArgs<ExtArgs>
    metrics?: boolean | Project$metricsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    owner?: boolean | UserArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    messages?: boolean | Project$messagesArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    campaigns?: boolean | Project$campaignsArgs<ExtArgs>
    aiAgents?: boolean | Project$aiAgentsArgs<ExtArgs>
    metrics?: boolean | Project$metricsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeArgs<ExtArgs>
  }


  type ProjectGetPayload<S extends boolean | null | undefined | ProjectArgs> = $Types.GetResult<ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Project'> extends True ? Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Project'> extends True ? Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
    **/
    create<T extends ProjectCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Projects.
     *     @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     *     @example
     *     // Create many Projects
     *     const project = await prisma.project.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
    **/
    delete<T extends ProjectDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>
    ): Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    owner<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>| Null>;

    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Project$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TaskPayload<ExtArgs>, T, 'findMany', never>| Null>;

    messages<T extends Project$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Project$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findMany', never>| Null>;

    documents<T extends Project$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    campaigns<T extends Project$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Project$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'findMany', never>| Null>;

    aiAgents<T extends Project$aiAgentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$aiAgentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    metrics<T extends Project$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Project$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MetricPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Project base type for findUnique actions
   */
  export type ProjectFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUnique
   */
  export interface ProjectFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProjectFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project base type for findFirst actions
   */
  export type ProjectFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }

  /**
   * Project findFirst
   */
  export interface ProjectFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProjectFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }


  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: Enumerable<ProjectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }


  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }


  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }


  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Project.tasks
   */
  export type Project$tasksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: Enumerable<TaskOrderByWithRelationInput>
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TaskScalarFieldEnum>
  }


  /**
   * Project.messages
   */
  export type Project$messagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Project.documents
   */
  export type Project$documentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Project.campaigns
   */
  export type Project$campaignsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }


  /**
   * Project.aiAgents
   */
  export type Project$aiAgentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIAgentInclude<ExtArgs> | null
    where?: AIAgentWhereInput
    orderBy?: Enumerable<AIAgentOrderByWithRelationInput>
    cursor?: AIAgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AIAgentScalarFieldEnum>
  }


  /**
   * Project.metrics
   */
  export type Project$metricsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetricInclude<ExtArgs> | null
    where?: MetricWhereInput
    orderBy?: Enumerable<MetricOrderByWithRelationInput>
    cursor?: MetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MetricScalarFieldEnum>
  }


  /**
   * Project without action
   */
  export type ProjectArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude<ExtArgs> | null
  }



  /**
   * Model Task
   */


  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: TaskStatus | null
    priority: Priority | null
    dueDate: Date | null
    projectId: string | null
    assigneeId: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: TaskStatus | null
    priority: Priority | null
    dueDate: Date | null
    projectId: string | null
    assigneeId: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    dueDate: number
    projectId: number
    assigneeId: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    projectId?: true
    assigneeId?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    projectId?: true
    assigneeId?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    projectId?: true
    assigneeId?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: Enumerable<TaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: Enumerable<TaskOrderByWithAggregationInput>
    by: TaskScalarFieldEnum[]
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }


  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: TaskStatus
    priority: Priority
    dueDate: Date | null
    projectId: string
    assigneeId: string | null
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    projectId?: boolean
    assigneeId?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectArgs<ExtArgs>
    assignee?: boolean | UserArgs<ExtArgs>
    creator?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    projectId?: boolean
    assigneeId?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectArgs<ExtArgs>
    assignee?: boolean | UserArgs<ExtArgs>
    creator?: boolean | UserArgs<ExtArgs>
  }


  type TaskGetPayload<S extends boolean | null | undefined | TaskArgs> = $Types.GetResult<TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaskFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Task'> extends True ? Prisma__TaskClient<$Types.GetResult<TaskPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TaskClient<$Types.GetResult<TaskPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TaskClient<$Types.GetResult<TaskPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaskFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Task'> extends True ? Prisma__TaskClient<$Types.GetResult<TaskPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TaskClient<$Types.GetResult<TaskPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TaskClient<$Types.GetResult<TaskPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TaskFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TaskPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
    **/
    create<T extends TaskCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskCreateArgs<ExtArgs>>
    ): Prisma__TaskClient<$Types.GetResult<TaskPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Tasks.
     *     @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     *     @example
     *     // Create many Tasks
     *     const task = await prisma.task.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TaskCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
    **/
    delete<T extends TaskDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>
    ): Prisma__TaskClient<$Types.GetResult<TaskPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaskUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>
    ): Prisma__TaskClient<$Types.GetResult<TaskPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaskDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaskUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
    **/
    upsert<T extends TaskUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>
    ): Prisma__TaskClient<$Types.GetResult<TaskPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs<ExtArgs> = {}>(args?: Subset<T, ProjectArgs<ExtArgs>>): Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    assignee<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    creator<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Task base type for findUnique actions
   */
  export type TaskFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUnique
   */
  export interface TaskFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TaskFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }


  /**
   * Task base type for findFirst actions
   */
  export type TaskFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: Enumerable<TaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: Enumerable<TaskScalarFieldEnum>
  }

  /**
   * Task findFirst
   */
  export interface TaskFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TaskFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: Enumerable<TaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: Enumerable<TaskScalarFieldEnum>
  }


  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: Enumerable<TaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: Enumerable<TaskScalarFieldEnum>
  }


  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }


  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: Enumerable<TaskCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }


  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }


  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }


  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }


  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }


  /**
   * Task without action
   */
  export type TaskArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
  }



  /**
   * Model Message
   */


  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    projectId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    projectId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    projectId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    projectId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    projectId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    projectId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithAggregationInput>
    by: MessageScalarFieldEnum[]
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }


  export type MessageGroupByOutputType = {
    id: string
    content: string
    projectId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    projectId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    projectId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }


  type MessageGetPayload<S extends boolean | null | undefined | MessageArgs> = $Types.GetResult<MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Message'> extends True ? Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Message'> extends True ? Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageCreateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs<ExtArgs> = {}>(args?: Subset<T, ProjectArgs<ExtArgs>>): Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Message base type for findUnique actions
   */
  export type MessageFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUnique
   */
  export interface MessageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MessageFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message base type for findFirst actions
   */
  export type MessageFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: Enumerable<MessageScalarFieldEnum>
  }

  /**
   * Message findFirst
   */
  export interface MessageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MessageFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: Enumerable<MessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }


  /**
   * Message without action
   */
  export type MessageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */


  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    projectId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    projectId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    fileUrl: number
    fileType: number
    fileSize: number
    projectId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    projectId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    projectId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    projectId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithAggregationInput>
    by: DocumentScalarFieldEnum[]
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }


  export type DocumentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    projectId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    projectId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    projectId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentArgs> = $Types.GetResult<DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs<ExtArgs> = {}>(args?: Subset<T, ProjectArgs<ExtArgs>>): Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Document base type for findUnique actions
   */
  export type DocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUnique
   */
  export interface DocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document base type for findFirst actions
   */
  export type DocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }

  /**
   * Document findFirst
   */
  export interface DocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: Enumerable<DocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document without action
   */
  export type DocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model AIAgent
   */


  export type AggregateAIAgent = {
    _count: AIAgentCountAggregateOutputType | null
    _min: AIAgentMinAggregateOutputType | null
    _max: AIAgentMaxAggregateOutputType | null
  }

  export type AIAgentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    agentType: AgentType | null
    lastRunAt: Date | null
    nextRunAt: Date | null
    scheduleExpression: string | null
    scheduleEnabled: boolean | null
    status: AgentStatus | null
    projectId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIAgentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    agentType: AgentType | null
    lastRunAt: Date | null
    nextRunAt: Date | null
    scheduleExpression: string | null
    scheduleEnabled: boolean | null
    status: AgentStatus | null
    projectId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIAgentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    agentType: number
    configuration: number
    lastRunAt: number
    nextRunAt: number
    scheduleExpression: number
    scheduleEnabled: number
    status: number
    projectId: number
    managerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIAgentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    agentType?: true
    lastRunAt?: true
    nextRunAt?: true
    scheduleExpression?: true
    scheduleEnabled?: true
    status?: true
    projectId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIAgentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    agentType?: true
    lastRunAt?: true
    nextRunAt?: true
    scheduleExpression?: true
    scheduleEnabled?: true
    status?: true
    projectId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIAgentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    agentType?: true
    configuration?: true
    lastRunAt?: true
    nextRunAt?: true
    scheduleExpression?: true
    scheduleEnabled?: true
    status?: true
    projectId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIAgentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIAgent to aggregate.
     */
    where?: AIAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgents to fetch.
     */
    orderBy?: Enumerable<AIAgentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIAgents
    **/
    _count?: true | AIAgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIAgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIAgentMaxAggregateInputType
  }

  export type GetAIAgentAggregateType<T extends AIAgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAIAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIAgent[P]>
      : GetScalarType<T[P], AggregateAIAgent[P]>
  }




  export type AIAgentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AIAgentWhereInput
    orderBy?: Enumerable<AIAgentOrderByWithAggregationInput>
    by: AIAgentScalarFieldEnum[]
    having?: AIAgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIAgentCountAggregateInputType | true
    _min?: AIAgentMinAggregateInputType
    _max?: AIAgentMaxAggregateInputType
  }


  export type AIAgentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    agentType: AgentType
    configuration: JsonValue
    lastRunAt: Date | null
    nextRunAt: Date | null
    scheduleExpression: string | null
    scheduleEnabled: boolean
    status: AgentStatus
    projectId: string
    managerId: string
    createdAt: Date
    updatedAt: Date
    _count: AIAgentCountAggregateOutputType | null
    _min: AIAgentMinAggregateOutputType | null
    _max: AIAgentMaxAggregateOutputType | null
  }

  type GetAIAgentGroupByPayload<T extends AIAgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AIAgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIAgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIAgentGroupByOutputType[P]>
            : GetScalarType<T[P], AIAgentGroupByOutputType[P]>
        }
      >
    >


  export type AIAgentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    agentType?: boolean
    configuration?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    scheduleExpression?: boolean
    scheduleEnabled?: boolean
    status?: boolean
    projectId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectArgs<ExtArgs>
    manager?: boolean | UserArgs<ExtArgs>
    generatedContent?: boolean | AIAgent$generatedContentArgs<ExtArgs>
    campaigns?: boolean | AIAgent$campaignsArgs<ExtArgs>
    trendSignals?: boolean | AIAgent$trendSignalsArgs<ExtArgs>
    executionSessions?: boolean | AIAgent$executionSessionsArgs<ExtArgs>
    _count?: boolean | AIAgentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["aIAgent"]>

  export type AIAgentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    agentType?: boolean
    configuration?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    scheduleExpression?: boolean
    scheduleEnabled?: boolean
    status?: boolean
    projectId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIAgentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectArgs<ExtArgs>
    manager?: boolean | UserArgs<ExtArgs>
    generatedContent?: boolean | AIAgent$generatedContentArgs<ExtArgs>
    campaigns?: boolean | AIAgent$campaignsArgs<ExtArgs>
    trendSignals?: boolean | AIAgent$trendSignalsArgs<ExtArgs>
    executionSessions?: boolean | AIAgent$executionSessionsArgs<ExtArgs>
    _count?: boolean | AIAgentCountOutputTypeArgs<ExtArgs>
  }


  type AIAgentGetPayload<S extends boolean | null | undefined | AIAgentArgs> = $Types.GetResult<AIAgentPayload, S>

  type AIAgentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AIAgentFindManyArgs, 'select' | 'include'> & {
      select?: AIAgentCountAggregateInputType | true
    }

  export interface AIAgentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIAgent'], meta: { name: 'AIAgent' } }
    /**
     * Find zero or one AIAgent that matches the filter.
     * @param {AIAgentFindUniqueArgs} args - Arguments to find a AIAgent
     * @example
     * // Get one AIAgent
     * const aIAgent = await prisma.aIAgent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AIAgentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AIAgentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AIAgent'> extends True ? Prisma__AIAgentClient<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AIAgentClient<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one AIAgent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AIAgentFindUniqueOrThrowArgs} args - Arguments to find a AIAgent
     * @example
     * // Get one AIAgent
     * const aIAgent = await prisma.aIAgent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AIAgentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AIAgentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AIAgentClient<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first AIAgent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentFindFirstArgs} args - Arguments to find a AIAgent
     * @example
     * // Get one AIAgent
     * const aIAgent = await prisma.aIAgent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AIAgentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AIAgentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AIAgent'> extends True ? Prisma__AIAgentClient<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AIAgentClient<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first AIAgent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentFindFirstOrThrowArgs} args - Arguments to find a AIAgent
     * @example
     * // Get one AIAgent
     * const aIAgent = await prisma.aIAgent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AIAgentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AIAgentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AIAgentClient<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more AIAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIAgents
     * const aIAgents = await prisma.aIAgent.findMany()
     * 
     * // Get first 10 AIAgents
     * const aIAgents = await prisma.aIAgent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIAgentWithIdOnly = await prisma.aIAgent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AIAgentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AIAgentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a AIAgent.
     * @param {AIAgentCreateArgs} args - Arguments to create a AIAgent.
     * @example
     * // Create one AIAgent
     * const AIAgent = await prisma.aIAgent.create({
     *   data: {
     *     // ... data to create a AIAgent
     *   }
     * })
     * 
    **/
    create<T extends AIAgentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AIAgentCreateArgs<ExtArgs>>
    ): Prisma__AIAgentClient<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many AIAgents.
     *     @param {AIAgentCreateManyArgs} args - Arguments to create many AIAgents.
     *     @example
     *     // Create many AIAgents
     *     const aIAgent = await prisma.aIAgent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AIAgentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AIAgentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AIAgent.
     * @param {AIAgentDeleteArgs} args - Arguments to delete one AIAgent.
     * @example
     * // Delete one AIAgent
     * const AIAgent = await prisma.aIAgent.delete({
     *   where: {
     *     // ... filter to delete one AIAgent
     *   }
     * })
     * 
    **/
    delete<T extends AIAgentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AIAgentDeleteArgs<ExtArgs>>
    ): Prisma__AIAgentClient<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one AIAgent.
     * @param {AIAgentUpdateArgs} args - Arguments to update one AIAgent.
     * @example
     * // Update one AIAgent
     * const aIAgent = await prisma.aIAgent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AIAgentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AIAgentUpdateArgs<ExtArgs>>
    ): Prisma__AIAgentClient<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more AIAgents.
     * @param {AIAgentDeleteManyArgs} args - Arguments to filter AIAgents to delete.
     * @example
     * // Delete a few AIAgents
     * const { count } = await prisma.aIAgent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AIAgentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AIAgentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIAgents
     * const aIAgent = await prisma.aIAgent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AIAgentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AIAgentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIAgent.
     * @param {AIAgentUpsertArgs} args - Arguments to update or create a AIAgent.
     * @example
     * // Update or create a AIAgent
     * const aIAgent = await prisma.aIAgent.upsert({
     *   create: {
     *     // ... data to create a AIAgent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIAgent we want to update
     *   }
     * })
    **/
    upsert<T extends AIAgentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AIAgentUpsertArgs<ExtArgs>>
    ): Prisma__AIAgentClient<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of AIAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentCountArgs} args - Arguments to filter AIAgents to count.
     * @example
     * // Count the number of AIAgents
     * const count = await prisma.aIAgent.count({
     *   where: {
     *     // ... the filter for the AIAgents we want to count
     *   }
     * })
    **/
    count<T extends AIAgentCountArgs>(
      args?: Subset<T, AIAgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIAgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIAgentAggregateArgs>(args: Subset<T, AIAgentAggregateArgs>): Prisma.PrismaPromise<GetAIAgentAggregateType<T>>

    /**
     * Group by AIAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIAgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIAgentGroupByArgs['orderBy'] }
        : { orderBy?: AIAgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIAgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AIAgent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AIAgentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs<ExtArgs> = {}>(args?: Subset<T, ProjectArgs<ExtArgs>>): Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    manager<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    generatedContent<T extends AIAgent$generatedContentArgs<ExtArgs> = {}>(args?: Subset<T, AIAgent$generatedContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    campaigns<T extends AIAgent$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, AIAgent$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'findMany', never>| Null>;

    trendSignals<T extends AIAgent$trendSignalsArgs<ExtArgs> = {}>(args?: Subset<T, AIAgent$trendSignalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TrendSignalPayload<ExtArgs>, T, 'findMany', never>| Null>;

    executionSessions<T extends AIAgent$executionSessionsArgs<ExtArgs> = {}>(args?: Subset<T, AIAgent$executionSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AgentExecutionSessionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AIAgent base type for findUnique actions
   */
  export type AIAgentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * Filter, which AIAgent to fetch.
     */
    where: AIAgentWhereUniqueInput
  }

  /**
   * AIAgent findUnique
   */
  export interface AIAgentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AIAgentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AIAgent findUniqueOrThrow
   */
  export type AIAgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * Filter, which AIAgent to fetch.
     */
    where: AIAgentWhereUniqueInput
  }


  /**
   * AIAgent base type for findFirst actions
   */
  export type AIAgentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * Filter, which AIAgent to fetch.
     */
    where?: AIAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgents to fetch.
     */
    orderBy?: Enumerable<AIAgentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIAgents.
     */
    cursor?: AIAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIAgents.
     */
    distinct?: Enumerable<AIAgentScalarFieldEnum>
  }

  /**
   * AIAgent findFirst
   */
  export interface AIAgentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AIAgentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AIAgent findFirstOrThrow
   */
  export type AIAgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * Filter, which AIAgent to fetch.
     */
    where?: AIAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgents to fetch.
     */
    orderBy?: Enumerable<AIAgentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIAgents.
     */
    cursor?: AIAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIAgents.
     */
    distinct?: Enumerable<AIAgentScalarFieldEnum>
  }


  /**
   * AIAgent findMany
   */
  export type AIAgentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * Filter, which AIAgents to fetch.
     */
    where?: AIAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgents to fetch.
     */
    orderBy?: Enumerable<AIAgentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIAgents.
     */
    cursor?: AIAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgents.
     */
    skip?: number
    distinct?: Enumerable<AIAgentScalarFieldEnum>
  }


  /**
   * AIAgent create
   */
  export type AIAgentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * The data needed to create a AIAgent.
     */
    data: XOR<AIAgentCreateInput, AIAgentUncheckedCreateInput>
  }


  /**
   * AIAgent createMany
   */
  export type AIAgentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIAgents.
     */
    data: Enumerable<AIAgentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AIAgent update
   */
  export type AIAgentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * The data needed to update a AIAgent.
     */
    data: XOR<AIAgentUpdateInput, AIAgentUncheckedUpdateInput>
    /**
     * Choose, which AIAgent to update.
     */
    where: AIAgentWhereUniqueInput
  }


  /**
   * AIAgent updateMany
   */
  export type AIAgentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIAgents.
     */
    data: XOR<AIAgentUpdateManyMutationInput, AIAgentUncheckedUpdateManyInput>
    /**
     * Filter which AIAgents to update
     */
    where?: AIAgentWhereInput
  }


  /**
   * AIAgent upsert
   */
  export type AIAgentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * The filter to search for the AIAgent to update in case it exists.
     */
    where: AIAgentWhereUniqueInput
    /**
     * In case the AIAgent found by the `where` argument doesn't exist, create a new AIAgent with this data.
     */
    create: XOR<AIAgentCreateInput, AIAgentUncheckedCreateInput>
    /**
     * In case the AIAgent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIAgentUpdateInput, AIAgentUncheckedUpdateInput>
  }


  /**
   * AIAgent delete
   */
  export type AIAgentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * Filter which AIAgent to delete.
     */
    where: AIAgentWhereUniqueInput
  }


  /**
   * AIAgent deleteMany
   */
  export type AIAgentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIAgents to delete
     */
    where?: AIAgentWhereInput
  }


  /**
   * AIAgent.generatedContent
   */
  export type AIAgent$generatedContentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContent
     */
    select?: GeneratedContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GeneratedContentInclude<ExtArgs> | null
    where?: GeneratedContentWhereInput
    orderBy?: Enumerable<GeneratedContentOrderByWithRelationInput>
    cursor?: GeneratedContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GeneratedContentScalarFieldEnum>
  }


  /**
   * AIAgent.campaigns
   */
  export type AIAgent$campaignsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }


  /**
   * AIAgent.trendSignals
   */
  export type AIAgent$trendSignalsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendSignal
     */
    select?: TrendSignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrendSignalInclude<ExtArgs> | null
    where?: TrendSignalWhereInput
    orderBy?: Enumerable<TrendSignalOrderByWithRelationInput>
    cursor?: TrendSignalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrendSignalScalarFieldEnum>
  }


  /**
   * AIAgent.executionSessions
   */
  export type AIAgent$executionSessionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentExecutionSession
     */
    select?: AgentExecutionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentExecutionSessionInclude<ExtArgs> | null
    where?: AgentExecutionSessionWhereInput
    orderBy?: Enumerable<AgentExecutionSessionOrderByWithRelationInput>
    cursor?: AgentExecutionSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AgentExecutionSessionScalarFieldEnum>
  }


  /**
   * AIAgent without action
   */
  export type AIAgentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIAgentInclude<ExtArgs> | null
  }



  /**
   * Model AgentExecutionSession
   */


  export type AggregateAgentExecutionSession = {
    _count: AgentExecutionSessionCountAggregateOutputType | null
    _avg: AgentExecutionSessionAvgAggregateOutputType | null
    _sum: AgentExecutionSessionSumAggregateOutputType | null
    _min: AgentExecutionSessionMinAggregateOutputType | null
    _max: AgentExecutionSessionMaxAggregateOutputType | null
  }

  export type AgentExecutionSessionAvgAggregateOutputType = {
    duration: number | null
  }

  export type AgentExecutionSessionSumAggregateOutputType = {
    duration: number | null
  }

  export type AgentExecutionSessionMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    startedAt: Date | null
    completedAt: Date | null
    success: boolean | null
    duration: number | null
    outputSummary: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type AgentExecutionSessionMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    startedAt: Date | null
    completedAt: Date | null
    success: boolean | null
    duration: number | null
    outputSummary: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type AgentExecutionSessionCountAggregateOutputType = {
    id: number
    agentId: number
    startedAt: number
    completedAt: number
    success: number
    duration: number
    outputSummary: number
    logs: number
    context: number
    metrics: number
    errorMessage: number
    createdAt: number
    _all: number
  }


  export type AgentExecutionSessionAvgAggregateInputType = {
    duration?: true
  }

  export type AgentExecutionSessionSumAggregateInputType = {
    duration?: true
  }

  export type AgentExecutionSessionMinAggregateInputType = {
    id?: true
    agentId?: true
    startedAt?: true
    completedAt?: true
    success?: true
    duration?: true
    outputSummary?: true
    errorMessage?: true
    createdAt?: true
  }

  export type AgentExecutionSessionMaxAggregateInputType = {
    id?: true
    agentId?: true
    startedAt?: true
    completedAt?: true
    success?: true
    duration?: true
    outputSummary?: true
    errorMessage?: true
    createdAt?: true
  }

  export type AgentExecutionSessionCountAggregateInputType = {
    id?: true
    agentId?: true
    startedAt?: true
    completedAt?: true
    success?: true
    duration?: true
    outputSummary?: true
    logs?: true
    context?: true
    metrics?: true
    errorMessage?: true
    createdAt?: true
    _all?: true
  }

  export type AgentExecutionSessionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentExecutionSession to aggregate.
     */
    where?: AgentExecutionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentExecutionSessions to fetch.
     */
    orderBy?: Enumerable<AgentExecutionSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentExecutionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentExecutionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentExecutionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentExecutionSessions
    **/
    _count?: true | AgentExecutionSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentExecutionSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentExecutionSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentExecutionSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentExecutionSessionMaxAggregateInputType
  }

  export type GetAgentExecutionSessionAggregateType<T extends AgentExecutionSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentExecutionSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentExecutionSession[P]>
      : GetScalarType<T[P], AggregateAgentExecutionSession[P]>
  }




  export type AgentExecutionSessionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AgentExecutionSessionWhereInput
    orderBy?: Enumerable<AgentExecutionSessionOrderByWithAggregationInput>
    by: AgentExecutionSessionScalarFieldEnum[]
    having?: AgentExecutionSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentExecutionSessionCountAggregateInputType | true
    _avg?: AgentExecutionSessionAvgAggregateInputType
    _sum?: AgentExecutionSessionSumAggregateInputType
    _min?: AgentExecutionSessionMinAggregateInputType
    _max?: AgentExecutionSessionMaxAggregateInputType
  }


  export type AgentExecutionSessionGroupByOutputType = {
    id: string
    agentId: string
    startedAt: Date
    completedAt: Date | null
    success: boolean | null
    duration: number | null
    outputSummary: string | null
    logs: JsonValue | null
    context: JsonValue | null
    metrics: JsonValue | null
    errorMessage: string | null
    createdAt: Date
    _count: AgentExecutionSessionCountAggregateOutputType | null
    _avg: AgentExecutionSessionAvgAggregateOutputType | null
    _sum: AgentExecutionSessionSumAggregateOutputType | null
    _min: AgentExecutionSessionMinAggregateOutputType | null
    _max: AgentExecutionSessionMaxAggregateOutputType | null
  }

  type GetAgentExecutionSessionGroupByPayload<T extends AgentExecutionSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AgentExecutionSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentExecutionSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentExecutionSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AgentExecutionSessionGroupByOutputType[P]>
        }
      >
    >


  export type AgentExecutionSessionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    success?: boolean
    duration?: boolean
    outputSummary?: boolean
    logs?: boolean
    context?: boolean
    metrics?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    agent?: boolean | AIAgentArgs<ExtArgs>
  }, ExtArgs["result"]["agentExecutionSession"]>

  export type AgentExecutionSessionSelectScalar = {
    id?: boolean
    agentId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    success?: boolean
    duration?: boolean
    outputSummary?: boolean
    logs?: boolean
    context?: boolean
    metrics?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }

  export type AgentExecutionSessionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    agent?: boolean | AIAgentArgs<ExtArgs>
  }


  type AgentExecutionSessionGetPayload<S extends boolean | null | undefined | AgentExecutionSessionArgs> = $Types.GetResult<AgentExecutionSessionPayload, S>

  type AgentExecutionSessionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AgentExecutionSessionFindManyArgs, 'select' | 'include'> & {
      select?: AgentExecutionSessionCountAggregateInputType | true
    }

  export interface AgentExecutionSessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentExecutionSession'], meta: { name: 'AgentExecutionSession' } }
    /**
     * Find zero or one AgentExecutionSession that matches the filter.
     * @param {AgentExecutionSessionFindUniqueArgs} args - Arguments to find a AgentExecutionSession
     * @example
     * // Get one AgentExecutionSession
     * const agentExecutionSession = await prisma.agentExecutionSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgentExecutionSessionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AgentExecutionSessionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AgentExecutionSession'> extends True ? Prisma__AgentExecutionSessionClient<$Types.GetResult<AgentExecutionSessionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AgentExecutionSessionClient<$Types.GetResult<AgentExecutionSessionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one AgentExecutionSession that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AgentExecutionSessionFindUniqueOrThrowArgs} args - Arguments to find a AgentExecutionSession
     * @example
     * // Get one AgentExecutionSession
     * const agentExecutionSession = await prisma.agentExecutionSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgentExecutionSessionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgentExecutionSessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgentExecutionSessionClient<$Types.GetResult<AgentExecutionSessionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first AgentExecutionSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentExecutionSessionFindFirstArgs} args - Arguments to find a AgentExecutionSession
     * @example
     * // Get one AgentExecutionSession
     * const agentExecutionSession = await prisma.agentExecutionSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgentExecutionSessionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AgentExecutionSessionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AgentExecutionSession'> extends True ? Prisma__AgentExecutionSessionClient<$Types.GetResult<AgentExecutionSessionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AgentExecutionSessionClient<$Types.GetResult<AgentExecutionSessionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first AgentExecutionSession that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentExecutionSessionFindFirstOrThrowArgs} args - Arguments to find a AgentExecutionSession
     * @example
     * // Get one AgentExecutionSession
     * const agentExecutionSession = await prisma.agentExecutionSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgentExecutionSessionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgentExecutionSessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgentExecutionSessionClient<$Types.GetResult<AgentExecutionSessionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more AgentExecutionSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentExecutionSessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentExecutionSessions
     * const agentExecutionSessions = await prisma.agentExecutionSession.findMany()
     * 
     * // Get first 10 AgentExecutionSessions
     * const agentExecutionSessions = await prisma.agentExecutionSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentExecutionSessionWithIdOnly = await prisma.agentExecutionSession.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgentExecutionSessionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgentExecutionSessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AgentExecutionSessionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a AgentExecutionSession.
     * @param {AgentExecutionSessionCreateArgs} args - Arguments to create a AgentExecutionSession.
     * @example
     * // Create one AgentExecutionSession
     * const AgentExecutionSession = await prisma.agentExecutionSession.create({
     *   data: {
     *     // ... data to create a AgentExecutionSession
     *   }
     * })
     * 
    **/
    create<T extends AgentExecutionSessionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgentExecutionSessionCreateArgs<ExtArgs>>
    ): Prisma__AgentExecutionSessionClient<$Types.GetResult<AgentExecutionSessionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many AgentExecutionSessions.
     *     @param {AgentExecutionSessionCreateManyArgs} args - Arguments to create many AgentExecutionSessions.
     *     @example
     *     // Create many AgentExecutionSessions
     *     const agentExecutionSession = await prisma.agentExecutionSession.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AgentExecutionSessionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgentExecutionSessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgentExecutionSession.
     * @param {AgentExecutionSessionDeleteArgs} args - Arguments to delete one AgentExecutionSession.
     * @example
     * // Delete one AgentExecutionSession
     * const AgentExecutionSession = await prisma.agentExecutionSession.delete({
     *   where: {
     *     // ... filter to delete one AgentExecutionSession
     *   }
     * })
     * 
    **/
    delete<T extends AgentExecutionSessionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgentExecutionSessionDeleteArgs<ExtArgs>>
    ): Prisma__AgentExecutionSessionClient<$Types.GetResult<AgentExecutionSessionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one AgentExecutionSession.
     * @param {AgentExecutionSessionUpdateArgs} args - Arguments to update one AgentExecutionSession.
     * @example
     * // Update one AgentExecutionSession
     * const agentExecutionSession = await prisma.agentExecutionSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgentExecutionSessionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgentExecutionSessionUpdateArgs<ExtArgs>>
    ): Prisma__AgentExecutionSessionClient<$Types.GetResult<AgentExecutionSessionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more AgentExecutionSessions.
     * @param {AgentExecutionSessionDeleteManyArgs} args - Arguments to filter AgentExecutionSessions to delete.
     * @example
     * // Delete a few AgentExecutionSessions
     * const { count } = await prisma.agentExecutionSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgentExecutionSessionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgentExecutionSessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentExecutionSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentExecutionSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentExecutionSessions
     * const agentExecutionSession = await prisma.agentExecutionSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgentExecutionSessionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgentExecutionSessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgentExecutionSession.
     * @param {AgentExecutionSessionUpsertArgs} args - Arguments to update or create a AgentExecutionSession.
     * @example
     * // Update or create a AgentExecutionSession
     * const agentExecutionSession = await prisma.agentExecutionSession.upsert({
     *   create: {
     *     // ... data to create a AgentExecutionSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentExecutionSession we want to update
     *   }
     * })
    **/
    upsert<T extends AgentExecutionSessionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgentExecutionSessionUpsertArgs<ExtArgs>>
    ): Prisma__AgentExecutionSessionClient<$Types.GetResult<AgentExecutionSessionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of AgentExecutionSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentExecutionSessionCountArgs} args - Arguments to filter AgentExecutionSessions to count.
     * @example
     * // Count the number of AgentExecutionSessions
     * const count = await prisma.agentExecutionSession.count({
     *   where: {
     *     // ... the filter for the AgentExecutionSessions we want to count
     *   }
     * })
    **/
    count<T extends AgentExecutionSessionCountArgs>(
      args?: Subset<T, AgentExecutionSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentExecutionSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentExecutionSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentExecutionSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentExecutionSessionAggregateArgs>(args: Subset<T, AgentExecutionSessionAggregateArgs>): Prisma.PrismaPromise<GetAgentExecutionSessionAggregateType<T>>

    /**
     * Group by AgentExecutionSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentExecutionSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentExecutionSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentExecutionSessionGroupByArgs['orderBy'] }
        : { orderBy?: AgentExecutionSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentExecutionSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentExecutionSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentExecutionSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AgentExecutionSessionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    agent<T extends AIAgentArgs<ExtArgs> = {}>(args?: Subset<T, AIAgentArgs<ExtArgs>>): Prisma__AIAgentClient<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AgentExecutionSession base type for findUnique actions
   */
  export type AgentExecutionSessionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentExecutionSession
     */
    select?: AgentExecutionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentExecutionSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgentExecutionSession to fetch.
     */
    where: AgentExecutionSessionWhereUniqueInput
  }

  /**
   * AgentExecutionSession findUnique
   */
  export interface AgentExecutionSessionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AgentExecutionSessionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AgentExecutionSession findUniqueOrThrow
   */
  export type AgentExecutionSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentExecutionSession
     */
    select?: AgentExecutionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentExecutionSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgentExecutionSession to fetch.
     */
    where: AgentExecutionSessionWhereUniqueInput
  }


  /**
   * AgentExecutionSession base type for findFirst actions
   */
  export type AgentExecutionSessionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentExecutionSession
     */
    select?: AgentExecutionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentExecutionSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgentExecutionSession to fetch.
     */
    where?: AgentExecutionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentExecutionSessions to fetch.
     */
    orderBy?: Enumerable<AgentExecutionSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentExecutionSessions.
     */
    cursor?: AgentExecutionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentExecutionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentExecutionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentExecutionSessions.
     */
    distinct?: Enumerable<AgentExecutionSessionScalarFieldEnum>
  }

  /**
   * AgentExecutionSession findFirst
   */
  export interface AgentExecutionSessionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AgentExecutionSessionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AgentExecutionSession findFirstOrThrow
   */
  export type AgentExecutionSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentExecutionSession
     */
    select?: AgentExecutionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentExecutionSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgentExecutionSession to fetch.
     */
    where?: AgentExecutionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentExecutionSessions to fetch.
     */
    orderBy?: Enumerable<AgentExecutionSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentExecutionSessions.
     */
    cursor?: AgentExecutionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentExecutionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentExecutionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentExecutionSessions.
     */
    distinct?: Enumerable<AgentExecutionSessionScalarFieldEnum>
  }


  /**
   * AgentExecutionSession findMany
   */
  export type AgentExecutionSessionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentExecutionSession
     */
    select?: AgentExecutionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentExecutionSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgentExecutionSessions to fetch.
     */
    where?: AgentExecutionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentExecutionSessions to fetch.
     */
    orderBy?: Enumerable<AgentExecutionSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentExecutionSessions.
     */
    cursor?: AgentExecutionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentExecutionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentExecutionSessions.
     */
    skip?: number
    distinct?: Enumerable<AgentExecutionSessionScalarFieldEnum>
  }


  /**
   * AgentExecutionSession create
   */
  export type AgentExecutionSessionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentExecutionSession
     */
    select?: AgentExecutionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentExecutionSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentExecutionSession.
     */
    data: XOR<AgentExecutionSessionCreateInput, AgentExecutionSessionUncheckedCreateInput>
  }


  /**
   * AgentExecutionSession createMany
   */
  export type AgentExecutionSessionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentExecutionSessions.
     */
    data: Enumerable<AgentExecutionSessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AgentExecutionSession update
   */
  export type AgentExecutionSessionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentExecutionSession
     */
    select?: AgentExecutionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentExecutionSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentExecutionSession.
     */
    data: XOR<AgentExecutionSessionUpdateInput, AgentExecutionSessionUncheckedUpdateInput>
    /**
     * Choose, which AgentExecutionSession to update.
     */
    where: AgentExecutionSessionWhereUniqueInput
  }


  /**
   * AgentExecutionSession updateMany
   */
  export type AgentExecutionSessionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentExecutionSessions.
     */
    data: XOR<AgentExecutionSessionUpdateManyMutationInput, AgentExecutionSessionUncheckedUpdateManyInput>
    /**
     * Filter which AgentExecutionSessions to update
     */
    where?: AgentExecutionSessionWhereInput
  }


  /**
   * AgentExecutionSession upsert
   */
  export type AgentExecutionSessionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentExecutionSession
     */
    select?: AgentExecutionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentExecutionSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentExecutionSession to update in case it exists.
     */
    where: AgentExecutionSessionWhereUniqueInput
    /**
     * In case the AgentExecutionSession found by the `where` argument doesn't exist, create a new AgentExecutionSession with this data.
     */
    create: XOR<AgentExecutionSessionCreateInput, AgentExecutionSessionUncheckedCreateInput>
    /**
     * In case the AgentExecutionSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentExecutionSessionUpdateInput, AgentExecutionSessionUncheckedUpdateInput>
  }


  /**
   * AgentExecutionSession delete
   */
  export type AgentExecutionSessionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentExecutionSession
     */
    select?: AgentExecutionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentExecutionSessionInclude<ExtArgs> | null
    /**
     * Filter which AgentExecutionSession to delete.
     */
    where: AgentExecutionSessionWhereUniqueInput
  }


  /**
   * AgentExecutionSession deleteMany
   */
  export type AgentExecutionSessionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentExecutionSessions to delete
     */
    where?: AgentExecutionSessionWhereInput
  }


  /**
   * AgentExecutionSession without action
   */
  export type AgentExecutionSessionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentExecutionSession
     */
    select?: AgentExecutionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgentExecutionSessionInclude<ExtArgs> | null
  }



  /**
   * Model Campaign
   */


  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    budget: number | null
  }

  export type CampaignSumAggregateOutputType = {
    budget: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: CampaignStatus | null
    campaignType: CampaignType | null
    budget: number | null
    startDate: Date | null
    endDate: Date | null
    ownerId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: CampaignStatus | null
    campaignType: CampaignType | null
    budget: number | null
    startDate: Date | null
    endDate: Date | null
    ownerId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    campaignType: number
    goals: number
    targeting: number
    budget: number
    startDate: number
    endDate: number
    ownerId: number
    projectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    budget?: true
  }

  export type CampaignSumAggregateInputType = {
    budget?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    campaignType?: true
    budget?: true
    startDate?: true
    endDate?: true
    ownerId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    campaignType?: true
    budget?: true
    startDate?: true
    endDate?: true
    ownerId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    campaignType?: true
    goals?: true
    targeting?: true
    budget?: true
    startDate?: true
    endDate?: true
    ownerId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: Enumerable<CampaignOrderByWithAggregationInput>
    by: CampaignScalarFieldEnum[]
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }


  export type CampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: CampaignStatus
    campaignType: CampaignType
    goals: JsonValue
    targeting: JsonValue
    budget: number | null
    startDate: Date | null
    endDate: Date | null
    ownerId: string
    projectId: string
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    campaignType?: boolean
    goals?: boolean
    targeting?: boolean
    budget?: boolean
    startDate?: boolean
    endDate?: boolean
    ownerId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserArgs<ExtArgs>
    project?: boolean | ProjectArgs<ExtArgs>
    agents?: boolean | Campaign$agentsArgs<ExtArgs>
    generatedContent?: boolean | Campaign$generatedContentArgs<ExtArgs>
    outreachTasks?: boolean | Campaign$outreachTasksArgs<ExtArgs>
    metrics?: boolean | Campaign$metricsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    campaignType?: boolean
    goals?: boolean
    targeting?: boolean
    budget?: boolean
    startDate?: boolean
    endDate?: boolean
    ownerId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    owner?: boolean | UserArgs<ExtArgs>
    project?: boolean | ProjectArgs<ExtArgs>
    agents?: boolean | Campaign$agentsArgs<ExtArgs>
    generatedContent?: boolean | Campaign$generatedContentArgs<ExtArgs>
    outreachTasks?: boolean | Campaign$outreachTasksArgs<ExtArgs>
    metrics?: boolean | Campaign$metricsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeArgs<ExtArgs>
  }


  type CampaignGetPayload<S extends boolean | null | undefined | CampaignArgs> = $Types.GetResult<CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Campaign'> extends True ? Prisma__CampaignClient<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CampaignClient<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Campaign'> extends True ? Prisma__CampaignClient<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CampaignClient<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
    **/
    create<T extends CampaignCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Campaigns.
     *     @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     *     @example
     *     // Create many Campaigns
     *     const campaign = await prisma.campaign.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
    **/
    delete<T extends CampaignDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    owner<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    project<T extends ProjectArgs<ExtArgs> = {}>(args?: Subset<T, ProjectArgs<ExtArgs>>): Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    agents<T extends Campaign$agentsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    generatedContent<T extends Campaign$generatedContentArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$generatedContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    outreachTasks<T extends Campaign$outreachTasksArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$outreachTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'findMany', never>| Null>;

    metrics<T extends Campaign$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MetricPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Campaign base type for findUnique actions
   */
  export type CampaignFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUnique
   */
  export interface CampaignFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CampaignFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign base type for findFirst actions
   */
  export type CampaignFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }

  /**
   * Campaign findFirst
   */
  export interface CampaignFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CampaignFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }


  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }


  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }


  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: Enumerable<CampaignCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }


  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }


  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }


  /**
   * Campaign.agents
   */
  export type Campaign$agentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AIAgentInclude<ExtArgs> | null
    where?: AIAgentWhereInput
    orderBy?: Enumerable<AIAgentOrderByWithRelationInput>
    cursor?: AIAgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AIAgentScalarFieldEnum>
  }


  /**
   * Campaign.generatedContent
   */
  export type Campaign$generatedContentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContent
     */
    select?: GeneratedContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GeneratedContentInclude<ExtArgs> | null
    where?: GeneratedContentWhereInput
    orderBy?: Enumerable<GeneratedContentOrderByWithRelationInput>
    cursor?: GeneratedContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GeneratedContentScalarFieldEnum>
  }


  /**
   * Campaign.outreachTasks
   */
  export type Campaign$outreachTasksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutreachTask
     */
    select?: OutreachTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutreachTaskInclude<ExtArgs> | null
    where?: OutreachTaskWhereInput
    orderBy?: Enumerable<OutreachTaskOrderByWithRelationInput>
    cursor?: OutreachTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OutreachTaskScalarFieldEnum>
  }


  /**
   * Campaign.metrics
   */
  export type Campaign$metricsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetricInclude<ExtArgs> | null
    where?: MetricWhereInput
    orderBy?: Enumerable<MetricOrderByWithRelationInput>
    cursor?: MetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MetricScalarFieldEnum>
  }


  /**
   * Campaign without action
   */
  export type CampaignArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
  }



  /**
   * Model GeneratedContent
   */


  export type AggregateGeneratedContent = {
    _count: GeneratedContentCountAggregateOutputType | null
    _min: GeneratedContentMinAggregateOutputType | null
    _max: GeneratedContentMaxAggregateOutputType | null
  }

  export type GeneratedContentMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    contentType: ContentType | null
    platform: Platform | null
    status: ContentStatus | null
    agentId: string | null
    campaignId: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GeneratedContentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    contentType: ContentType | null
    platform: Platform | null
    status: ContentStatus | null
    agentId: string | null
    campaignId: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GeneratedContentCountAggregateOutputType = {
    id: number
    title: number
    content: number
    contentType: number
    platform: number
    status: number
    metadata: number
    agentId: number
    campaignId: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GeneratedContentMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    contentType?: true
    platform?: true
    status?: true
    agentId?: true
    campaignId?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GeneratedContentMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    contentType?: true
    platform?: true
    status?: true
    agentId?: true
    campaignId?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GeneratedContentCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    contentType?: true
    platform?: true
    status?: true
    metadata?: true
    agentId?: true
    campaignId?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GeneratedContentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedContent to aggregate.
     */
    where?: GeneratedContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedContents to fetch.
     */
    orderBy?: Enumerable<GeneratedContentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeneratedContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeneratedContents
    **/
    _count?: true | GeneratedContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneratedContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneratedContentMaxAggregateInputType
  }

  export type GetGeneratedContentAggregateType<T extends GeneratedContentAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneratedContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneratedContent[P]>
      : GetScalarType<T[P], AggregateGeneratedContent[P]>
  }




  export type GeneratedContentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GeneratedContentWhereInput
    orderBy?: Enumerable<GeneratedContentOrderByWithAggregationInput>
    by: GeneratedContentScalarFieldEnum[]
    having?: GeneratedContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneratedContentCountAggregateInputType | true
    _min?: GeneratedContentMinAggregateInputType
    _max?: GeneratedContentMaxAggregateInputType
  }


  export type GeneratedContentGroupByOutputType = {
    id: string
    title: string
    content: string
    contentType: ContentType
    platform: Platform | null
    status: ContentStatus
    metadata: JsonValue | null
    agentId: string
    campaignId: string | null
    creatorId: string | null
    createdAt: Date
    updatedAt: Date
    _count: GeneratedContentCountAggregateOutputType | null
    _min: GeneratedContentMinAggregateOutputType | null
    _max: GeneratedContentMaxAggregateOutputType | null
  }

  type GetGeneratedContentGroupByPayload<T extends GeneratedContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GeneratedContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneratedContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneratedContentGroupByOutputType[P]>
            : GetScalarType<T[P], GeneratedContentGroupByOutputType[P]>
        }
      >
    >


  export type GeneratedContentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    contentType?: boolean
    platform?: boolean
    status?: boolean
    metadata?: boolean
    agentId?: boolean
    campaignId?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AIAgentArgs<ExtArgs>
    campaign?: boolean | CampaignArgs<ExtArgs>
    creator?: boolean | UserArgs<ExtArgs>
    feedback?: boolean | GeneratedContent$feedbackArgs<ExtArgs>
    _count?: boolean | GeneratedContentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["generatedContent"]>

  export type GeneratedContentSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    contentType?: boolean
    platform?: boolean
    status?: boolean
    metadata?: boolean
    agentId?: boolean
    campaignId?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GeneratedContentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    agent?: boolean | AIAgentArgs<ExtArgs>
    campaign?: boolean | CampaignArgs<ExtArgs>
    creator?: boolean | UserArgs<ExtArgs>
    feedback?: boolean | GeneratedContent$feedbackArgs<ExtArgs>
    _count?: boolean | GeneratedContentCountOutputTypeArgs<ExtArgs>
  }


  type GeneratedContentGetPayload<S extends boolean | null | undefined | GeneratedContentArgs> = $Types.GetResult<GeneratedContentPayload, S>

  type GeneratedContentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<GeneratedContentFindManyArgs, 'select' | 'include'> & {
      select?: GeneratedContentCountAggregateInputType | true
    }

  export interface GeneratedContentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeneratedContent'], meta: { name: 'GeneratedContent' } }
    /**
     * Find zero or one GeneratedContent that matches the filter.
     * @param {GeneratedContentFindUniqueArgs} args - Arguments to find a GeneratedContent
     * @example
     * // Get one GeneratedContent
     * const generatedContent = await prisma.generatedContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GeneratedContentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GeneratedContentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GeneratedContent'> extends True ? Prisma__GeneratedContentClient<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__GeneratedContentClient<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one GeneratedContent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GeneratedContentFindUniqueOrThrowArgs} args - Arguments to find a GeneratedContent
     * @example
     * // Get one GeneratedContent
     * const generatedContent = await prisma.generatedContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GeneratedContentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GeneratedContentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GeneratedContentClient<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first GeneratedContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedContentFindFirstArgs} args - Arguments to find a GeneratedContent
     * @example
     * // Get one GeneratedContent
     * const generatedContent = await prisma.generatedContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GeneratedContentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GeneratedContentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GeneratedContent'> extends True ? Prisma__GeneratedContentClient<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__GeneratedContentClient<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first GeneratedContent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedContentFindFirstOrThrowArgs} args - Arguments to find a GeneratedContent
     * @example
     * // Get one GeneratedContent
     * const generatedContent = await prisma.generatedContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GeneratedContentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GeneratedContentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GeneratedContentClient<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more GeneratedContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedContentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeneratedContents
     * const generatedContents = await prisma.generatedContent.findMany()
     * 
     * // Get first 10 GeneratedContents
     * const generatedContents = await prisma.generatedContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generatedContentWithIdOnly = await prisma.generatedContent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GeneratedContentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GeneratedContentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a GeneratedContent.
     * @param {GeneratedContentCreateArgs} args - Arguments to create a GeneratedContent.
     * @example
     * // Create one GeneratedContent
     * const GeneratedContent = await prisma.generatedContent.create({
     *   data: {
     *     // ... data to create a GeneratedContent
     *   }
     * })
     * 
    **/
    create<T extends GeneratedContentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GeneratedContentCreateArgs<ExtArgs>>
    ): Prisma__GeneratedContentClient<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many GeneratedContents.
     *     @param {GeneratedContentCreateManyArgs} args - Arguments to create many GeneratedContents.
     *     @example
     *     // Create many GeneratedContents
     *     const generatedContent = await prisma.generatedContent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GeneratedContentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GeneratedContentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GeneratedContent.
     * @param {GeneratedContentDeleteArgs} args - Arguments to delete one GeneratedContent.
     * @example
     * // Delete one GeneratedContent
     * const GeneratedContent = await prisma.generatedContent.delete({
     *   where: {
     *     // ... filter to delete one GeneratedContent
     *   }
     * })
     * 
    **/
    delete<T extends GeneratedContentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GeneratedContentDeleteArgs<ExtArgs>>
    ): Prisma__GeneratedContentClient<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one GeneratedContent.
     * @param {GeneratedContentUpdateArgs} args - Arguments to update one GeneratedContent.
     * @example
     * // Update one GeneratedContent
     * const generatedContent = await prisma.generatedContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GeneratedContentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GeneratedContentUpdateArgs<ExtArgs>>
    ): Prisma__GeneratedContentClient<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more GeneratedContents.
     * @param {GeneratedContentDeleteManyArgs} args - Arguments to filter GeneratedContents to delete.
     * @example
     * // Delete a few GeneratedContents
     * const { count } = await prisma.generatedContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GeneratedContentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GeneratedContentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeneratedContents
     * const generatedContent = await prisma.generatedContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GeneratedContentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GeneratedContentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GeneratedContent.
     * @param {GeneratedContentUpsertArgs} args - Arguments to update or create a GeneratedContent.
     * @example
     * // Update or create a GeneratedContent
     * const generatedContent = await prisma.generatedContent.upsert({
     *   create: {
     *     // ... data to create a GeneratedContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeneratedContent we want to update
     *   }
     * })
    **/
    upsert<T extends GeneratedContentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GeneratedContentUpsertArgs<ExtArgs>>
    ): Prisma__GeneratedContentClient<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of GeneratedContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedContentCountArgs} args - Arguments to filter GeneratedContents to count.
     * @example
     * // Count the number of GeneratedContents
     * const count = await prisma.generatedContent.count({
     *   where: {
     *     // ... the filter for the GeneratedContents we want to count
     *   }
     * })
    **/
    count<T extends GeneratedContentCountArgs>(
      args?: Subset<T, GeneratedContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneratedContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeneratedContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneratedContentAggregateArgs>(args: Subset<T, GeneratedContentAggregateArgs>): Prisma.PrismaPromise<GetGeneratedContentAggregateType<T>>

    /**
     * Group by GeneratedContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeneratedContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneratedContentGroupByArgs['orderBy'] }
        : { orderBy?: GeneratedContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeneratedContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneratedContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GeneratedContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GeneratedContentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    agent<T extends AIAgentArgs<ExtArgs> = {}>(args?: Subset<T, AIAgentArgs<ExtArgs>>): Prisma__AIAgentClient<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    campaign<T extends CampaignArgs<ExtArgs> = {}>(args?: Subset<T, CampaignArgs<ExtArgs>>): Prisma__CampaignClient<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    creator<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    feedback<T extends GeneratedContent$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedContent$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GeneratedContent base type for findUnique actions
   */
  export type GeneratedContentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContent
     */
    select?: GeneratedContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GeneratedContentInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedContent to fetch.
     */
    where: GeneratedContentWhereUniqueInput
  }

  /**
   * GeneratedContent findUnique
   */
  export interface GeneratedContentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends GeneratedContentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GeneratedContent findUniqueOrThrow
   */
  export type GeneratedContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContent
     */
    select?: GeneratedContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GeneratedContentInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedContent to fetch.
     */
    where: GeneratedContentWhereUniqueInput
  }


  /**
   * GeneratedContent base type for findFirst actions
   */
  export type GeneratedContentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContent
     */
    select?: GeneratedContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GeneratedContentInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedContent to fetch.
     */
    where?: GeneratedContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedContents to fetch.
     */
    orderBy?: Enumerable<GeneratedContentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedContents.
     */
    cursor?: GeneratedContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedContents.
     */
    distinct?: Enumerable<GeneratedContentScalarFieldEnum>
  }

  /**
   * GeneratedContent findFirst
   */
  export interface GeneratedContentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends GeneratedContentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GeneratedContent findFirstOrThrow
   */
  export type GeneratedContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContent
     */
    select?: GeneratedContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GeneratedContentInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedContent to fetch.
     */
    where?: GeneratedContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedContents to fetch.
     */
    orderBy?: Enumerable<GeneratedContentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedContents.
     */
    cursor?: GeneratedContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedContents.
     */
    distinct?: Enumerable<GeneratedContentScalarFieldEnum>
  }


  /**
   * GeneratedContent findMany
   */
  export type GeneratedContentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContent
     */
    select?: GeneratedContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GeneratedContentInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedContents to fetch.
     */
    where?: GeneratedContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedContents to fetch.
     */
    orderBy?: Enumerable<GeneratedContentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeneratedContents.
     */
    cursor?: GeneratedContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedContents.
     */
    skip?: number
    distinct?: Enumerable<GeneratedContentScalarFieldEnum>
  }


  /**
   * GeneratedContent create
   */
  export type GeneratedContentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContent
     */
    select?: GeneratedContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GeneratedContentInclude<ExtArgs> | null
    /**
     * The data needed to create a GeneratedContent.
     */
    data: XOR<GeneratedContentCreateInput, GeneratedContentUncheckedCreateInput>
  }


  /**
   * GeneratedContent createMany
   */
  export type GeneratedContentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeneratedContents.
     */
    data: Enumerable<GeneratedContentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GeneratedContent update
   */
  export type GeneratedContentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContent
     */
    select?: GeneratedContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GeneratedContentInclude<ExtArgs> | null
    /**
     * The data needed to update a GeneratedContent.
     */
    data: XOR<GeneratedContentUpdateInput, GeneratedContentUncheckedUpdateInput>
    /**
     * Choose, which GeneratedContent to update.
     */
    where: GeneratedContentWhereUniqueInput
  }


  /**
   * GeneratedContent updateMany
   */
  export type GeneratedContentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeneratedContents.
     */
    data: XOR<GeneratedContentUpdateManyMutationInput, GeneratedContentUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedContents to update
     */
    where?: GeneratedContentWhereInput
  }


  /**
   * GeneratedContent upsert
   */
  export type GeneratedContentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContent
     */
    select?: GeneratedContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GeneratedContentInclude<ExtArgs> | null
    /**
     * The filter to search for the GeneratedContent to update in case it exists.
     */
    where: GeneratedContentWhereUniqueInput
    /**
     * In case the GeneratedContent found by the `where` argument doesn't exist, create a new GeneratedContent with this data.
     */
    create: XOR<GeneratedContentCreateInput, GeneratedContentUncheckedCreateInput>
    /**
     * In case the GeneratedContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeneratedContentUpdateInput, GeneratedContentUncheckedUpdateInput>
  }


  /**
   * GeneratedContent delete
   */
  export type GeneratedContentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContent
     */
    select?: GeneratedContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GeneratedContentInclude<ExtArgs> | null
    /**
     * Filter which GeneratedContent to delete.
     */
    where: GeneratedContentWhereUniqueInput
  }


  /**
   * GeneratedContent deleteMany
   */
  export type GeneratedContentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedContents to delete
     */
    where?: GeneratedContentWhereInput
  }


  /**
   * GeneratedContent.feedback
   */
  export type GeneratedContent$feedbackArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: Enumerable<FeedbackOrderByWithRelationInput>
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FeedbackScalarFieldEnum>
  }


  /**
   * GeneratedContent without action
   */
  export type GeneratedContentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedContent
     */
    select?: GeneratedContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GeneratedContentInclude<ExtArgs> | null
  }



  /**
   * Model OutreachTask
   */


  export type AggregateOutreachTask = {
    _count: OutreachTaskCountAggregateOutputType | null
    _min: OutreachTaskMinAggregateOutputType | null
    _max: OutreachTaskMaxAggregateOutputType | null
  }

  export type OutreachTaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    outreachType: OutreachType | null
    status: OutreachStatus | null
    contactMethod: ContactMethod | null
    aiResponse: string | null
    responseHandlerId: string | null
    campaignId: string | null
    scheduledAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutreachTaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    outreachType: OutreachType | null
    status: OutreachStatus | null
    contactMethod: ContactMethod | null
    aiResponse: string | null
    responseHandlerId: string | null
    campaignId: string | null
    scheduledAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutreachTaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    outreachType: number
    status: number
    leadInfo: number
    contactMethod: number
    aiResponse: number
    responseHandlerId: number
    campaignId: number
    scheduledAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OutreachTaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    outreachType?: true
    status?: true
    contactMethod?: true
    aiResponse?: true
    responseHandlerId?: true
    campaignId?: true
    scheduledAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutreachTaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    outreachType?: true
    status?: true
    contactMethod?: true
    aiResponse?: true
    responseHandlerId?: true
    campaignId?: true
    scheduledAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutreachTaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    outreachType?: true
    status?: true
    leadInfo?: true
    contactMethod?: true
    aiResponse?: true
    responseHandlerId?: true
    campaignId?: true
    scheduledAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OutreachTaskAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutreachTask to aggregate.
     */
    where?: OutreachTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutreachTasks to fetch.
     */
    orderBy?: Enumerable<OutreachTaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutreachTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutreachTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutreachTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutreachTasks
    **/
    _count?: true | OutreachTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutreachTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutreachTaskMaxAggregateInputType
  }

  export type GetOutreachTaskAggregateType<T extends OutreachTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateOutreachTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutreachTask[P]>
      : GetScalarType<T[P], AggregateOutreachTask[P]>
  }




  export type OutreachTaskGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OutreachTaskWhereInput
    orderBy?: Enumerable<OutreachTaskOrderByWithAggregationInput>
    by: OutreachTaskScalarFieldEnum[]
    having?: OutreachTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutreachTaskCountAggregateInputType | true
    _min?: OutreachTaskMinAggregateInputType
    _max?: OutreachTaskMaxAggregateInputType
  }


  export type OutreachTaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    outreachType: OutreachType
    status: OutreachStatus
    leadInfo: JsonValue
    contactMethod: ContactMethod
    aiResponse: string | null
    responseHandlerId: string | null
    campaignId: string
    scheduledAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OutreachTaskCountAggregateOutputType | null
    _min: OutreachTaskMinAggregateOutputType | null
    _max: OutreachTaskMaxAggregateOutputType | null
  }

  type GetOutreachTaskGroupByPayload<T extends OutreachTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OutreachTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutreachTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutreachTaskGroupByOutputType[P]>
            : GetScalarType<T[P], OutreachTaskGroupByOutputType[P]>
        }
      >
    >


  export type OutreachTaskSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    outreachType?: boolean
    status?: boolean
    leadInfo?: boolean
    contactMethod?: boolean
    aiResponse?: boolean
    responseHandlerId?: boolean
    campaignId?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responseHandler?: boolean | UserArgs<ExtArgs>
    campaign?: boolean | CampaignArgs<ExtArgs>
    feedback?: boolean | OutreachTask$feedbackArgs<ExtArgs>
    _count?: boolean | OutreachTaskCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["outreachTask"]>

  export type OutreachTaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    outreachType?: boolean
    status?: boolean
    leadInfo?: boolean
    contactMethod?: boolean
    aiResponse?: boolean
    responseHandlerId?: boolean
    campaignId?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OutreachTaskInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    responseHandler?: boolean | UserArgs<ExtArgs>
    campaign?: boolean | CampaignArgs<ExtArgs>
    feedback?: boolean | OutreachTask$feedbackArgs<ExtArgs>
    _count?: boolean | OutreachTaskCountOutputTypeArgs<ExtArgs>
  }


  type OutreachTaskGetPayload<S extends boolean | null | undefined | OutreachTaskArgs> = $Types.GetResult<OutreachTaskPayload, S>

  type OutreachTaskCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OutreachTaskFindManyArgs, 'select' | 'include'> & {
      select?: OutreachTaskCountAggregateInputType | true
    }

  export interface OutreachTaskDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutreachTask'], meta: { name: 'OutreachTask' } }
    /**
     * Find zero or one OutreachTask that matches the filter.
     * @param {OutreachTaskFindUniqueArgs} args - Arguments to find a OutreachTask
     * @example
     * // Get one OutreachTask
     * const outreachTask = await prisma.outreachTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OutreachTaskFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OutreachTaskFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OutreachTask'> extends True ? Prisma__OutreachTaskClient<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__OutreachTaskClient<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one OutreachTask that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OutreachTaskFindUniqueOrThrowArgs} args - Arguments to find a OutreachTask
     * @example
     * // Get one OutreachTask
     * const outreachTask = await prisma.outreachTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OutreachTaskFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OutreachTaskFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OutreachTaskClient<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first OutreachTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutreachTaskFindFirstArgs} args - Arguments to find a OutreachTask
     * @example
     * // Get one OutreachTask
     * const outreachTask = await prisma.outreachTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OutreachTaskFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OutreachTaskFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OutreachTask'> extends True ? Prisma__OutreachTaskClient<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__OutreachTaskClient<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first OutreachTask that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutreachTaskFindFirstOrThrowArgs} args - Arguments to find a OutreachTask
     * @example
     * // Get one OutreachTask
     * const outreachTask = await prisma.outreachTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OutreachTaskFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OutreachTaskFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OutreachTaskClient<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more OutreachTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutreachTaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutreachTasks
     * const outreachTasks = await prisma.outreachTask.findMany()
     * 
     * // Get first 10 OutreachTasks
     * const outreachTasks = await prisma.outreachTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outreachTaskWithIdOnly = await prisma.outreachTask.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OutreachTaskFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OutreachTaskFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a OutreachTask.
     * @param {OutreachTaskCreateArgs} args - Arguments to create a OutreachTask.
     * @example
     * // Create one OutreachTask
     * const OutreachTask = await prisma.outreachTask.create({
     *   data: {
     *     // ... data to create a OutreachTask
     *   }
     * })
     * 
    **/
    create<T extends OutreachTaskCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OutreachTaskCreateArgs<ExtArgs>>
    ): Prisma__OutreachTaskClient<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many OutreachTasks.
     *     @param {OutreachTaskCreateManyArgs} args - Arguments to create many OutreachTasks.
     *     @example
     *     // Create many OutreachTasks
     *     const outreachTask = await prisma.outreachTask.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OutreachTaskCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OutreachTaskCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OutreachTask.
     * @param {OutreachTaskDeleteArgs} args - Arguments to delete one OutreachTask.
     * @example
     * // Delete one OutreachTask
     * const OutreachTask = await prisma.outreachTask.delete({
     *   where: {
     *     // ... filter to delete one OutreachTask
     *   }
     * })
     * 
    **/
    delete<T extends OutreachTaskDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OutreachTaskDeleteArgs<ExtArgs>>
    ): Prisma__OutreachTaskClient<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one OutreachTask.
     * @param {OutreachTaskUpdateArgs} args - Arguments to update one OutreachTask.
     * @example
     * // Update one OutreachTask
     * const outreachTask = await prisma.outreachTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OutreachTaskUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OutreachTaskUpdateArgs<ExtArgs>>
    ): Prisma__OutreachTaskClient<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more OutreachTasks.
     * @param {OutreachTaskDeleteManyArgs} args - Arguments to filter OutreachTasks to delete.
     * @example
     * // Delete a few OutreachTasks
     * const { count } = await prisma.outreachTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OutreachTaskDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OutreachTaskDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutreachTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutreachTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutreachTasks
     * const outreachTask = await prisma.outreachTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OutreachTaskUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OutreachTaskUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OutreachTask.
     * @param {OutreachTaskUpsertArgs} args - Arguments to update or create a OutreachTask.
     * @example
     * // Update or create a OutreachTask
     * const outreachTask = await prisma.outreachTask.upsert({
     *   create: {
     *     // ... data to create a OutreachTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutreachTask we want to update
     *   }
     * })
    **/
    upsert<T extends OutreachTaskUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OutreachTaskUpsertArgs<ExtArgs>>
    ): Prisma__OutreachTaskClient<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of OutreachTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutreachTaskCountArgs} args - Arguments to filter OutreachTasks to count.
     * @example
     * // Count the number of OutreachTasks
     * const count = await prisma.outreachTask.count({
     *   where: {
     *     // ... the filter for the OutreachTasks we want to count
     *   }
     * })
    **/
    count<T extends OutreachTaskCountArgs>(
      args?: Subset<T, OutreachTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutreachTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutreachTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutreachTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutreachTaskAggregateArgs>(args: Subset<T, OutreachTaskAggregateArgs>): Prisma.PrismaPromise<GetOutreachTaskAggregateType<T>>

    /**
     * Group by OutreachTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutreachTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutreachTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutreachTaskGroupByArgs['orderBy'] }
        : { orderBy?: OutreachTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutreachTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutreachTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OutreachTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OutreachTaskClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    responseHandler<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    campaign<T extends CampaignArgs<ExtArgs> = {}>(args?: Subset<T, CampaignArgs<ExtArgs>>): Prisma__CampaignClient<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    feedback<T extends OutreachTask$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, OutreachTask$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OutreachTask base type for findUnique actions
   */
  export type OutreachTaskFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutreachTask
     */
    select?: OutreachTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutreachTaskInclude<ExtArgs> | null
    /**
     * Filter, which OutreachTask to fetch.
     */
    where: OutreachTaskWhereUniqueInput
  }

  /**
   * OutreachTask findUnique
   */
  export interface OutreachTaskFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OutreachTaskFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OutreachTask findUniqueOrThrow
   */
  export type OutreachTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutreachTask
     */
    select?: OutreachTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutreachTaskInclude<ExtArgs> | null
    /**
     * Filter, which OutreachTask to fetch.
     */
    where: OutreachTaskWhereUniqueInput
  }


  /**
   * OutreachTask base type for findFirst actions
   */
  export type OutreachTaskFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutreachTask
     */
    select?: OutreachTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutreachTaskInclude<ExtArgs> | null
    /**
     * Filter, which OutreachTask to fetch.
     */
    where?: OutreachTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutreachTasks to fetch.
     */
    orderBy?: Enumerable<OutreachTaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutreachTasks.
     */
    cursor?: OutreachTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutreachTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutreachTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutreachTasks.
     */
    distinct?: Enumerable<OutreachTaskScalarFieldEnum>
  }

  /**
   * OutreachTask findFirst
   */
  export interface OutreachTaskFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OutreachTaskFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OutreachTask findFirstOrThrow
   */
  export type OutreachTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutreachTask
     */
    select?: OutreachTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutreachTaskInclude<ExtArgs> | null
    /**
     * Filter, which OutreachTask to fetch.
     */
    where?: OutreachTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutreachTasks to fetch.
     */
    orderBy?: Enumerable<OutreachTaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutreachTasks.
     */
    cursor?: OutreachTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutreachTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutreachTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutreachTasks.
     */
    distinct?: Enumerable<OutreachTaskScalarFieldEnum>
  }


  /**
   * OutreachTask findMany
   */
  export type OutreachTaskFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutreachTask
     */
    select?: OutreachTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutreachTaskInclude<ExtArgs> | null
    /**
     * Filter, which OutreachTasks to fetch.
     */
    where?: OutreachTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutreachTasks to fetch.
     */
    orderBy?: Enumerable<OutreachTaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutreachTasks.
     */
    cursor?: OutreachTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutreachTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutreachTasks.
     */
    skip?: number
    distinct?: Enumerable<OutreachTaskScalarFieldEnum>
  }


  /**
   * OutreachTask create
   */
  export type OutreachTaskCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutreachTask
     */
    select?: OutreachTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutreachTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a OutreachTask.
     */
    data: XOR<OutreachTaskCreateInput, OutreachTaskUncheckedCreateInput>
  }


  /**
   * OutreachTask createMany
   */
  export type OutreachTaskCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutreachTasks.
     */
    data: Enumerable<OutreachTaskCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OutreachTask update
   */
  export type OutreachTaskUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutreachTask
     */
    select?: OutreachTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutreachTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a OutreachTask.
     */
    data: XOR<OutreachTaskUpdateInput, OutreachTaskUncheckedUpdateInput>
    /**
     * Choose, which OutreachTask to update.
     */
    where: OutreachTaskWhereUniqueInput
  }


  /**
   * OutreachTask updateMany
   */
  export type OutreachTaskUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutreachTasks.
     */
    data: XOR<OutreachTaskUpdateManyMutationInput, OutreachTaskUncheckedUpdateManyInput>
    /**
     * Filter which OutreachTasks to update
     */
    where?: OutreachTaskWhereInput
  }


  /**
   * OutreachTask upsert
   */
  export type OutreachTaskUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutreachTask
     */
    select?: OutreachTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutreachTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the OutreachTask to update in case it exists.
     */
    where: OutreachTaskWhereUniqueInput
    /**
     * In case the OutreachTask found by the `where` argument doesn't exist, create a new OutreachTask with this data.
     */
    create: XOR<OutreachTaskCreateInput, OutreachTaskUncheckedCreateInput>
    /**
     * In case the OutreachTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutreachTaskUpdateInput, OutreachTaskUncheckedUpdateInput>
  }


  /**
   * OutreachTask delete
   */
  export type OutreachTaskDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutreachTask
     */
    select?: OutreachTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutreachTaskInclude<ExtArgs> | null
    /**
     * Filter which OutreachTask to delete.
     */
    where: OutreachTaskWhereUniqueInput
  }


  /**
   * OutreachTask deleteMany
   */
  export type OutreachTaskDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutreachTasks to delete
     */
    where?: OutreachTaskWhereInput
  }


  /**
   * OutreachTask.feedback
   */
  export type OutreachTask$feedbackArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: Enumerable<FeedbackOrderByWithRelationInput>
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FeedbackScalarFieldEnum>
  }


  /**
   * OutreachTask without action
   */
  export type OutreachTaskArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutreachTask
     */
    select?: OutreachTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutreachTaskInclude<ExtArgs> | null
  }



  /**
   * Model TrendSignal
   */


  export type AggregateTrendSignal = {
    _count: TrendSignalCountAggregateOutputType | null
    _avg: TrendSignalAvgAggregateOutputType | null
    _sum: TrendSignalSumAggregateOutputType | null
    _min: TrendSignalMinAggregateOutputType | null
    _max: TrendSignalMaxAggregateOutputType | null
  }

  export type TrendSignalAvgAggregateOutputType = {
    confidence: number | null
  }

  export type TrendSignalSumAggregateOutputType = {
    confidence: number | null
  }

  export type TrendSignalMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    source: string | null
    signalType: SignalType | null
    confidence: number | null
    impact: TrendImpact | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrendSignalMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    source: string | null
    signalType: SignalType | null
    confidence: number | null
    impact: TrendImpact | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrendSignalCountAggregateOutputType = {
    id: number
    title: number
    description: number
    source: number
    signalType: number
    confidence: number
    rawData: number
    impact: number
    agentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrendSignalAvgAggregateInputType = {
    confidence?: true
  }

  export type TrendSignalSumAggregateInputType = {
    confidence?: true
  }

  export type TrendSignalMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    source?: true
    signalType?: true
    confidence?: true
    impact?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrendSignalMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    source?: true
    signalType?: true
    confidence?: true
    impact?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrendSignalCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    source?: true
    signalType?: true
    confidence?: true
    rawData?: true
    impact?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrendSignalAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrendSignal to aggregate.
     */
    where?: TrendSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrendSignals to fetch.
     */
    orderBy?: Enumerable<TrendSignalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrendSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrendSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrendSignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrendSignals
    **/
    _count?: true | TrendSignalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrendSignalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrendSignalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrendSignalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrendSignalMaxAggregateInputType
  }

  export type GetTrendSignalAggregateType<T extends TrendSignalAggregateArgs> = {
        [P in keyof T & keyof AggregateTrendSignal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrendSignal[P]>
      : GetScalarType<T[P], AggregateTrendSignal[P]>
  }




  export type TrendSignalGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TrendSignalWhereInput
    orderBy?: Enumerable<TrendSignalOrderByWithAggregationInput>
    by: TrendSignalScalarFieldEnum[]
    having?: TrendSignalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrendSignalCountAggregateInputType | true
    _avg?: TrendSignalAvgAggregateInputType
    _sum?: TrendSignalSumAggregateInputType
    _min?: TrendSignalMinAggregateInputType
    _max?: TrendSignalMaxAggregateInputType
  }


  export type TrendSignalGroupByOutputType = {
    id: string
    title: string
    description: string
    source: string
    signalType: SignalType
    confidence: number
    rawData: JsonValue | null
    impact: TrendImpact
    agentId: string
    createdAt: Date
    updatedAt: Date
    _count: TrendSignalCountAggregateOutputType | null
    _avg: TrendSignalAvgAggregateOutputType | null
    _sum: TrendSignalSumAggregateOutputType | null
    _min: TrendSignalMinAggregateOutputType | null
    _max: TrendSignalMaxAggregateOutputType | null
  }

  type GetTrendSignalGroupByPayload<T extends TrendSignalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TrendSignalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrendSignalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrendSignalGroupByOutputType[P]>
            : GetScalarType<T[P], TrendSignalGroupByOutputType[P]>
        }
      >
    >


  export type TrendSignalSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    source?: boolean
    signalType?: boolean
    confidence?: boolean
    rawData?: boolean
    impact?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AIAgentArgs<ExtArgs>
  }, ExtArgs["result"]["trendSignal"]>

  export type TrendSignalSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    source?: boolean
    signalType?: boolean
    confidence?: boolean
    rawData?: boolean
    impact?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrendSignalInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    agent?: boolean | AIAgentArgs<ExtArgs>
  }


  type TrendSignalGetPayload<S extends boolean | null | undefined | TrendSignalArgs> = $Types.GetResult<TrendSignalPayload, S>

  type TrendSignalCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TrendSignalFindManyArgs, 'select' | 'include'> & {
      select?: TrendSignalCountAggregateInputType | true
    }

  export interface TrendSignalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrendSignal'], meta: { name: 'TrendSignal' } }
    /**
     * Find zero or one TrendSignal that matches the filter.
     * @param {TrendSignalFindUniqueArgs} args - Arguments to find a TrendSignal
     * @example
     * // Get one TrendSignal
     * const trendSignal = await prisma.trendSignal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrendSignalFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TrendSignalFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TrendSignal'> extends True ? Prisma__TrendSignalClient<$Types.GetResult<TrendSignalPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TrendSignalClient<$Types.GetResult<TrendSignalPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one TrendSignal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrendSignalFindUniqueOrThrowArgs} args - Arguments to find a TrendSignal
     * @example
     * // Get one TrendSignal
     * const trendSignal = await prisma.trendSignal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrendSignalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrendSignalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TrendSignalClient<$Types.GetResult<TrendSignalPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first TrendSignal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendSignalFindFirstArgs} args - Arguments to find a TrendSignal
     * @example
     * // Get one TrendSignal
     * const trendSignal = await prisma.trendSignal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrendSignalFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TrendSignalFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TrendSignal'> extends True ? Prisma__TrendSignalClient<$Types.GetResult<TrendSignalPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TrendSignalClient<$Types.GetResult<TrendSignalPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first TrendSignal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendSignalFindFirstOrThrowArgs} args - Arguments to find a TrendSignal
     * @example
     * // Get one TrendSignal
     * const trendSignal = await prisma.trendSignal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrendSignalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrendSignalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TrendSignalClient<$Types.GetResult<TrendSignalPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more TrendSignals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendSignalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrendSignals
     * const trendSignals = await prisma.trendSignal.findMany()
     * 
     * // Get first 10 TrendSignals
     * const trendSignals = await prisma.trendSignal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trendSignalWithIdOnly = await prisma.trendSignal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TrendSignalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrendSignalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TrendSignalPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a TrendSignal.
     * @param {TrendSignalCreateArgs} args - Arguments to create a TrendSignal.
     * @example
     * // Create one TrendSignal
     * const TrendSignal = await prisma.trendSignal.create({
     *   data: {
     *     // ... data to create a TrendSignal
     *   }
     * })
     * 
    **/
    create<T extends TrendSignalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TrendSignalCreateArgs<ExtArgs>>
    ): Prisma__TrendSignalClient<$Types.GetResult<TrendSignalPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many TrendSignals.
     *     @param {TrendSignalCreateManyArgs} args - Arguments to create many TrendSignals.
     *     @example
     *     // Create many TrendSignals
     *     const trendSignal = await prisma.trendSignal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrendSignalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrendSignalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrendSignal.
     * @param {TrendSignalDeleteArgs} args - Arguments to delete one TrendSignal.
     * @example
     * // Delete one TrendSignal
     * const TrendSignal = await prisma.trendSignal.delete({
     *   where: {
     *     // ... filter to delete one TrendSignal
     *   }
     * })
     * 
    **/
    delete<T extends TrendSignalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TrendSignalDeleteArgs<ExtArgs>>
    ): Prisma__TrendSignalClient<$Types.GetResult<TrendSignalPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one TrendSignal.
     * @param {TrendSignalUpdateArgs} args - Arguments to update one TrendSignal.
     * @example
     * // Update one TrendSignal
     * const trendSignal = await prisma.trendSignal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrendSignalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TrendSignalUpdateArgs<ExtArgs>>
    ): Prisma__TrendSignalClient<$Types.GetResult<TrendSignalPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more TrendSignals.
     * @param {TrendSignalDeleteManyArgs} args - Arguments to filter TrendSignals to delete.
     * @example
     * // Delete a few TrendSignals
     * const { count } = await prisma.trendSignal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrendSignalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrendSignalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrendSignals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendSignalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrendSignals
     * const trendSignal = await prisma.trendSignal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrendSignalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TrendSignalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrendSignal.
     * @param {TrendSignalUpsertArgs} args - Arguments to update or create a TrendSignal.
     * @example
     * // Update or create a TrendSignal
     * const trendSignal = await prisma.trendSignal.upsert({
     *   create: {
     *     // ... data to create a TrendSignal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrendSignal we want to update
     *   }
     * })
    **/
    upsert<T extends TrendSignalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TrendSignalUpsertArgs<ExtArgs>>
    ): Prisma__TrendSignalClient<$Types.GetResult<TrendSignalPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of TrendSignals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendSignalCountArgs} args - Arguments to filter TrendSignals to count.
     * @example
     * // Count the number of TrendSignals
     * const count = await prisma.trendSignal.count({
     *   where: {
     *     // ... the filter for the TrendSignals we want to count
     *   }
     * })
    **/
    count<T extends TrendSignalCountArgs>(
      args?: Subset<T, TrendSignalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrendSignalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrendSignal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendSignalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrendSignalAggregateArgs>(args: Subset<T, TrendSignalAggregateArgs>): Prisma.PrismaPromise<GetTrendSignalAggregateType<T>>

    /**
     * Group by TrendSignal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendSignalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrendSignalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrendSignalGroupByArgs['orderBy'] }
        : { orderBy?: TrendSignalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrendSignalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrendSignalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TrendSignal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TrendSignalClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    agent<T extends AIAgentArgs<ExtArgs> = {}>(args?: Subset<T, AIAgentArgs<ExtArgs>>): Prisma__AIAgentClient<$Types.GetResult<AIAgentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TrendSignal base type for findUnique actions
   */
  export type TrendSignalFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendSignal
     */
    select?: TrendSignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrendSignalInclude<ExtArgs> | null
    /**
     * Filter, which TrendSignal to fetch.
     */
    where: TrendSignalWhereUniqueInput
  }

  /**
   * TrendSignal findUnique
   */
  export interface TrendSignalFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TrendSignalFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TrendSignal findUniqueOrThrow
   */
  export type TrendSignalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendSignal
     */
    select?: TrendSignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrendSignalInclude<ExtArgs> | null
    /**
     * Filter, which TrendSignal to fetch.
     */
    where: TrendSignalWhereUniqueInput
  }


  /**
   * TrendSignal base type for findFirst actions
   */
  export type TrendSignalFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendSignal
     */
    select?: TrendSignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrendSignalInclude<ExtArgs> | null
    /**
     * Filter, which TrendSignal to fetch.
     */
    where?: TrendSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrendSignals to fetch.
     */
    orderBy?: Enumerable<TrendSignalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrendSignals.
     */
    cursor?: TrendSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrendSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrendSignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrendSignals.
     */
    distinct?: Enumerable<TrendSignalScalarFieldEnum>
  }

  /**
   * TrendSignal findFirst
   */
  export interface TrendSignalFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TrendSignalFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TrendSignal findFirstOrThrow
   */
  export type TrendSignalFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendSignal
     */
    select?: TrendSignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrendSignalInclude<ExtArgs> | null
    /**
     * Filter, which TrendSignal to fetch.
     */
    where?: TrendSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrendSignals to fetch.
     */
    orderBy?: Enumerable<TrendSignalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrendSignals.
     */
    cursor?: TrendSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrendSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrendSignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrendSignals.
     */
    distinct?: Enumerable<TrendSignalScalarFieldEnum>
  }


  /**
   * TrendSignal findMany
   */
  export type TrendSignalFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendSignal
     */
    select?: TrendSignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrendSignalInclude<ExtArgs> | null
    /**
     * Filter, which TrendSignals to fetch.
     */
    where?: TrendSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrendSignals to fetch.
     */
    orderBy?: Enumerable<TrendSignalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrendSignals.
     */
    cursor?: TrendSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrendSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrendSignals.
     */
    skip?: number
    distinct?: Enumerable<TrendSignalScalarFieldEnum>
  }


  /**
   * TrendSignal create
   */
  export type TrendSignalCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendSignal
     */
    select?: TrendSignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrendSignalInclude<ExtArgs> | null
    /**
     * The data needed to create a TrendSignal.
     */
    data: XOR<TrendSignalCreateInput, TrendSignalUncheckedCreateInput>
  }


  /**
   * TrendSignal createMany
   */
  export type TrendSignalCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrendSignals.
     */
    data: Enumerable<TrendSignalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TrendSignal update
   */
  export type TrendSignalUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendSignal
     */
    select?: TrendSignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrendSignalInclude<ExtArgs> | null
    /**
     * The data needed to update a TrendSignal.
     */
    data: XOR<TrendSignalUpdateInput, TrendSignalUncheckedUpdateInput>
    /**
     * Choose, which TrendSignal to update.
     */
    where: TrendSignalWhereUniqueInput
  }


  /**
   * TrendSignal updateMany
   */
  export type TrendSignalUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrendSignals.
     */
    data: XOR<TrendSignalUpdateManyMutationInput, TrendSignalUncheckedUpdateManyInput>
    /**
     * Filter which TrendSignals to update
     */
    where?: TrendSignalWhereInput
  }


  /**
   * TrendSignal upsert
   */
  export type TrendSignalUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendSignal
     */
    select?: TrendSignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrendSignalInclude<ExtArgs> | null
    /**
     * The filter to search for the TrendSignal to update in case it exists.
     */
    where: TrendSignalWhereUniqueInput
    /**
     * In case the TrendSignal found by the `where` argument doesn't exist, create a new TrendSignal with this data.
     */
    create: XOR<TrendSignalCreateInput, TrendSignalUncheckedCreateInput>
    /**
     * In case the TrendSignal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrendSignalUpdateInput, TrendSignalUncheckedUpdateInput>
  }


  /**
   * TrendSignal delete
   */
  export type TrendSignalDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendSignal
     */
    select?: TrendSignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrendSignalInclude<ExtArgs> | null
    /**
     * Filter which TrendSignal to delete.
     */
    where: TrendSignalWhereUniqueInput
  }


  /**
   * TrendSignal deleteMany
   */
  export type TrendSignalDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrendSignals to delete
     */
    where?: TrendSignalWhereInput
  }


  /**
   * TrendSignal without action
   */
  export type TrendSignalArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrendSignal
     */
    select?: TrendSignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrendSignalInclude<ExtArgs> | null
  }



  /**
   * Model IntegrationCredential
   */


  export type AggregateIntegrationCredential = {
    _count: IntegrationCredentialCountAggregateOutputType | null
    _min: IntegrationCredentialMinAggregateOutputType | null
    _max: IntegrationCredentialMaxAggregateOutputType | null
  }

  export type IntegrationCredentialMinAggregateOutputType = {
    id: string | null
    platform: string | null
    accountIdentifier: string | null
    authToken: string | null
    refreshToken: string | null
    tokenType: string | null
    expiry: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationCredentialMaxAggregateOutputType = {
    id: string | null
    platform: string | null
    accountIdentifier: string | null
    authToken: string | null
    refreshToken: string | null
    tokenType: string | null
    expiry: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationCredentialCountAggregateOutputType = {
    id: number
    platform: number
    accountIdentifier: number
    authToken: number
    refreshToken: number
    tokenType: number
    expiry: number
    scopes: number
    metadata: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntegrationCredentialMinAggregateInputType = {
    id?: true
    platform?: true
    accountIdentifier?: true
    authToken?: true
    refreshToken?: true
    tokenType?: true
    expiry?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationCredentialMaxAggregateInputType = {
    id?: true
    platform?: true
    accountIdentifier?: true
    authToken?: true
    refreshToken?: true
    tokenType?: true
    expiry?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationCredentialCountAggregateInputType = {
    id?: true
    platform?: true
    accountIdentifier?: true
    authToken?: true
    refreshToken?: true
    tokenType?: true
    expiry?: true
    scopes?: true
    metadata?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegrationCredentialAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationCredential to aggregate.
     */
    where?: IntegrationCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationCredentials to fetch.
     */
    orderBy?: Enumerable<IntegrationCredentialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntegrationCredentials
    **/
    _count?: true | IntegrationCredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationCredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationCredentialMaxAggregateInputType
  }

  export type GetIntegrationCredentialAggregateType<T extends IntegrationCredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegrationCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegrationCredential[P]>
      : GetScalarType<T[P], AggregateIntegrationCredential[P]>
  }




  export type IntegrationCredentialGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: IntegrationCredentialWhereInput
    orderBy?: Enumerable<IntegrationCredentialOrderByWithAggregationInput>
    by: IntegrationCredentialScalarFieldEnum[]
    having?: IntegrationCredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCredentialCountAggregateInputType | true
    _min?: IntegrationCredentialMinAggregateInputType
    _max?: IntegrationCredentialMaxAggregateInputType
  }


  export type IntegrationCredentialGroupByOutputType = {
    id: string
    platform: string
    accountIdentifier: string | null
    authToken: string
    refreshToken: string | null
    tokenType: string | null
    expiry: Date | null
    scopes: string[]
    metadata: JsonValue | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: IntegrationCredentialCountAggregateOutputType | null
    _min: IntegrationCredentialMinAggregateOutputType | null
    _max: IntegrationCredentialMaxAggregateOutputType | null
  }

  type GetIntegrationCredentialGroupByPayload<T extends IntegrationCredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<IntegrationCredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationCredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationCredentialGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationCredentialGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationCredentialSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    accountIdentifier?: boolean
    authToken?: boolean
    refreshToken?: boolean
    tokenType?: boolean
    expiry?: boolean
    scopes?: boolean
    metadata?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["integrationCredential"]>

  export type IntegrationCredentialSelectScalar = {
    id?: boolean
    platform?: boolean
    accountIdentifier?: boolean
    authToken?: boolean
    refreshToken?: boolean
    tokenType?: boolean
    expiry?: boolean
    scopes?: boolean
    metadata?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntegrationCredentialInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type IntegrationCredentialGetPayload<S extends boolean | null | undefined | IntegrationCredentialArgs> = $Types.GetResult<IntegrationCredentialPayload, S>

  type IntegrationCredentialCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<IntegrationCredentialFindManyArgs, 'select' | 'include'> & {
      select?: IntegrationCredentialCountAggregateInputType | true
    }

  export interface IntegrationCredentialDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntegrationCredential'], meta: { name: 'IntegrationCredential' } }
    /**
     * Find zero or one IntegrationCredential that matches the filter.
     * @param {IntegrationCredentialFindUniqueArgs} args - Arguments to find a IntegrationCredential
     * @example
     * // Get one IntegrationCredential
     * const integrationCredential = await prisma.integrationCredential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntegrationCredentialFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntegrationCredentialFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntegrationCredential'> extends True ? Prisma__IntegrationCredentialClient<$Types.GetResult<IntegrationCredentialPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__IntegrationCredentialClient<$Types.GetResult<IntegrationCredentialPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one IntegrationCredential that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IntegrationCredentialFindUniqueOrThrowArgs} args - Arguments to find a IntegrationCredential
     * @example
     * // Get one IntegrationCredential
     * const integrationCredential = await prisma.integrationCredential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IntegrationCredentialFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IntegrationCredentialFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IntegrationCredentialClient<$Types.GetResult<IntegrationCredentialPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first IntegrationCredential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCredentialFindFirstArgs} args - Arguments to find a IntegrationCredential
     * @example
     * // Get one IntegrationCredential
     * const integrationCredential = await prisma.integrationCredential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntegrationCredentialFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntegrationCredentialFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntegrationCredential'> extends True ? Prisma__IntegrationCredentialClient<$Types.GetResult<IntegrationCredentialPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__IntegrationCredentialClient<$Types.GetResult<IntegrationCredentialPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first IntegrationCredential that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCredentialFindFirstOrThrowArgs} args - Arguments to find a IntegrationCredential
     * @example
     * // Get one IntegrationCredential
     * const integrationCredential = await prisma.integrationCredential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IntegrationCredentialFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IntegrationCredentialFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IntegrationCredentialClient<$Types.GetResult<IntegrationCredentialPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more IntegrationCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCredentialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntegrationCredentials
     * const integrationCredentials = await prisma.integrationCredential.findMany()
     * 
     * // Get first 10 IntegrationCredentials
     * const integrationCredentials = await prisma.integrationCredential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationCredentialWithIdOnly = await prisma.integrationCredential.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IntegrationCredentialFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IntegrationCredentialFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<IntegrationCredentialPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a IntegrationCredential.
     * @param {IntegrationCredentialCreateArgs} args - Arguments to create a IntegrationCredential.
     * @example
     * // Create one IntegrationCredential
     * const IntegrationCredential = await prisma.integrationCredential.create({
     *   data: {
     *     // ... data to create a IntegrationCredential
     *   }
     * })
     * 
    **/
    create<T extends IntegrationCredentialCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IntegrationCredentialCreateArgs<ExtArgs>>
    ): Prisma__IntegrationCredentialClient<$Types.GetResult<IntegrationCredentialPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many IntegrationCredentials.
     *     @param {IntegrationCredentialCreateManyArgs} args - Arguments to create many IntegrationCredentials.
     *     @example
     *     // Create many IntegrationCredentials
     *     const integrationCredential = await prisma.integrationCredential.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntegrationCredentialCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IntegrationCredentialCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IntegrationCredential.
     * @param {IntegrationCredentialDeleteArgs} args - Arguments to delete one IntegrationCredential.
     * @example
     * // Delete one IntegrationCredential
     * const IntegrationCredential = await prisma.integrationCredential.delete({
     *   where: {
     *     // ... filter to delete one IntegrationCredential
     *   }
     * })
     * 
    **/
    delete<T extends IntegrationCredentialDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IntegrationCredentialDeleteArgs<ExtArgs>>
    ): Prisma__IntegrationCredentialClient<$Types.GetResult<IntegrationCredentialPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one IntegrationCredential.
     * @param {IntegrationCredentialUpdateArgs} args - Arguments to update one IntegrationCredential.
     * @example
     * // Update one IntegrationCredential
     * const integrationCredential = await prisma.integrationCredential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntegrationCredentialUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IntegrationCredentialUpdateArgs<ExtArgs>>
    ): Prisma__IntegrationCredentialClient<$Types.GetResult<IntegrationCredentialPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more IntegrationCredentials.
     * @param {IntegrationCredentialDeleteManyArgs} args - Arguments to filter IntegrationCredentials to delete.
     * @example
     * // Delete a few IntegrationCredentials
     * const { count } = await prisma.integrationCredential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntegrationCredentialDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IntegrationCredentialDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegrationCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntegrationCredentials
     * const integrationCredential = await prisma.integrationCredential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntegrationCredentialUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IntegrationCredentialUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IntegrationCredential.
     * @param {IntegrationCredentialUpsertArgs} args - Arguments to update or create a IntegrationCredential.
     * @example
     * // Update or create a IntegrationCredential
     * const integrationCredential = await prisma.integrationCredential.upsert({
     *   create: {
     *     // ... data to create a IntegrationCredential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntegrationCredential we want to update
     *   }
     * })
    **/
    upsert<T extends IntegrationCredentialUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IntegrationCredentialUpsertArgs<ExtArgs>>
    ): Prisma__IntegrationCredentialClient<$Types.GetResult<IntegrationCredentialPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of IntegrationCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCredentialCountArgs} args - Arguments to filter IntegrationCredentials to count.
     * @example
     * // Count the number of IntegrationCredentials
     * const count = await prisma.integrationCredential.count({
     *   where: {
     *     // ... the filter for the IntegrationCredentials we want to count
     *   }
     * })
    **/
    count<T extends IntegrationCredentialCountArgs>(
      args?: Subset<T, IntegrationCredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntegrationCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationCredentialAggregateArgs>(args: Subset<T, IntegrationCredentialAggregateArgs>): Prisma.PrismaPromise<GetIntegrationCredentialAggregateType<T>>

    /**
     * Group by IntegrationCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationCredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationCredentialGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationCredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationCredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for IntegrationCredential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntegrationCredentialClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * IntegrationCredential base type for findUnique actions
   */
  export type IntegrationCredentialFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCredential
     */
    select?: IntegrationCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IntegrationCredentialInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationCredential to fetch.
     */
    where: IntegrationCredentialWhereUniqueInput
  }

  /**
   * IntegrationCredential findUnique
   */
  export interface IntegrationCredentialFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends IntegrationCredentialFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IntegrationCredential findUniqueOrThrow
   */
  export type IntegrationCredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCredential
     */
    select?: IntegrationCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IntegrationCredentialInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationCredential to fetch.
     */
    where: IntegrationCredentialWhereUniqueInput
  }


  /**
   * IntegrationCredential base type for findFirst actions
   */
  export type IntegrationCredentialFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCredential
     */
    select?: IntegrationCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IntegrationCredentialInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationCredential to fetch.
     */
    where?: IntegrationCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationCredentials to fetch.
     */
    orderBy?: Enumerable<IntegrationCredentialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationCredentials.
     */
    cursor?: IntegrationCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationCredentials.
     */
    distinct?: Enumerable<IntegrationCredentialScalarFieldEnum>
  }

  /**
   * IntegrationCredential findFirst
   */
  export interface IntegrationCredentialFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends IntegrationCredentialFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IntegrationCredential findFirstOrThrow
   */
  export type IntegrationCredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCredential
     */
    select?: IntegrationCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IntegrationCredentialInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationCredential to fetch.
     */
    where?: IntegrationCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationCredentials to fetch.
     */
    orderBy?: Enumerable<IntegrationCredentialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationCredentials.
     */
    cursor?: IntegrationCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationCredentials.
     */
    distinct?: Enumerable<IntegrationCredentialScalarFieldEnum>
  }


  /**
   * IntegrationCredential findMany
   */
  export type IntegrationCredentialFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCredential
     */
    select?: IntegrationCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IntegrationCredentialInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationCredentials to fetch.
     */
    where?: IntegrationCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationCredentials to fetch.
     */
    orderBy?: Enumerable<IntegrationCredentialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntegrationCredentials.
     */
    cursor?: IntegrationCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationCredentials.
     */
    skip?: number
    distinct?: Enumerable<IntegrationCredentialScalarFieldEnum>
  }


  /**
   * IntegrationCredential create
   */
  export type IntegrationCredentialCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCredential
     */
    select?: IntegrationCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IntegrationCredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a IntegrationCredential.
     */
    data: XOR<IntegrationCredentialCreateInput, IntegrationCredentialUncheckedCreateInput>
  }


  /**
   * IntegrationCredential createMany
   */
  export type IntegrationCredentialCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntegrationCredentials.
     */
    data: Enumerable<IntegrationCredentialCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntegrationCredential update
   */
  export type IntegrationCredentialUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCredential
     */
    select?: IntegrationCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IntegrationCredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a IntegrationCredential.
     */
    data: XOR<IntegrationCredentialUpdateInput, IntegrationCredentialUncheckedUpdateInput>
    /**
     * Choose, which IntegrationCredential to update.
     */
    where: IntegrationCredentialWhereUniqueInput
  }


  /**
   * IntegrationCredential updateMany
   */
  export type IntegrationCredentialUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntegrationCredentials.
     */
    data: XOR<IntegrationCredentialUpdateManyMutationInput, IntegrationCredentialUncheckedUpdateManyInput>
    /**
     * Filter which IntegrationCredentials to update
     */
    where?: IntegrationCredentialWhereInput
  }


  /**
   * IntegrationCredential upsert
   */
  export type IntegrationCredentialUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCredential
     */
    select?: IntegrationCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IntegrationCredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the IntegrationCredential to update in case it exists.
     */
    where: IntegrationCredentialWhereUniqueInput
    /**
     * In case the IntegrationCredential found by the `where` argument doesn't exist, create a new IntegrationCredential with this data.
     */
    create: XOR<IntegrationCredentialCreateInput, IntegrationCredentialUncheckedCreateInput>
    /**
     * In case the IntegrationCredential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationCredentialUpdateInput, IntegrationCredentialUncheckedUpdateInput>
  }


  /**
   * IntegrationCredential delete
   */
  export type IntegrationCredentialDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCredential
     */
    select?: IntegrationCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IntegrationCredentialInclude<ExtArgs> | null
    /**
     * Filter which IntegrationCredential to delete.
     */
    where: IntegrationCredentialWhereUniqueInput
  }


  /**
   * IntegrationCredential deleteMany
   */
  export type IntegrationCredentialDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationCredentials to delete
     */
    where?: IntegrationCredentialWhereInput
  }


  /**
   * IntegrationCredential without action
   */
  export type IntegrationCredentialArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCredential
     */
    select?: IntegrationCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IntegrationCredentialInclude<ExtArgs> | null
  }



  /**
   * Model Metric
   */


  export type AggregateMetric = {
    _count: MetricCountAggregateOutputType | null
    _avg: MetricAvgAggregateOutputType | null
    _sum: MetricSumAggregateOutputType | null
    _min: MetricMinAggregateOutputType | null
    _max: MetricMaxAggregateOutputType | null
  }

  export type MetricAvgAggregateOutputType = {
    value: number | null
  }

  export type MetricSumAggregateOutputType = {
    value: number | null
  }

  export type MetricMinAggregateOutputType = {
    id: string | null
    name: string | null
    source: string | null
    value: number | null
    unit: string | null
    dimension: string | null
    campaignId: string | null
    projectId: string | null
    timestamp: Date | null
  }

  export type MetricMaxAggregateOutputType = {
    id: string | null
    name: string | null
    source: string | null
    value: number | null
    unit: string | null
    dimension: string | null
    campaignId: string | null
    projectId: string | null
    timestamp: Date | null
  }

  export type MetricCountAggregateOutputType = {
    id: number
    name: number
    source: number
    value: number
    unit: number
    dimension: number
    campaignId: number
    projectId: number
    timestamp: number
    metadata: number
    _all: number
  }


  export type MetricAvgAggregateInputType = {
    value?: true
  }

  export type MetricSumAggregateInputType = {
    value?: true
  }

  export type MetricMinAggregateInputType = {
    id?: true
    name?: true
    source?: true
    value?: true
    unit?: true
    dimension?: true
    campaignId?: true
    projectId?: true
    timestamp?: true
  }

  export type MetricMaxAggregateInputType = {
    id?: true
    name?: true
    source?: true
    value?: true
    unit?: true
    dimension?: true
    campaignId?: true
    projectId?: true
    timestamp?: true
  }

  export type MetricCountAggregateInputType = {
    id?: true
    name?: true
    source?: true
    value?: true
    unit?: true
    dimension?: true
    campaignId?: true
    projectId?: true
    timestamp?: true
    metadata?: true
    _all?: true
  }

  export type MetricAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metric to aggregate.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: Enumerable<MetricOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Metrics
    **/
    _count?: true | MetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetricMaxAggregateInputType
  }

  export type GetMetricAggregateType<T extends MetricAggregateArgs> = {
        [P in keyof T & keyof AggregateMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetric[P]>
      : GetScalarType<T[P], AggregateMetric[P]>
  }




  export type MetricGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MetricWhereInput
    orderBy?: Enumerable<MetricOrderByWithAggregationInput>
    by: MetricScalarFieldEnum[]
    having?: MetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetricCountAggregateInputType | true
    _avg?: MetricAvgAggregateInputType
    _sum?: MetricSumAggregateInputType
    _min?: MetricMinAggregateInputType
    _max?: MetricMaxAggregateInputType
  }


  export type MetricGroupByOutputType = {
    id: string
    name: string
    source: string
    value: number
    unit: string | null
    dimension: string | null
    campaignId: string | null
    projectId: string | null
    timestamp: Date
    metadata: JsonValue | null
    _count: MetricCountAggregateOutputType | null
    _avg: MetricAvgAggregateOutputType | null
    _sum: MetricSumAggregateOutputType | null
    _min: MetricMinAggregateOutputType | null
    _max: MetricMaxAggregateOutputType | null
  }

  type GetMetricGroupByPayload<T extends MetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetricGroupByOutputType[P]>
            : GetScalarType<T[P], MetricGroupByOutputType[P]>
        }
      >
    >


  export type MetricSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    source?: boolean
    value?: boolean
    unit?: boolean
    dimension?: boolean
    campaignId?: boolean
    projectId?: boolean
    timestamp?: boolean
    metadata?: boolean
    campaign?: boolean | CampaignArgs<ExtArgs>
    project?: boolean | ProjectArgs<ExtArgs>
  }, ExtArgs["result"]["metric"]>

  export type MetricSelectScalar = {
    id?: boolean
    name?: boolean
    source?: boolean
    value?: boolean
    unit?: boolean
    dimension?: boolean
    campaignId?: boolean
    projectId?: boolean
    timestamp?: boolean
    metadata?: boolean
  }

  export type MetricInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignArgs<ExtArgs>
    project?: boolean | ProjectArgs<ExtArgs>
  }


  type MetricGetPayload<S extends boolean | null | undefined | MetricArgs> = $Types.GetResult<MetricPayload, S>

  type MetricCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MetricFindManyArgs, 'select' | 'include'> & {
      select?: MetricCountAggregateInputType | true
    }

  export interface MetricDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Metric'], meta: { name: 'Metric' } }
    /**
     * Find zero or one Metric that matches the filter.
     * @param {MetricFindUniqueArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MetricFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MetricFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Metric'> extends True ? Prisma__MetricClient<$Types.GetResult<MetricPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__MetricClient<$Types.GetResult<MetricPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Metric that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MetricFindUniqueOrThrowArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MetricFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MetricFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MetricClient<$Types.GetResult<MetricPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Metric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindFirstArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MetricFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MetricFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Metric'> extends True ? Prisma__MetricClient<$Types.GetResult<MetricPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__MetricClient<$Types.GetResult<MetricPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Metric that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindFirstOrThrowArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MetricFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MetricFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MetricClient<$Types.GetResult<MetricPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Metrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metrics
     * const metrics = await prisma.metric.findMany()
     * 
     * // Get first 10 Metrics
     * const metrics = await prisma.metric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metricWithIdOnly = await prisma.metric.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MetricFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MetricFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MetricPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Metric.
     * @param {MetricCreateArgs} args - Arguments to create a Metric.
     * @example
     * // Create one Metric
     * const Metric = await prisma.metric.create({
     *   data: {
     *     // ... data to create a Metric
     *   }
     * })
     * 
    **/
    create<T extends MetricCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MetricCreateArgs<ExtArgs>>
    ): Prisma__MetricClient<$Types.GetResult<MetricPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Metrics.
     *     @param {MetricCreateManyArgs} args - Arguments to create many Metrics.
     *     @example
     *     // Create many Metrics
     *     const metric = await prisma.metric.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MetricCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MetricCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Metric.
     * @param {MetricDeleteArgs} args - Arguments to delete one Metric.
     * @example
     * // Delete one Metric
     * const Metric = await prisma.metric.delete({
     *   where: {
     *     // ... filter to delete one Metric
     *   }
     * })
     * 
    **/
    delete<T extends MetricDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MetricDeleteArgs<ExtArgs>>
    ): Prisma__MetricClient<$Types.GetResult<MetricPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Metric.
     * @param {MetricUpdateArgs} args - Arguments to update one Metric.
     * @example
     * // Update one Metric
     * const metric = await prisma.metric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MetricUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MetricUpdateArgs<ExtArgs>>
    ): Prisma__MetricClient<$Types.GetResult<MetricPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Metrics.
     * @param {MetricDeleteManyArgs} args - Arguments to filter Metrics to delete.
     * @example
     * // Delete a few Metrics
     * const { count } = await prisma.metric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MetricDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MetricDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metrics
     * const metric = await prisma.metric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MetricUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MetricUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Metric.
     * @param {MetricUpsertArgs} args - Arguments to update or create a Metric.
     * @example
     * // Update or create a Metric
     * const metric = await prisma.metric.upsert({
     *   create: {
     *     // ... data to create a Metric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metric we want to update
     *   }
     * })
    **/
    upsert<T extends MetricUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MetricUpsertArgs<ExtArgs>>
    ): Prisma__MetricClient<$Types.GetResult<MetricPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricCountArgs} args - Arguments to filter Metrics to count.
     * @example
     * // Count the number of Metrics
     * const count = await prisma.metric.count({
     *   where: {
     *     // ... the filter for the Metrics we want to count
     *   }
     * })
    **/
    count<T extends MetricCountArgs>(
      args?: Subset<T, MetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetricAggregateArgs>(args: Subset<T, MetricAggregateArgs>): Prisma.PrismaPromise<GetMetricAggregateType<T>>

    /**
     * Group by Metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetricGroupByArgs['orderBy'] }
        : { orderBy?: MetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Metric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MetricClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    campaign<T extends CampaignArgs<ExtArgs> = {}>(args?: Subset<T, CampaignArgs<ExtArgs>>): Prisma__CampaignClient<$Types.GetResult<CampaignPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    project<T extends ProjectArgs<ExtArgs> = {}>(args?: Subset<T, ProjectArgs<ExtArgs>>): Prisma__ProjectClient<$Types.GetResult<ProjectPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Metric base type for findUnique actions
   */
  export type MetricFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric findUnique
   */
  export interface MetricFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MetricFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Metric findUniqueOrThrow
   */
  export type MetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where: MetricWhereUniqueInput
  }


  /**
   * Metric base type for findFirst actions
   */
  export type MetricFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: Enumerable<MetricOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metrics.
     */
    distinct?: Enumerable<MetricScalarFieldEnum>
  }

  /**
   * Metric findFirst
   */
  export interface MetricFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MetricFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Metric findFirstOrThrow
   */
  export type MetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: Enumerable<MetricOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metrics.
     */
    distinct?: Enumerable<MetricScalarFieldEnum>
  }


  /**
   * Metric findMany
   */
  export type MetricFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * Filter, which Metrics to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: Enumerable<MetricOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    distinct?: Enumerable<MetricScalarFieldEnum>
  }


  /**
   * Metric create
   */
  export type MetricCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * The data needed to create a Metric.
     */
    data: XOR<MetricCreateInput, MetricUncheckedCreateInput>
  }


  /**
   * Metric createMany
   */
  export type MetricCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Metrics.
     */
    data: Enumerable<MetricCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Metric update
   */
  export type MetricUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * The data needed to update a Metric.
     */
    data: XOR<MetricUpdateInput, MetricUncheckedUpdateInput>
    /**
     * Choose, which Metric to update.
     */
    where: MetricWhereUniqueInput
  }


  /**
   * Metric updateMany
   */
  export type MetricUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Metrics.
     */
    data: XOR<MetricUpdateManyMutationInput, MetricUncheckedUpdateManyInput>
    /**
     * Filter which Metrics to update
     */
    where?: MetricWhereInput
  }


  /**
   * Metric upsert
   */
  export type MetricUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * The filter to search for the Metric to update in case it exists.
     */
    where: MetricWhereUniqueInput
    /**
     * In case the Metric found by the `where` argument doesn't exist, create a new Metric with this data.
     */
    create: XOR<MetricCreateInput, MetricUncheckedCreateInput>
    /**
     * In case the Metric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetricUpdateInput, MetricUncheckedUpdateInput>
  }


  /**
   * Metric delete
   */
  export type MetricDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * Filter which Metric to delete.
     */
    where: MetricWhereUniqueInput
  }


  /**
   * Metric deleteMany
   */
  export type MetricDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metrics to delete
     */
    where?: MetricWhereInput
  }


  /**
   * Metric without action
   */
  export type MetricArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetricInclude<ExtArgs> | null
  }



  /**
   * Model PersonalizationProfile
   */


  export type AggregatePersonalizationProfile = {
    _count: PersonalizationProfileCountAggregateOutputType | null
    _avg: PersonalizationProfileAvgAggregateOutputType | null
    _sum: PersonalizationProfileSumAggregateOutputType | null
    _min: PersonalizationProfileMinAggregateOutputType | null
    _max: PersonalizationProfileMaxAggregateOutputType | null
  }

  export type PersonalizationProfileAvgAggregateOutputType = {
    engagementScore: number | null
  }

  export type PersonalizationProfileSumAggregateOutputType = {
    engagementScore: number | null
  }

  export type PersonalizationProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    behaviorCluster: string | null
    engagementScore: number | null
    devicePreference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonalizationProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    behaviorCluster: string | null
    engagementScore: number | null
    devicePreference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonalizationProfileCountAggregateOutputType = {
    id: number
    userId: number
    behaviorCluster: number
    interestAffinity: number
    engagementScore: number
    contentPreferences: number
    activeHours: number
    devicePreference: number
    clickPatterns: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PersonalizationProfileAvgAggregateInputType = {
    engagementScore?: true
  }

  export type PersonalizationProfileSumAggregateInputType = {
    engagementScore?: true
  }

  export type PersonalizationProfileMinAggregateInputType = {
    id?: true
    userId?: true
    behaviorCluster?: true
    engagementScore?: true
    devicePreference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonalizationProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    behaviorCluster?: true
    engagementScore?: true
    devicePreference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonalizationProfileCountAggregateInputType = {
    id?: true
    userId?: true
    behaviorCluster?: true
    interestAffinity?: true
    engagementScore?: true
    contentPreferences?: true
    activeHours?: true
    devicePreference?: true
    clickPatterns?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PersonalizationProfileAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalizationProfile to aggregate.
     */
    where?: PersonalizationProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalizationProfiles to fetch.
     */
    orderBy?: Enumerable<PersonalizationProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalizationProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalizationProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalizationProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonalizationProfiles
    **/
    _count?: true | PersonalizationProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonalizationProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonalizationProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalizationProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalizationProfileMaxAggregateInputType
  }

  export type GetPersonalizationProfileAggregateType<T extends PersonalizationProfileAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalizationProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalizationProfile[P]>
      : GetScalarType<T[P], AggregatePersonalizationProfile[P]>
  }




  export type PersonalizationProfileGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PersonalizationProfileWhereInput
    orderBy?: Enumerable<PersonalizationProfileOrderByWithAggregationInput>
    by: PersonalizationProfileScalarFieldEnum[]
    having?: PersonalizationProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalizationProfileCountAggregateInputType | true
    _avg?: PersonalizationProfileAvgAggregateInputType
    _sum?: PersonalizationProfileSumAggregateInputType
    _min?: PersonalizationProfileMinAggregateInputType
    _max?: PersonalizationProfileMaxAggregateInputType
  }


  export type PersonalizationProfileGroupByOutputType = {
    id: string
    userId: string
    behaviorCluster: string
    interestAffinity: JsonValue
    engagementScore: number
    contentPreferences: JsonValue
    activeHours: JsonValue | null
    devicePreference: string | null
    clickPatterns: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PersonalizationProfileCountAggregateOutputType | null
    _avg: PersonalizationProfileAvgAggregateOutputType | null
    _sum: PersonalizationProfileSumAggregateOutputType | null
    _min: PersonalizationProfileMinAggregateOutputType | null
    _max: PersonalizationProfileMaxAggregateOutputType | null
  }

  type GetPersonalizationProfileGroupByPayload<T extends PersonalizationProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PersonalizationProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalizationProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalizationProfileGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalizationProfileGroupByOutputType[P]>
        }
      >
    >


  export type PersonalizationProfileSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    behaviorCluster?: boolean
    interestAffinity?: boolean
    engagementScore?: boolean
    contentPreferences?: boolean
    activeHours?: boolean
    devicePreference?: boolean
    clickPatterns?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["personalizationProfile"]>

  export type PersonalizationProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    behaviorCluster?: boolean
    interestAffinity?: boolean
    engagementScore?: boolean
    contentPreferences?: boolean
    activeHours?: boolean
    devicePreference?: boolean
    clickPatterns?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PersonalizationProfileInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type PersonalizationProfileGetPayload<S extends boolean | null | undefined | PersonalizationProfileArgs> = $Types.GetResult<PersonalizationProfilePayload, S>

  type PersonalizationProfileCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PersonalizationProfileFindManyArgs, 'select' | 'include'> & {
      select?: PersonalizationProfileCountAggregateInputType | true
    }

  export interface PersonalizationProfileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonalizationProfile'], meta: { name: 'PersonalizationProfile' } }
    /**
     * Find zero or one PersonalizationProfile that matches the filter.
     * @param {PersonalizationProfileFindUniqueArgs} args - Arguments to find a PersonalizationProfile
     * @example
     * // Get one PersonalizationProfile
     * const personalizationProfile = await prisma.personalizationProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PersonalizationProfileFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PersonalizationProfileFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PersonalizationProfile'> extends True ? Prisma__PersonalizationProfileClient<$Types.GetResult<PersonalizationProfilePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PersonalizationProfileClient<$Types.GetResult<PersonalizationProfilePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PersonalizationProfile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PersonalizationProfileFindUniqueOrThrowArgs} args - Arguments to find a PersonalizationProfile
     * @example
     * // Get one PersonalizationProfile
     * const personalizationProfile = await prisma.personalizationProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PersonalizationProfileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonalizationProfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PersonalizationProfileClient<$Types.GetResult<PersonalizationProfilePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PersonalizationProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationProfileFindFirstArgs} args - Arguments to find a PersonalizationProfile
     * @example
     * // Get one PersonalizationProfile
     * const personalizationProfile = await prisma.personalizationProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PersonalizationProfileFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PersonalizationProfileFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PersonalizationProfile'> extends True ? Prisma__PersonalizationProfileClient<$Types.GetResult<PersonalizationProfilePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PersonalizationProfileClient<$Types.GetResult<PersonalizationProfilePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PersonalizationProfile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationProfileFindFirstOrThrowArgs} args - Arguments to find a PersonalizationProfile
     * @example
     * // Get one PersonalizationProfile
     * const personalizationProfile = await prisma.personalizationProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PersonalizationProfileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonalizationProfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PersonalizationProfileClient<$Types.GetResult<PersonalizationProfilePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PersonalizationProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalizationProfiles
     * const personalizationProfiles = await prisma.personalizationProfile.findMany()
     * 
     * // Get first 10 PersonalizationProfiles
     * const personalizationProfiles = await prisma.personalizationProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalizationProfileWithIdOnly = await prisma.personalizationProfile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PersonalizationProfileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonalizationProfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PersonalizationProfilePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PersonalizationProfile.
     * @param {PersonalizationProfileCreateArgs} args - Arguments to create a PersonalizationProfile.
     * @example
     * // Create one PersonalizationProfile
     * const PersonalizationProfile = await prisma.personalizationProfile.create({
     *   data: {
     *     // ... data to create a PersonalizationProfile
     *   }
     * })
     * 
    **/
    create<T extends PersonalizationProfileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PersonalizationProfileCreateArgs<ExtArgs>>
    ): Prisma__PersonalizationProfileClient<$Types.GetResult<PersonalizationProfilePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PersonalizationProfiles.
     *     @param {PersonalizationProfileCreateManyArgs} args - Arguments to create many PersonalizationProfiles.
     *     @example
     *     // Create many PersonalizationProfiles
     *     const personalizationProfile = await prisma.personalizationProfile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PersonalizationProfileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonalizationProfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PersonalizationProfile.
     * @param {PersonalizationProfileDeleteArgs} args - Arguments to delete one PersonalizationProfile.
     * @example
     * // Delete one PersonalizationProfile
     * const PersonalizationProfile = await prisma.personalizationProfile.delete({
     *   where: {
     *     // ... filter to delete one PersonalizationProfile
     *   }
     * })
     * 
    **/
    delete<T extends PersonalizationProfileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PersonalizationProfileDeleteArgs<ExtArgs>>
    ): Prisma__PersonalizationProfileClient<$Types.GetResult<PersonalizationProfilePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PersonalizationProfile.
     * @param {PersonalizationProfileUpdateArgs} args - Arguments to update one PersonalizationProfile.
     * @example
     * // Update one PersonalizationProfile
     * const personalizationProfile = await prisma.personalizationProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PersonalizationProfileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PersonalizationProfileUpdateArgs<ExtArgs>>
    ): Prisma__PersonalizationProfileClient<$Types.GetResult<PersonalizationProfilePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PersonalizationProfiles.
     * @param {PersonalizationProfileDeleteManyArgs} args - Arguments to filter PersonalizationProfiles to delete.
     * @example
     * // Delete a few PersonalizationProfiles
     * const { count } = await prisma.personalizationProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PersonalizationProfileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonalizationProfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalizationProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalizationProfiles
     * const personalizationProfile = await prisma.personalizationProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PersonalizationProfileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PersonalizationProfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonalizationProfile.
     * @param {PersonalizationProfileUpsertArgs} args - Arguments to update or create a PersonalizationProfile.
     * @example
     * // Update or create a PersonalizationProfile
     * const personalizationProfile = await prisma.personalizationProfile.upsert({
     *   create: {
     *     // ... data to create a PersonalizationProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalizationProfile we want to update
     *   }
     * })
    **/
    upsert<T extends PersonalizationProfileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PersonalizationProfileUpsertArgs<ExtArgs>>
    ): Prisma__PersonalizationProfileClient<$Types.GetResult<PersonalizationProfilePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PersonalizationProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationProfileCountArgs} args - Arguments to filter PersonalizationProfiles to count.
     * @example
     * // Count the number of PersonalizationProfiles
     * const count = await prisma.personalizationProfile.count({
     *   where: {
     *     // ... the filter for the PersonalizationProfiles we want to count
     *   }
     * })
    **/
    count<T extends PersonalizationProfileCountArgs>(
      args?: Subset<T, PersonalizationProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalizationProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalizationProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalizationProfileAggregateArgs>(args: Subset<T, PersonalizationProfileAggregateArgs>): Prisma.PrismaPromise<GetPersonalizationProfileAggregateType<T>>

    /**
     * Group by PersonalizationProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalizationProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalizationProfileGroupByArgs['orderBy'] }
        : { orderBy?: PersonalizationProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalizationProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalizationProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonalizationProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PersonalizationProfileClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PersonalizationProfile base type for findUnique actions
   */
  export type PersonalizationProfileFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationProfile
     */
    select?: PersonalizationProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationProfileInclude<ExtArgs> | null
    /**
     * Filter, which PersonalizationProfile to fetch.
     */
    where: PersonalizationProfileWhereUniqueInput
  }

  /**
   * PersonalizationProfile findUnique
   */
  export interface PersonalizationProfileFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PersonalizationProfileFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PersonalizationProfile findUniqueOrThrow
   */
  export type PersonalizationProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationProfile
     */
    select?: PersonalizationProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationProfileInclude<ExtArgs> | null
    /**
     * Filter, which PersonalizationProfile to fetch.
     */
    where: PersonalizationProfileWhereUniqueInput
  }


  /**
   * PersonalizationProfile base type for findFirst actions
   */
  export type PersonalizationProfileFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationProfile
     */
    select?: PersonalizationProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationProfileInclude<ExtArgs> | null
    /**
     * Filter, which PersonalizationProfile to fetch.
     */
    where?: PersonalizationProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalizationProfiles to fetch.
     */
    orderBy?: Enumerable<PersonalizationProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalizationProfiles.
     */
    cursor?: PersonalizationProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalizationProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalizationProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalizationProfiles.
     */
    distinct?: Enumerable<PersonalizationProfileScalarFieldEnum>
  }

  /**
   * PersonalizationProfile findFirst
   */
  export interface PersonalizationProfileFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PersonalizationProfileFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PersonalizationProfile findFirstOrThrow
   */
  export type PersonalizationProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationProfile
     */
    select?: PersonalizationProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationProfileInclude<ExtArgs> | null
    /**
     * Filter, which PersonalizationProfile to fetch.
     */
    where?: PersonalizationProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalizationProfiles to fetch.
     */
    orderBy?: Enumerable<PersonalizationProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalizationProfiles.
     */
    cursor?: PersonalizationProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalizationProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalizationProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalizationProfiles.
     */
    distinct?: Enumerable<PersonalizationProfileScalarFieldEnum>
  }


  /**
   * PersonalizationProfile findMany
   */
  export type PersonalizationProfileFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationProfile
     */
    select?: PersonalizationProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationProfileInclude<ExtArgs> | null
    /**
     * Filter, which PersonalizationProfiles to fetch.
     */
    where?: PersonalizationProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalizationProfiles to fetch.
     */
    orderBy?: Enumerable<PersonalizationProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonalizationProfiles.
     */
    cursor?: PersonalizationProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalizationProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalizationProfiles.
     */
    skip?: number
    distinct?: Enumerable<PersonalizationProfileScalarFieldEnum>
  }


  /**
   * PersonalizationProfile create
   */
  export type PersonalizationProfileCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationProfile
     */
    select?: PersonalizationProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonalizationProfile.
     */
    data: XOR<PersonalizationProfileCreateInput, PersonalizationProfileUncheckedCreateInput>
  }


  /**
   * PersonalizationProfile createMany
   */
  export type PersonalizationProfileCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonalizationProfiles.
     */
    data: Enumerable<PersonalizationProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PersonalizationProfile update
   */
  export type PersonalizationProfileUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationProfile
     */
    select?: PersonalizationProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonalizationProfile.
     */
    data: XOR<PersonalizationProfileUpdateInput, PersonalizationProfileUncheckedUpdateInput>
    /**
     * Choose, which PersonalizationProfile to update.
     */
    where: PersonalizationProfileWhereUniqueInput
  }


  /**
   * PersonalizationProfile updateMany
   */
  export type PersonalizationProfileUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonalizationProfiles.
     */
    data: XOR<PersonalizationProfileUpdateManyMutationInput, PersonalizationProfileUncheckedUpdateManyInput>
    /**
     * Filter which PersonalizationProfiles to update
     */
    where?: PersonalizationProfileWhereInput
  }


  /**
   * PersonalizationProfile upsert
   */
  export type PersonalizationProfileUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationProfile
     */
    select?: PersonalizationProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonalizationProfile to update in case it exists.
     */
    where: PersonalizationProfileWhereUniqueInput
    /**
     * In case the PersonalizationProfile found by the `where` argument doesn't exist, create a new PersonalizationProfile with this data.
     */
    create: XOR<PersonalizationProfileCreateInput, PersonalizationProfileUncheckedCreateInput>
    /**
     * In case the PersonalizationProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalizationProfileUpdateInput, PersonalizationProfileUncheckedUpdateInput>
  }


  /**
   * PersonalizationProfile delete
   */
  export type PersonalizationProfileDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationProfile
     */
    select?: PersonalizationProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationProfileInclude<ExtArgs> | null
    /**
     * Filter which PersonalizationProfile to delete.
     */
    where: PersonalizationProfileWhereUniqueInput
  }


  /**
   * PersonalizationProfile deleteMany
   */
  export type PersonalizationProfileDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalizationProfiles to delete
     */
    where?: PersonalizationProfileWhereInput
  }


  /**
   * PersonalizationProfile without action
   */
  export type PersonalizationProfileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationProfile
     */
    select?: PersonalizationProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationProfileInclude<ExtArgs> | null
  }



  /**
   * Model Feedback
   */


  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: string | null
    channel: FeedbackChannel | null
    content: string | null
    sentiment: Sentiment | null
    sourceType: FeedbackSource | null
    sourceId: string | null
    userId: string | null
    contentId: string | null
    outreachTaskId: string | null
    createdAt: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: string | null
    channel: FeedbackChannel | null
    content: string | null
    sentiment: Sentiment | null
    sourceType: FeedbackSource | null
    sourceId: string | null
    userId: string | null
    contentId: string | null
    outreachTaskId: string | null
    createdAt: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    channel: number
    content: number
    sentiment: number
    sourceType: number
    sourceId: number
    userId: number
    contentId: number
    outreachTaskId: number
    createdAt: number
    _all: number
  }


  export type FeedbackMinAggregateInputType = {
    id?: true
    channel?: true
    content?: true
    sentiment?: true
    sourceType?: true
    sourceId?: true
    userId?: true
    contentId?: true
    outreachTaskId?: true
    createdAt?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    channel?: true
    content?: true
    sentiment?: true
    sourceType?: true
    sourceId?: true
    userId?: true
    contentId?: true
    outreachTaskId?: true
    createdAt?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    channel?: true
    content?: true
    sentiment?: true
    sourceType?: true
    sourceId?: true
    userId?: true
    contentId?: true
    outreachTaskId?: true
    createdAt?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: Enumerable<FeedbackOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: Enumerable<FeedbackOrderByWithAggregationInput>
    by: FeedbackScalarFieldEnum[]
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }


  export type FeedbackGroupByOutputType = {
    id: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    userId: string
    contentId: string | null
    outreachTaskId: string | null
    createdAt: Date
    _count: FeedbackCountAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channel?: boolean
    content?: boolean
    sentiment?: boolean
    sourceType?: boolean
    sourceId?: boolean
    userId?: boolean
    contentId?: boolean
    outreachTaskId?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    content_rel?: boolean | GeneratedContentArgs<ExtArgs>
    outreachTask?: boolean | OutreachTaskArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    channel?: boolean
    content?: boolean
    sentiment?: boolean
    sourceType?: boolean
    sourceId?: boolean
    userId?: boolean
    contentId?: boolean
    outreachTaskId?: boolean
    createdAt?: boolean
  }

  export type FeedbackInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    content_rel?: boolean | GeneratedContentArgs<ExtArgs>
    outreachTask?: boolean | OutreachTaskArgs<ExtArgs>
  }


  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackArgs> = $Types.GetResult<FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<FeedbackFindManyArgs, 'select' | 'include'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeedbackFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Feedback'> extends True ? Prisma__FeedbackClient<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__FeedbackClient<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Feedback that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeedbackFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Feedback'> extends True ? Prisma__FeedbackClient<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__FeedbackClient<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Feedback that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeedbackFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
    **/
    create<T extends FeedbackCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Feedbacks.
     *     @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     *     @example
     *     // Create many Feedbacks
     *     const feedback = await prisma.feedback.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeedbackCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
    **/
    delete<T extends FeedbackDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeedbackUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeedbackDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeedbackUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
    **/
    upsert<T extends FeedbackUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Types.GetResult<FeedbackPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    content_rel<T extends GeneratedContentArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedContentArgs<ExtArgs>>): Prisma__GeneratedContentClient<$Types.GetResult<GeneratedContentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    outreachTask<T extends OutreachTaskArgs<ExtArgs> = {}>(args?: Subset<T, OutreachTaskArgs<ExtArgs>>): Prisma__OutreachTaskClient<$Types.GetResult<OutreachTaskPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Feedback base type for findUnique actions
   */
  export type FeedbackFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUnique
   */
  export interface FeedbackFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends FeedbackFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback base type for findFirst actions
   */
  export type FeedbackFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: Enumerable<FeedbackOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: Enumerable<FeedbackScalarFieldEnum>
  }

  /**
   * Feedback findFirst
   */
  export interface FeedbackFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends FeedbackFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: Enumerable<FeedbackOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: Enumerable<FeedbackScalarFieldEnum>
  }


  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: Enumerable<FeedbackOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: Enumerable<FeedbackScalarFieldEnum>
  }


  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }


  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: Enumerable<FeedbackCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
  }


  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }


  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
  }


  /**
   * Feedback without action
   */
  export type FeedbackArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    avatar: 'avatar',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    projectId: 'projectId',
    assigneeId: 'assigneeId',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    projectId: 'projectId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    fileUrl: 'fileUrl',
    fileType: 'fileType',
    fileSize: 'fileSize',
    projectId: 'projectId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const AIAgentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    agentType: 'agentType',
    configuration: 'configuration',
    lastRunAt: 'lastRunAt',
    nextRunAt: 'nextRunAt',
    scheduleExpression: 'scheduleExpression',
    scheduleEnabled: 'scheduleEnabled',
    status: 'status',
    projectId: 'projectId',
    managerId: 'managerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIAgentScalarFieldEnum = (typeof AIAgentScalarFieldEnum)[keyof typeof AIAgentScalarFieldEnum]


  export const AgentExecutionSessionScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    success: 'success',
    duration: 'duration',
    outputSummary: 'outputSummary',
    logs: 'logs',
    context: 'context',
    metrics: 'metrics',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt'
  };

  export type AgentExecutionSessionScalarFieldEnum = (typeof AgentExecutionSessionScalarFieldEnum)[keyof typeof AgentExecutionSessionScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    campaignType: 'campaignType',
    goals: 'goals',
    targeting: 'targeting',
    budget: 'budget',
    startDate: 'startDate',
    endDate: 'endDate',
    ownerId: 'ownerId',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const GeneratedContentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    contentType: 'contentType',
    platform: 'platform',
    status: 'status',
    metadata: 'metadata',
    agentId: 'agentId',
    campaignId: 'campaignId',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GeneratedContentScalarFieldEnum = (typeof GeneratedContentScalarFieldEnum)[keyof typeof GeneratedContentScalarFieldEnum]


  export const OutreachTaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    outreachType: 'outreachType',
    status: 'status',
    leadInfo: 'leadInfo',
    contactMethod: 'contactMethod',
    aiResponse: 'aiResponse',
    responseHandlerId: 'responseHandlerId',
    campaignId: 'campaignId',
    scheduledAt: 'scheduledAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OutreachTaskScalarFieldEnum = (typeof OutreachTaskScalarFieldEnum)[keyof typeof OutreachTaskScalarFieldEnum]


  export const TrendSignalScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    source: 'source',
    signalType: 'signalType',
    confidence: 'confidence',
    rawData: 'rawData',
    impact: 'impact',
    agentId: 'agentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrendSignalScalarFieldEnum = (typeof TrendSignalScalarFieldEnum)[keyof typeof TrendSignalScalarFieldEnum]


  export const IntegrationCredentialScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    accountIdentifier: 'accountIdentifier',
    authToken: 'authToken',
    refreshToken: 'refreshToken',
    tokenType: 'tokenType',
    expiry: 'expiry',
    scopes: 'scopes',
    metadata: 'metadata',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntegrationCredentialScalarFieldEnum = (typeof IntegrationCredentialScalarFieldEnum)[keyof typeof IntegrationCredentialScalarFieldEnum]


  export const MetricScalarFieldEnum: {
    id: 'id',
    name: 'name',
    source: 'source',
    value: 'value',
    unit: 'unit',
    dimension: 'dimension',
    campaignId: 'campaignId',
    projectId: 'projectId',
    timestamp: 'timestamp',
    metadata: 'metadata'
  };

  export type MetricScalarFieldEnum = (typeof MetricScalarFieldEnum)[keyof typeof MetricScalarFieldEnum]


  export const PersonalizationProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    behaviorCluster: 'behaviorCluster',
    interestAffinity: 'interestAffinity',
    engagementScore: 'engagementScore',
    contentPreferences: 'contentPreferences',
    activeHours: 'activeHours',
    devicePreference: 'devicePreference',
    clickPatterns: 'clickPatterns',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PersonalizationProfileScalarFieldEnum = (typeof PersonalizationProfileScalarFieldEnum)[keyof typeof PersonalizationProfileScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    channel: 'channel',
    content: 'content',
    sentiment: 'sentiment',
    sourceType: 'sourceType',
    sourceId: 'sourceId',
    userId: 'userId',
    contentId: 'contentId',
    outreachTaskId: 'outreachTaskId',
    createdAt: 'createdAt'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    name?: StringFilter | string
    password?: StringFilter | string
    role?: EnumRoleFilter | Role
    avatar?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    projects?: ProjectListRelationFilter
    ownedProjects?: ProjectListRelationFilter
    tasks?: TaskListRelationFilter
    createdTasks?: TaskListRelationFilter
    messages?: MessageListRelationFilter
    documents?: DocumentListRelationFilter
    campaigns?: CampaignListRelationFilter
    managedAgents?: AIAgentListRelationFilter
    feedback?: FeedbackListRelationFilter
    personalizationProfile?: XOR<PersonalizationProfileRelationFilter, PersonalizationProfileWhereInput> | null
    outreachResponses?: OutreachTaskListRelationFilter
    createdContent?: GeneratedContentListRelationFilter
    integrationCredentials?: IntegrationCredentialListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    avatar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    ownedProjects?: ProjectOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    createdTasks?: TaskOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
    managedAgents?: AIAgentOrderByRelationAggregateInput
    feedback?: FeedbackOrderByRelationAggregateInput
    personalizationProfile?: PersonalizationProfileOrderByWithRelationInput
    outreachResponses?: OutreachTaskOrderByRelationAggregateInput
    createdContent?: GeneratedContentOrderByRelationAggregateInput
    integrationCredentials?: IntegrationCredentialOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    avatar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    role?: EnumRoleWithAggregatesFilter | Role
    avatar?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProjectWhereInput = {
    AND?: Enumerable<ProjectWhereInput>
    OR?: Enumerable<ProjectWhereInput>
    NOT?: Enumerable<ProjectWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    ownerId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    members?: UserListRelationFilter
    tasks?: TaskListRelationFilter
    messages?: MessageListRelationFilter
    documents?: DocumentListRelationFilter
    campaigns?: CampaignListRelationFilter
    aiAgents?: AIAgentListRelationFilter
    metrics?: MetricListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    members?: UserOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
    aiAgents?: AIAgentOrderByRelationAggregateInput
    metrics?: MetricOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = {
    id?: string
  }

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    ownerId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TaskWhereInput = {
    AND?: Enumerable<TaskWhereInput>
    OR?: Enumerable<TaskWhereInput>
    NOT?: Enumerable<TaskWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    status?: EnumTaskStatusFilter | TaskStatus
    priority?: EnumPriorityFilter | Priority
    dueDate?: DateTimeNullableFilter | Date | string | null
    projectId?: StringFilter | string
    assigneeId?: StringNullableFilter | string | null
    creatorId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    assignee?: XOR<UserRelationFilter, UserWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    projectId?: SortOrder
    assigneeId?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    assignee?: UserOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = {
    id?: string
  }

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    projectId?: SortOrder
    assigneeId?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TaskScalarWhereWithAggregatesInput>
    OR?: Enumerable<TaskScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TaskScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    status?: EnumTaskStatusWithAggregatesFilter | TaskStatus
    priority?: EnumPriorityWithAggregatesFilter | Priority
    dueDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    projectId?: StringWithAggregatesFilter | string
    assigneeId?: StringNullableWithAggregatesFilter | string | null
    creatorId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MessageWhereInput = {
    AND?: Enumerable<MessageWhereInput>
    OR?: Enumerable<MessageWhereInput>
    NOT?: Enumerable<MessageWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    projectId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = {
    id?: string
  }

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MessageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    projectId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DocumentWhereInput = {
    AND?: Enumerable<DocumentWhereInput>
    OR?: Enumerable<DocumentWhereInput>
    NOT?: Enumerable<DocumentWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    fileUrl?: StringFilter | string
    fileType?: StringFilter | string
    fileSize?: IntFilter | number
    projectId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = {
    id?: string
  }

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    fileUrl?: StringWithAggregatesFilter | string
    fileType?: StringWithAggregatesFilter | string
    fileSize?: IntWithAggregatesFilter | number
    projectId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AIAgentWhereInput = {
    AND?: Enumerable<AIAgentWhereInput>
    OR?: Enumerable<AIAgentWhereInput>
    NOT?: Enumerable<AIAgentWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    agentType?: EnumAgentTypeFilter | AgentType
    configuration?: JsonFilter
    lastRunAt?: DateTimeNullableFilter | Date | string | null
    nextRunAt?: DateTimeNullableFilter | Date | string | null
    scheduleExpression?: StringNullableFilter | string | null
    scheduleEnabled?: BoolFilter | boolean
    status?: EnumAgentStatusFilter | AgentStatus
    projectId?: StringFilter | string
    managerId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    manager?: XOR<UserRelationFilter, UserWhereInput>
    generatedContent?: GeneratedContentListRelationFilter
    campaigns?: CampaignListRelationFilter
    trendSignals?: TrendSignalListRelationFilter
    executionSessions?: AgentExecutionSessionListRelationFilter
  }

  export type AIAgentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    agentType?: SortOrder
    configuration?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    scheduleExpression?: SortOrderInput | SortOrder
    scheduleEnabled?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    generatedContent?: GeneratedContentOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
    trendSignals?: TrendSignalOrderByRelationAggregateInput
    executionSessions?: AgentExecutionSessionOrderByRelationAggregateInput
  }

  export type AIAgentWhereUniqueInput = {
    id?: string
  }

  export type AIAgentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    agentType?: SortOrder
    configuration?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    scheduleExpression?: SortOrderInput | SortOrder
    scheduleEnabled?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIAgentCountOrderByAggregateInput
    _max?: AIAgentMaxOrderByAggregateInput
    _min?: AIAgentMinOrderByAggregateInput
  }

  export type AIAgentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AIAgentScalarWhereWithAggregatesInput>
    OR?: Enumerable<AIAgentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AIAgentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    agentType?: EnumAgentTypeWithAggregatesFilter | AgentType
    configuration?: JsonWithAggregatesFilter
    lastRunAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    nextRunAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    scheduleExpression?: StringNullableWithAggregatesFilter | string | null
    scheduleEnabled?: BoolWithAggregatesFilter | boolean
    status?: EnumAgentStatusWithAggregatesFilter | AgentStatus
    projectId?: StringWithAggregatesFilter | string
    managerId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AgentExecutionSessionWhereInput = {
    AND?: Enumerable<AgentExecutionSessionWhereInput>
    OR?: Enumerable<AgentExecutionSessionWhereInput>
    NOT?: Enumerable<AgentExecutionSessionWhereInput>
    id?: StringFilter | string
    agentId?: StringFilter | string
    startedAt?: DateTimeFilter | Date | string
    completedAt?: DateTimeNullableFilter | Date | string | null
    success?: BoolNullableFilter | boolean | null
    duration?: IntNullableFilter | number | null
    outputSummary?: StringNullableFilter | string | null
    logs?: JsonNullableFilter
    context?: JsonNullableFilter
    metrics?: JsonNullableFilter
    errorMessage?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    agent?: XOR<AIAgentRelationFilter, AIAgentWhereInput>
  }

  export type AgentExecutionSessionOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    success?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    outputSummary?: SortOrderInput | SortOrder
    logs?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    agent?: AIAgentOrderByWithRelationInput
  }

  export type AgentExecutionSessionWhereUniqueInput = {
    id?: string
  }

  export type AgentExecutionSessionOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    success?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    outputSummary?: SortOrderInput | SortOrder
    logs?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AgentExecutionSessionCountOrderByAggregateInput
    _avg?: AgentExecutionSessionAvgOrderByAggregateInput
    _max?: AgentExecutionSessionMaxOrderByAggregateInput
    _min?: AgentExecutionSessionMinOrderByAggregateInput
    _sum?: AgentExecutionSessionSumOrderByAggregateInput
  }

  export type AgentExecutionSessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AgentExecutionSessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<AgentExecutionSessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AgentExecutionSessionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    agentId?: StringWithAggregatesFilter | string
    startedAt?: DateTimeWithAggregatesFilter | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    success?: BoolNullableWithAggregatesFilter | boolean | null
    duration?: IntNullableWithAggregatesFilter | number | null
    outputSummary?: StringNullableWithAggregatesFilter | string | null
    logs?: JsonNullableWithAggregatesFilter
    context?: JsonNullableWithAggregatesFilter
    metrics?: JsonNullableWithAggregatesFilter
    errorMessage?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CampaignWhereInput = {
    AND?: Enumerable<CampaignWhereInput>
    OR?: Enumerable<CampaignWhereInput>
    NOT?: Enumerable<CampaignWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    status?: EnumCampaignStatusFilter | CampaignStatus
    campaignType?: EnumCampaignTypeFilter | CampaignType
    goals?: JsonFilter
    targeting?: JsonFilter
    budget?: FloatNullableFilter | number | null
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    ownerId?: StringFilter | string
    projectId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    agents?: AIAgentListRelationFilter
    generatedContent?: GeneratedContentListRelationFilter
    outreachTasks?: OutreachTaskListRelationFilter
    metrics?: MetricListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    campaignType?: SortOrder
    goals?: SortOrder
    targeting?: SortOrder
    budget?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    agents?: AIAgentOrderByRelationAggregateInput
    generatedContent?: GeneratedContentOrderByRelationAggregateInput
    outreachTasks?: OutreachTaskOrderByRelationAggregateInput
    metrics?: MetricOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = {
    id?: string
  }

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    campaignType?: SortOrder
    goals?: SortOrder
    targeting?: SortOrder
    budget?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    status?: EnumCampaignStatusWithAggregatesFilter | CampaignStatus
    campaignType?: EnumCampaignTypeWithAggregatesFilter | CampaignType
    goals?: JsonWithAggregatesFilter
    targeting?: JsonWithAggregatesFilter
    budget?: FloatNullableWithAggregatesFilter | number | null
    startDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ownerId?: StringWithAggregatesFilter | string
    projectId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type GeneratedContentWhereInput = {
    AND?: Enumerable<GeneratedContentWhereInput>
    OR?: Enumerable<GeneratedContentWhereInput>
    NOT?: Enumerable<GeneratedContentWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    content?: StringFilter | string
    contentType?: EnumContentTypeFilter | ContentType
    platform?: EnumPlatformNullableFilter | Platform | null
    status?: EnumContentStatusFilter | ContentStatus
    metadata?: JsonNullableFilter
    agentId?: StringFilter | string
    campaignId?: StringNullableFilter | string | null
    creatorId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    agent?: XOR<AIAgentRelationFilter, AIAgentWhereInput>
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput> | null
    feedback?: FeedbackListRelationFilter
  }

  export type GeneratedContentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    platform?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    agentId?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    creatorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AIAgentOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    feedback?: FeedbackOrderByRelationAggregateInput
  }

  export type GeneratedContentWhereUniqueInput = {
    id?: string
  }

  export type GeneratedContentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    platform?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    agentId?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    creatorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GeneratedContentCountOrderByAggregateInput
    _max?: GeneratedContentMaxOrderByAggregateInput
    _min?: GeneratedContentMinOrderByAggregateInput
  }

  export type GeneratedContentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GeneratedContentScalarWhereWithAggregatesInput>
    OR?: Enumerable<GeneratedContentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GeneratedContentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    contentType?: EnumContentTypeWithAggregatesFilter | ContentType
    platform?: EnumPlatformNullableWithAggregatesFilter | Platform | null
    status?: EnumContentStatusWithAggregatesFilter | ContentStatus
    metadata?: JsonNullableWithAggregatesFilter
    agentId?: StringWithAggregatesFilter | string
    campaignId?: StringNullableWithAggregatesFilter | string | null
    creatorId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OutreachTaskWhereInput = {
    AND?: Enumerable<OutreachTaskWhereInput>
    OR?: Enumerable<OutreachTaskWhereInput>
    NOT?: Enumerable<OutreachTaskWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    outreachType?: EnumOutreachTypeFilter | OutreachType
    status?: EnumOutreachStatusFilter | OutreachStatus
    leadInfo?: JsonFilter
    contactMethod?: EnumContactMethodFilter | ContactMethod
    aiResponse?: StringNullableFilter | string | null
    responseHandlerId?: StringNullableFilter | string | null
    campaignId?: StringFilter | string
    scheduledAt?: DateTimeNullableFilter | Date | string | null
    completedAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    responseHandler?: XOR<UserRelationFilter, UserWhereInput> | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    feedback?: FeedbackListRelationFilter
  }

  export type OutreachTaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    outreachType?: SortOrder
    status?: SortOrder
    leadInfo?: SortOrder
    contactMethod?: SortOrder
    aiResponse?: SortOrderInput | SortOrder
    responseHandlerId?: SortOrderInput | SortOrder
    campaignId?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    responseHandler?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
    feedback?: FeedbackOrderByRelationAggregateInput
  }

  export type OutreachTaskWhereUniqueInput = {
    id?: string
  }

  export type OutreachTaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    outreachType?: SortOrder
    status?: SortOrder
    leadInfo?: SortOrder
    contactMethod?: SortOrder
    aiResponse?: SortOrderInput | SortOrder
    responseHandlerId?: SortOrderInput | SortOrder
    campaignId?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OutreachTaskCountOrderByAggregateInput
    _max?: OutreachTaskMaxOrderByAggregateInput
    _min?: OutreachTaskMinOrderByAggregateInput
  }

  export type OutreachTaskScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OutreachTaskScalarWhereWithAggregatesInput>
    OR?: Enumerable<OutreachTaskScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OutreachTaskScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    outreachType?: EnumOutreachTypeWithAggregatesFilter | OutreachType
    status?: EnumOutreachStatusWithAggregatesFilter | OutreachStatus
    leadInfo?: JsonWithAggregatesFilter
    contactMethod?: EnumContactMethodWithAggregatesFilter | ContactMethod
    aiResponse?: StringNullableWithAggregatesFilter | string | null
    responseHandlerId?: StringNullableWithAggregatesFilter | string | null
    campaignId?: StringWithAggregatesFilter | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TrendSignalWhereInput = {
    AND?: Enumerable<TrendSignalWhereInput>
    OR?: Enumerable<TrendSignalWhereInput>
    NOT?: Enumerable<TrendSignalWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringFilter | string
    source?: StringFilter | string
    signalType?: EnumSignalTypeFilter | SignalType
    confidence?: FloatFilter | number
    rawData?: JsonNullableFilter
    impact?: EnumTrendImpactFilter | TrendImpact
    agentId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    agent?: XOR<AIAgentRelationFilter, AIAgentWhereInput>
  }

  export type TrendSignalOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    source?: SortOrder
    signalType?: SortOrder
    confidence?: SortOrder
    rawData?: SortOrderInput | SortOrder
    impact?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AIAgentOrderByWithRelationInput
  }

  export type TrendSignalWhereUniqueInput = {
    id?: string
  }

  export type TrendSignalOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    source?: SortOrder
    signalType?: SortOrder
    confidence?: SortOrder
    rawData?: SortOrderInput | SortOrder
    impact?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrendSignalCountOrderByAggregateInput
    _avg?: TrendSignalAvgOrderByAggregateInput
    _max?: TrendSignalMaxOrderByAggregateInput
    _min?: TrendSignalMinOrderByAggregateInput
    _sum?: TrendSignalSumOrderByAggregateInput
  }

  export type TrendSignalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TrendSignalScalarWhereWithAggregatesInput>
    OR?: Enumerable<TrendSignalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TrendSignalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    source?: StringWithAggregatesFilter | string
    signalType?: EnumSignalTypeWithAggregatesFilter | SignalType
    confidence?: FloatWithAggregatesFilter | number
    rawData?: JsonNullableWithAggregatesFilter
    impact?: EnumTrendImpactWithAggregatesFilter | TrendImpact
    agentId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntegrationCredentialWhereInput = {
    AND?: Enumerable<IntegrationCredentialWhereInput>
    OR?: Enumerable<IntegrationCredentialWhereInput>
    NOT?: Enumerable<IntegrationCredentialWhereInput>
    id?: StringFilter | string
    platform?: StringFilter | string
    accountIdentifier?: StringNullableFilter | string | null
    authToken?: StringFilter | string
    refreshToken?: StringNullableFilter | string | null
    tokenType?: StringNullableFilter | string | null
    expiry?: DateTimeNullableFilter | Date | string | null
    scopes?: StringNullableListFilter
    metadata?: JsonNullableFilter
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type IntegrationCredentialOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    accountIdentifier?: SortOrderInput | SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenType?: SortOrderInput | SortOrder
    expiry?: SortOrderInput | SortOrder
    scopes?: SortOrder
    metadata?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type IntegrationCredentialWhereUniqueInput = {
    id?: string
    userId_platform_accountIdentifier?: IntegrationCredentialUserIdPlatformAccountIdentifierCompoundUniqueInput
  }

  export type IntegrationCredentialOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    accountIdentifier?: SortOrderInput | SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenType?: SortOrderInput | SortOrder
    expiry?: SortOrderInput | SortOrder
    scopes?: SortOrder
    metadata?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegrationCredentialCountOrderByAggregateInput
    _max?: IntegrationCredentialMaxOrderByAggregateInput
    _min?: IntegrationCredentialMinOrderByAggregateInput
  }

  export type IntegrationCredentialScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntegrationCredentialScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntegrationCredentialScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntegrationCredentialScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    platform?: StringWithAggregatesFilter | string
    accountIdentifier?: StringNullableWithAggregatesFilter | string | null
    authToken?: StringWithAggregatesFilter | string
    refreshToken?: StringNullableWithAggregatesFilter | string | null
    tokenType?: StringNullableWithAggregatesFilter | string | null
    expiry?: DateTimeNullableWithAggregatesFilter | Date | string | null
    scopes?: StringNullableListFilter
    metadata?: JsonNullableWithAggregatesFilter
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MetricWhereInput = {
    AND?: Enumerable<MetricWhereInput>
    OR?: Enumerable<MetricWhereInput>
    NOT?: Enumerable<MetricWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    source?: StringFilter | string
    value?: FloatFilter | number
    unit?: StringNullableFilter | string | null
    dimension?: StringNullableFilter | string | null
    campaignId?: StringNullableFilter | string | null
    projectId?: StringNullableFilter | string | null
    timestamp?: DateTimeFilter | Date | string
    metadata?: JsonNullableFilter
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput> | null
  }

  export type MetricOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    source?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    dimension?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    campaign?: CampaignOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type MetricWhereUniqueInput = {
    id?: string
  }

  export type MetricOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    source?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    dimension?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MetricCountOrderByAggregateInput
    _avg?: MetricAvgOrderByAggregateInput
    _max?: MetricMaxOrderByAggregateInput
    _min?: MetricMinOrderByAggregateInput
    _sum?: MetricSumOrderByAggregateInput
  }

  export type MetricScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MetricScalarWhereWithAggregatesInput>
    OR?: Enumerable<MetricScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MetricScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    source?: StringWithAggregatesFilter | string
    value?: FloatWithAggregatesFilter | number
    unit?: StringNullableWithAggregatesFilter | string | null
    dimension?: StringNullableWithAggregatesFilter | string | null
    campaignId?: StringNullableWithAggregatesFilter | string | null
    projectId?: StringNullableWithAggregatesFilter | string | null
    timestamp?: DateTimeWithAggregatesFilter | Date | string
    metadata?: JsonNullableWithAggregatesFilter
  }

  export type PersonalizationProfileWhereInput = {
    AND?: Enumerable<PersonalizationProfileWhereInput>
    OR?: Enumerable<PersonalizationProfileWhereInput>
    NOT?: Enumerable<PersonalizationProfileWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    behaviorCluster?: StringFilter | string
    interestAffinity?: JsonFilter
    engagementScore?: FloatFilter | number
    contentPreferences?: JsonFilter
    activeHours?: JsonNullableFilter
    devicePreference?: StringNullableFilter | string | null
    clickPatterns?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PersonalizationProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    behaviorCluster?: SortOrder
    interestAffinity?: SortOrder
    engagementScore?: SortOrder
    contentPreferences?: SortOrder
    activeHours?: SortOrderInput | SortOrder
    devicePreference?: SortOrderInput | SortOrder
    clickPatterns?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PersonalizationProfileWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type PersonalizationProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    behaviorCluster?: SortOrder
    interestAffinity?: SortOrder
    engagementScore?: SortOrder
    contentPreferences?: SortOrder
    activeHours?: SortOrderInput | SortOrder
    devicePreference?: SortOrderInput | SortOrder
    clickPatterns?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PersonalizationProfileCountOrderByAggregateInput
    _avg?: PersonalizationProfileAvgOrderByAggregateInput
    _max?: PersonalizationProfileMaxOrderByAggregateInput
    _min?: PersonalizationProfileMinOrderByAggregateInput
    _sum?: PersonalizationProfileSumOrderByAggregateInput
  }

  export type PersonalizationProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PersonalizationProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<PersonalizationProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PersonalizationProfileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    behaviorCluster?: StringWithAggregatesFilter | string
    interestAffinity?: JsonWithAggregatesFilter
    engagementScore?: FloatWithAggregatesFilter | number
    contentPreferences?: JsonWithAggregatesFilter
    activeHours?: JsonNullableWithAggregatesFilter
    devicePreference?: StringNullableWithAggregatesFilter | string | null
    clickPatterns?: JsonNullableWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FeedbackWhereInput = {
    AND?: Enumerable<FeedbackWhereInput>
    OR?: Enumerable<FeedbackWhereInput>
    NOT?: Enumerable<FeedbackWhereInput>
    id?: StringFilter | string
    channel?: EnumFeedbackChannelFilter | FeedbackChannel
    content?: StringFilter | string
    sentiment?: EnumSentimentFilter | Sentiment
    sourceType?: EnumFeedbackSourceFilter | FeedbackSource
    sourceId?: StringFilter | string
    userId?: StringFilter | string
    contentId?: StringNullableFilter | string | null
    outreachTaskId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    content_rel?: XOR<GeneratedContentRelationFilter, GeneratedContentWhereInput> | null
    outreachTask?: XOR<OutreachTaskRelationFilter, OutreachTaskWhereInput> | null
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    channel?: SortOrder
    content?: SortOrder
    sentiment?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    userId?: SortOrder
    contentId?: SortOrderInput | SortOrder
    outreachTaskId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    content_rel?: GeneratedContentOrderByWithRelationInput
    outreachTask?: OutreachTaskOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = {
    id?: string
  }

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    channel?: SortOrder
    content?: SortOrder
    sentiment?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    userId?: SortOrder
    contentId?: SortOrderInput | SortOrder
    outreachTaskId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FeedbackScalarWhereWithAggregatesInput>
    OR?: Enumerable<FeedbackScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FeedbackScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    channel?: EnumFeedbackChannelWithAggregatesFilter | FeedbackChannel
    content?: StringWithAggregatesFilter | string
    sentiment?: EnumSentimentWithAggregatesFilter | Sentiment
    sourceType?: EnumFeedbackSourceWithAggregatesFilter | FeedbackSource
    sourceId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    contentId?: StringNullableWithAggregatesFilter | string | null
    outreachTaskId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    messages?: MessageCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentCreateNestedManyWithoutManagerInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentUncheckedCreateNestedManyWithoutManagerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUncheckedUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: UserCreateNestedManyWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    campaigns?: CampaignCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentCreateNestedManyWithoutProjectInput
    metrics?: MetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutProjectsInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutProjectInput
    metrics?: MetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: UserUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUpdateManyWithoutProjectNestedInput
    metrics?: MetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutProjectNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: TaskStatus
    priority?: Priority
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    assignee?: UserCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutCreatedTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: TaskStatus
    priority?: Priority
    dueDate?: Date | string | null
    projectId: string
    assigneeId?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    assignee?: UserUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: TaskStatus
    priority?: Priority
    dueDate?: Date | string | null
    projectId: string
    assigneeId?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content: string
    projectId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    content: string
    projectId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDocumentsInput
    user: UserCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    projectId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDocumentsNestedInput
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    projectId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentCreateInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAiAgentsInput
    manager: UserCreateNestedOneWithoutManagedAgentsInput
    generatedContent?: GeneratedContentCreateNestedManyWithoutAgentInput
    campaigns?: CampaignCreateNestedManyWithoutAgentsInput
    trendSignals?: TrendSignalCreateNestedManyWithoutAgentInput
    executionSessions?: AgentExecutionSessionCreateNestedManyWithoutAgentInput
  }

  export type AIAgentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    projectId: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedContent?: GeneratedContentUncheckedCreateNestedManyWithoutAgentInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutAgentsInput
    trendSignals?: TrendSignalUncheckedCreateNestedManyWithoutAgentInput
    executionSessions?: AgentExecutionSessionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AIAgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAiAgentsNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedAgentsNestedInput
    generatedContent?: GeneratedContentUpdateManyWithoutAgentNestedInput
    campaigns?: CampaignUpdateManyWithoutAgentsNestedInput
    trendSignals?: TrendSignalUpdateManyWithoutAgentNestedInput
    executionSessions?: AgentExecutionSessionUpdateManyWithoutAgentNestedInput
  }

  export type AIAgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    projectId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedContent?: GeneratedContentUncheckedUpdateManyWithoutAgentNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutAgentsNestedInput
    trendSignals?: TrendSignalUncheckedUpdateManyWithoutAgentNestedInput
    executionSessions?: AgentExecutionSessionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AIAgentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    projectId: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIAgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    projectId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentExecutionSessionCreateInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    success?: boolean | null
    duration?: number | null
    outputSummary?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    createdAt?: Date | string
    agent: AIAgentCreateNestedOneWithoutExecutionSessionsInput
  }

  export type AgentExecutionSessionUncheckedCreateInput = {
    id?: string
    agentId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    success?: boolean | null
    duration?: number | null
    outputSummary?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AgentExecutionSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AIAgentUpdateOneRequiredWithoutExecutionSessionsNestedInput
  }

  export type AgentExecutionSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentExecutionSessionCreateManyInput = {
    id?: string
    agentId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    success?: boolean | null
    duration?: number | null
    outputSummary?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AgentExecutionSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentExecutionSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutCampaignsInput
    project: ProjectCreateNestedOneWithoutCampaignsInput
    agents?: AIAgentCreateNestedManyWithoutCampaignsInput
    generatedContent?: GeneratedContentCreateNestedManyWithoutCampaignInput
    outreachTasks?: OutreachTaskCreateNestedManyWithoutCampaignInput
    metrics?: MetricCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    ownerId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AIAgentUncheckedCreateNestedManyWithoutCampaignsInput
    generatedContent?: GeneratedContentUncheckedCreateNestedManyWithoutCampaignInput
    outreachTasks?: OutreachTaskUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: MetricUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    project?: ProjectUpdateOneRequiredWithoutCampaignsNestedInput
    agents?: AIAgentUpdateManyWithoutCampaignsNestedInput
    generatedContent?: GeneratedContentUpdateManyWithoutCampaignNestedInput
    outreachTasks?: OutreachTaskUpdateManyWithoutCampaignNestedInput
    metrics?: MetricUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AIAgentUncheckedUpdateManyWithoutCampaignsNestedInput
    generatedContent?: GeneratedContentUncheckedUpdateManyWithoutCampaignNestedInput
    outreachTasks?: OutreachTaskUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    ownerId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedContentCreateInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AIAgentCreateNestedOneWithoutGeneratedContentInput
    campaign?: CampaignCreateNestedOneWithoutGeneratedContentInput
    creator?: UserCreateNestedOneWithoutCreatedContentInput
    feedback?: FeedbackCreateNestedManyWithoutContent_relInput
  }

  export type GeneratedContentUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    agentId: string
    campaignId?: string | null
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feedback?: FeedbackUncheckedCreateNestedManyWithoutContent_relInput
  }

  export type GeneratedContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AIAgentUpdateOneRequiredWithoutGeneratedContentNestedInput
    campaign?: CampaignUpdateOneWithoutGeneratedContentNestedInput
    creator?: UserUpdateOneWithoutCreatedContentNestedInput
    feedback?: FeedbackUpdateManyWithoutContent_relNestedInput
  }

  export type GeneratedContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    agentId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUncheckedUpdateManyWithoutContent_relNestedInput
  }

  export type GeneratedContentCreateManyInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    agentId: string
    campaignId?: string | null
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GeneratedContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    agentId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutreachTaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    outreachType: OutreachType
    status?: OutreachStatus
    leadInfo: JsonNullValueInput | InputJsonValue
    contactMethod: ContactMethod
    aiResponse?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responseHandler?: UserCreateNestedOneWithoutOutreachResponsesInput
    campaign: CampaignCreateNestedOneWithoutOutreachTasksInput
    feedback?: FeedbackCreateNestedManyWithoutOutreachTaskInput
  }

  export type OutreachTaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    outreachType: OutreachType
    status?: OutreachStatus
    leadInfo: JsonNullValueInput | InputJsonValue
    contactMethod: ContactMethod
    aiResponse?: string | null
    responseHandlerId?: string | null
    campaignId: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feedback?: FeedbackUncheckedCreateNestedManyWithoutOutreachTaskInput
  }

  export type OutreachTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    outreachType?: EnumOutreachTypeFieldUpdateOperationsInput | OutreachType
    status?: EnumOutreachStatusFieldUpdateOperationsInput | OutreachStatus
    leadInfo?: JsonNullValueInput | InputJsonValue
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseHandler?: UserUpdateOneWithoutOutreachResponsesNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutOutreachTasksNestedInput
    feedback?: FeedbackUpdateManyWithoutOutreachTaskNestedInput
  }

  export type OutreachTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    outreachType?: EnumOutreachTypeFieldUpdateOperationsInput | OutreachType
    status?: EnumOutreachStatusFieldUpdateOperationsInput | OutreachStatus
    leadInfo?: JsonNullValueInput | InputJsonValue
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    responseHandlerId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUncheckedUpdateManyWithoutOutreachTaskNestedInput
  }

  export type OutreachTaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    outreachType: OutreachType
    status?: OutreachStatus
    leadInfo: JsonNullValueInput | InputJsonValue
    contactMethod: ContactMethod
    aiResponse?: string | null
    responseHandlerId?: string | null
    campaignId: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutreachTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    outreachType?: EnumOutreachTypeFieldUpdateOperationsInput | OutreachType
    status?: EnumOutreachStatusFieldUpdateOperationsInput | OutreachStatus
    leadInfo?: JsonNullValueInput | InputJsonValue
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutreachTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    outreachType?: EnumOutreachTypeFieldUpdateOperationsInput | OutreachType
    status?: EnumOutreachStatusFieldUpdateOperationsInput | OutreachStatus
    leadInfo?: JsonNullValueInput | InputJsonValue
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    responseHandlerId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrendSignalCreateInput = {
    id?: string
    title: string
    description: string
    source: string
    signalType: SignalType
    confidence: number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    impact?: TrendImpact
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AIAgentCreateNestedOneWithoutTrendSignalsInput
  }

  export type TrendSignalUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    source: string
    signalType: SignalType
    confidence: number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    impact?: TrendImpact
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrendSignalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSignalTypeFieldUpdateOperationsInput | SignalType
    confidence?: FloatFieldUpdateOperationsInput | number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    impact?: EnumTrendImpactFieldUpdateOperationsInput | TrendImpact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AIAgentUpdateOneRequiredWithoutTrendSignalsNestedInput
  }

  export type TrendSignalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSignalTypeFieldUpdateOperationsInput | SignalType
    confidence?: FloatFieldUpdateOperationsInput | number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    impact?: EnumTrendImpactFieldUpdateOperationsInput | TrendImpact
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrendSignalCreateManyInput = {
    id?: string
    title: string
    description: string
    source: string
    signalType: SignalType
    confidence: number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    impact?: TrendImpact
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrendSignalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSignalTypeFieldUpdateOperationsInput | SignalType
    confidence?: FloatFieldUpdateOperationsInput | number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    impact?: EnumTrendImpactFieldUpdateOperationsInput | TrendImpact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrendSignalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSignalTypeFieldUpdateOperationsInput | SignalType
    confidence?: FloatFieldUpdateOperationsInput | number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    impact?: EnumTrendImpactFieldUpdateOperationsInput | TrendImpact
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCredentialCreateInput = {
    id?: string
    platform: string
    accountIdentifier?: string | null
    authToken: string
    refreshToken?: string | null
    tokenType?: string | null
    expiry?: Date | string | null
    scopes?: IntegrationCredentialCreatescopesInput | Enumerable<string>
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIntegrationCredentialsInput
  }

  export type IntegrationCredentialUncheckedCreateInput = {
    id?: string
    platform: string
    accountIdentifier?: string | null
    authToken: string
    refreshToken?: string | null
    tokenType?: string | null
    expiry?: Date | string | null
    scopes?: IntegrationCredentialCreatescopesInput | Enumerable<string>
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    accountIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scopes?: IntegrationCredentialUpdatescopesInput | Enumerable<string>
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIntegrationCredentialsNestedInput
  }

  export type IntegrationCredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    accountIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scopes?: IntegrationCredentialUpdatescopesInput | Enumerable<string>
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCredentialCreateManyInput = {
    id?: string
    platform: string
    accountIdentifier?: string | null
    authToken: string
    refreshToken?: string | null
    tokenType?: string | null
    expiry?: Date | string | null
    scopes?: IntegrationCredentialCreatescopesInput | Enumerable<string>
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    accountIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scopes?: IntegrationCredentialUpdatescopesInput | Enumerable<string>
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    accountIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scopes?: IntegrationCredentialUpdatescopesInput | Enumerable<string>
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricCreateInput = {
    id?: string
    name: string
    source: string
    value: number
    unit?: string | null
    dimension?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    campaign?: CampaignCreateNestedOneWithoutMetricsInput
    project?: ProjectCreateNestedOneWithoutMetricsInput
  }

  export type MetricUncheckedCreateInput = {
    id?: string
    name: string
    source: string
    value: number
    unit?: string | null
    dimension?: string | null
    campaignId?: string | null
    projectId?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dimension?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    campaign?: CampaignUpdateOneWithoutMetricsNestedInput
    project?: ProjectUpdateOneWithoutMetricsNestedInput
  }

  export type MetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dimension?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricCreateManyInput = {
    id?: string
    name: string
    source: string
    value: number
    unit?: string | null
    dimension?: string | null
    campaignId?: string | null
    projectId?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dimension?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dimension?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PersonalizationProfileCreateInput = {
    id?: string
    behaviorCluster: string
    interestAffinity: JsonNullValueInput | InputJsonValue
    engagementScore: number
    contentPreferences: JsonNullValueInput | InputJsonValue
    activeHours?: NullableJsonNullValueInput | InputJsonValue
    devicePreference?: string | null
    clickPatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonalizationProfileInput
  }

  export type PersonalizationProfileUncheckedCreateInput = {
    id?: string
    userId: string
    behaviorCluster: string
    interestAffinity: JsonNullValueInput | InputJsonValue
    engagementScore: number
    contentPreferences: JsonNullValueInput | InputJsonValue
    activeHours?: NullableJsonNullValueInput | InputJsonValue
    devicePreference?: string | null
    clickPatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalizationProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    behaviorCluster?: StringFieldUpdateOperationsInput | string
    interestAffinity?: JsonNullValueInput | InputJsonValue
    engagementScore?: FloatFieldUpdateOperationsInput | number
    contentPreferences?: JsonNullValueInput | InputJsonValue
    activeHours?: NullableJsonNullValueInput | InputJsonValue
    devicePreference?: NullableStringFieldUpdateOperationsInput | string | null
    clickPatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonalizationProfileNestedInput
  }

  export type PersonalizationProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    behaviorCluster?: StringFieldUpdateOperationsInput | string
    interestAffinity?: JsonNullValueInput | InputJsonValue
    engagementScore?: FloatFieldUpdateOperationsInput | number
    contentPreferences?: JsonNullValueInput | InputJsonValue
    activeHours?: NullableJsonNullValueInput | InputJsonValue
    devicePreference?: NullableStringFieldUpdateOperationsInput | string | null
    clickPatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalizationProfileCreateManyInput = {
    id?: string
    userId: string
    behaviorCluster: string
    interestAffinity: JsonNullValueInput | InputJsonValue
    engagementScore: number
    contentPreferences: JsonNullValueInput | InputJsonValue
    activeHours?: NullableJsonNullValueInput | InputJsonValue
    devicePreference?: string | null
    clickPatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalizationProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    behaviorCluster?: StringFieldUpdateOperationsInput | string
    interestAffinity?: JsonNullValueInput | InputJsonValue
    engagementScore?: FloatFieldUpdateOperationsInput | number
    contentPreferences?: JsonNullValueInput | InputJsonValue
    activeHours?: NullableJsonNullValueInput | InputJsonValue
    devicePreference?: NullableStringFieldUpdateOperationsInput | string | null
    clickPatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalizationProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    behaviorCluster?: StringFieldUpdateOperationsInput | string
    interestAffinity?: JsonNullValueInput | InputJsonValue
    engagementScore?: FloatFieldUpdateOperationsInput | number
    contentPreferences?: JsonNullValueInput | InputJsonValue
    activeHours?: NullableJsonNullValueInput | InputJsonValue
    devicePreference?: NullableStringFieldUpdateOperationsInput | string | null
    clickPatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateInput = {
    id?: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFeedbackInput
    content_rel?: GeneratedContentCreateNestedOneWithoutFeedbackInput
    outreachTask?: OutreachTaskCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    userId: string
    contentId?: string | null
    outreachTaskId?: string | null
    createdAt?: Date | string
  }

  export type FeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumFeedbackChannelFieldUpdateOperationsInput | FeedbackChannel
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: EnumSentimentFieldUpdateOperationsInput | Sentiment
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | FeedbackSource
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbackNestedInput
    content_rel?: GeneratedContentUpdateOneWithoutFeedbackNestedInput
    outreachTask?: OutreachTaskUpdateOneWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumFeedbackChannelFieldUpdateOperationsInput | FeedbackChannel
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: EnumSentimentFieldUpdateOperationsInput | Sentiment
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | FeedbackSource
    sourceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    outreachTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateManyInput = {
    id?: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    userId: string
    contentId?: string | null
    outreachTaskId?: string | null
    createdAt?: Date | string
  }

  export type FeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumFeedbackChannelFieldUpdateOperationsInput | FeedbackChannel
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: EnumSentimentFieldUpdateOperationsInput | Sentiment
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | FeedbackSource
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumFeedbackChannelFieldUpdateOperationsInput | FeedbackChannel
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: EnumSentimentFieldUpdateOperationsInput | Sentiment
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | FeedbackSource
    sourceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    outreachTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type AIAgentListRelationFilter = {
    every?: AIAgentWhereInput
    some?: AIAgentWhereInput
    none?: AIAgentWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type PersonalizationProfileRelationFilter = {
    is?: PersonalizationProfileWhereInput | null
    isNot?: PersonalizationProfileWhereInput | null
  }

  export type OutreachTaskListRelationFilter = {
    every?: OutreachTaskWhereInput
    some?: OutreachTaskWhereInput
    none?: OutreachTaskWhereInput
  }

  export type GeneratedContentListRelationFilter = {
    every?: GeneratedContentWhereInput
    some?: GeneratedContentWhereInput
    none?: GeneratedContentWhereInput
  }

  export type IntegrationCredentialListRelationFilter = {
    every?: IntegrationCredentialWhereInput
    some?: IntegrationCredentialWhereInput
    none?: IntegrationCredentialWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIAgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutreachTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GeneratedContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationCredentialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type MetricListRelationFilter = {
    every?: MetricWhereInput
    some?: MetricWhereInput
    none?: MetricWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaskStatusFilter = {
    equals?: TaskStatus
    in?: Enumerable<TaskStatus>
    notIn?: Enumerable<TaskStatus>
    not?: NestedEnumTaskStatusFilter | TaskStatus
  }

  export type EnumPriorityFilter = {
    equals?: Priority
    in?: Enumerable<Priority>
    notIn?: Enumerable<Priority>
    not?: NestedEnumPriorityFilter | Priority
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    projectId?: SortOrder
    assigneeId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    projectId?: SortOrder
    assigneeId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    projectId?: SortOrder
    assigneeId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter = {
    equals?: TaskStatus
    in?: Enumerable<TaskStatus>
    notIn?: Enumerable<TaskStatus>
    not?: NestedEnumTaskStatusWithAggregatesFilter | TaskStatus
    _count?: NestedIntFilter
    _min?: NestedEnumTaskStatusFilter
    _max?: NestedEnumTaskStatusFilter
  }

  export type EnumPriorityWithAggregatesFilter = {
    equals?: Priority
    in?: Enumerable<Priority>
    notIn?: Enumerable<Priority>
    not?: NestedEnumPriorityWithAggregatesFilter | Priority
    _count?: NestedIntFilter
    _min?: NestedEnumPriorityFilter
    _max?: NestedEnumPriorityFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type EnumAgentTypeFilter = {
    equals?: AgentType
    in?: Enumerable<AgentType>
    notIn?: Enumerable<AgentType>
    not?: NestedEnumAgentTypeFilter | AgentType
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type EnumAgentStatusFilter = {
    equals?: AgentStatus
    in?: Enumerable<AgentStatus>
    notIn?: Enumerable<AgentStatus>
    not?: NestedEnumAgentStatusFilter | AgentStatus
  }

  export type TrendSignalListRelationFilter = {
    every?: TrendSignalWhereInput
    some?: TrendSignalWhereInput
    none?: TrendSignalWhereInput
  }

  export type AgentExecutionSessionListRelationFilter = {
    every?: AgentExecutionSessionWhereInput
    some?: AgentExecutionSessionWhereInput
    none?: AgentExecutionSessionWhereInput
  }

  export type TrendSignalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentExecutionSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIAgentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    agentType?: SortOrder
    configuration?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    scheduleExpression?: SortOrder
    scheduleEnabled?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIAgentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    agentType?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    scheduleExpression?: SortOrder
    scheduleEnabled?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIAgentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    agentType?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    scheduleExpression?: SortOrder
    scheduleEnabled?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAgentTypeWithAggregatesFilter = {
    equals?: AgentType
    in?: Enumerable<AgentType>
    notIn?: Enumerable<AgentType>
    not?: NestedEnumAgentTypeWithAggregatesFilter | AgentType
    _count?: NestedIntFilter
    _min?: NestedEnumAgentTypeFilter
    _max?: NestedEnumAgentTypeFilter
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type EnumAgentStatusWithAggregatesFilter = {
    equals?: AgentStatus
    in?: Enumerable<AgentStatus>
    notIn?: Enumerable<AgentStatus>
    not?: NestedEnumAgentStatusWithAggregatesFilter | AgentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumAgentStatusFilter
    _max?: NestedEnumAgentStatusFilter
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type AIAgentRelationFilter = {
    is?: AIAgentWhereInput | null
    isNot?: AIAgentWhereInput | null
  }

  export type AgentExecutionSessionCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    success?: SortOrder
    duration?: SortOrder
    outputSummary?: SortOrder
    logs?: SortOrder
    context?: SortOrder
    metrics?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type AgentExecutionSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type AgentExecutionSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    success?: SortOrder
    duration?: SortOrder
    outputSummary?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type AgentExecutionSessionMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    success?: SortOrder
    duration?: SortOrder
    outputSummary?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type AgentExecutionSessionSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type EnumCampaignStatusFilter = {
    equals?: CampaignStatus
    in?: Enumerable<CampaignStatus>
    notIn?: Enumerable<CampaignStatus>
    not?: NestedEnumCampaignStatusFilter | CampaignStatus
  }

  export type EnumCampaignTypeFilter = {
    equals?: CampaignType
    in?: Enumerable<CampaignType>
    notIn?: Enumerable<CampaignType>
    not?: NestedEnumCampaignTypeFilter | CampaignType
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    campaignType?: SortOrder
    goals?: SortOrder
    targeting?: SortOrder
    budget?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    ownerId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    campaignType?: SortOrder
    budget?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    ownerId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    campaignType?: SortOrder
    budget?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    ownerId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type EnumCampaignStatusWithAggregatesFilter = {
    equals?: CampaignStatus
    in?: Enumerable<CampaignStatus>
    notIn?: Enumerable<CampaignStatus>
    not?: NestedEnumCampaignStatusWithAggregatesFilter | CampaignStatus
    _count?: NestedIntFilter
    _min?: NestedEnumCampaignStatusFilter
    _max?: NestedEnumCampaignStatusFilter
  }

  export type EnumCampaignTypeWithAggregatesFilter = {
    equals?: CampaignType
    in?: Enumerable<CampaignType>
    notIn?: Enumerable<CampaignType>
    not?: NestedEnumCampaignTypeWithAggregatesFilter | CampaignType
    _count?: NestedIntFilter
    _min?: NestedEnumCampaignTypeFilter
    _max?: NestedEnumCampaignTypeFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type EnumContentTypeFilter = {
    equals?: ContentType
    in?: Enumerable<ContentType>
    notIn?: Enumerable<ContentType>
    not?: NestedEnumContentTypeFilter | ContentType
  }

  export type EnumPlatformNullableFilter = {
    equals?: Platform | null
    in?: Enumerable<Platform> | null
    notIn?: Enumerable<Platform> | null
    not?: NestedEnumPlatformNullableFilter | Platform | null
  }

  export type EnumContentStatusFilter = {
    equals?: ContentStatus
    in?: Enumerable<ContentStatus>
    notIn?: Enumerable<ContentStatus>
    not?: NestedEnumContentStatusFilter | ContentStatus
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput | null
    isNot?: CampaignWhereInput | null
  }

  export type GeneratedContentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    agentId?: SortOrder
    campaignId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GeneratedContentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    agentId?: SortOrder
    campaignId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GeneratedContentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    platform?: SortOrder
    status?: SortOrder
    agentId?: SortOrder
    campaignId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContentTypeWithAggregatesFilter = {
    equals?: ContentType
    in?: Enumerable<ContentType>
    notIn?: Enumerable<ContentType>
    not?: NestedEnumContentTypeWithAggregatesFilter | ContentType
    _count?: NestedIntFilter
    _min?: NestedEnumContentTypeFilter
    _max?: NestedEnumContentTypeFilter
  }

  export type EnumPlatformNullableWithAggregatesFilter = {
    equals?: Platform | null
    in?: Enumerable<Platform> | null
    notIn?: Enumerable<Platform> | null
    not?: NestedEnumPlatformNullableWithAggregatesFilter | Platform | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumPlatformNullableFilter
    _max?: NestedEnumPlatformNullableFilter
  }

  export type EnumContentStatusWithAggregatesFilter = {
    equals?: ContentStatus
    in?: Enumerable<ContentStatus>
    notIn?: Enumerable<ContentStatus>
    not?: NestedEnumContentStatusWithAggregatesFilter | ContentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumContentStatusFilter
    _max?: NestedEnumContentStatusFilter
  }

  export type EnumOutreachTypeFilter = {
    equals?: OutreachType
    in?: Enumerable<OutreachType>
    notIn?: Enumerable<OutreachType>
    not?: NestedEnumOutreachTypeFilter | OutreachType
  }

  export type EnumOutreachStatusFilter = {
    equals?: OutreachStatus
    in?: Enumerable<OutreachStatus>
    notIn?: Enumerable<OutreachStatus>
    not?: NestedEnumOutreachStatusFilter | OutreachStatus
  }

  export type EnumContactMethodFilter = {
    equals?: ContactMethod
    in?: Enumerable<ContactMethod>
    notIn?: Enumerable<ContactMethod>
    not?: NestedEnumContactMethodFilter | ContactMethod
  }

  export type OutreachTaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    outreachType?: SortOrder
    status?: SortOrder
    leadInfo?: SortOrder
    contactMethod?: SortOrder
    aiResponse?: SortOrder
    responseHandlerId?: SortOrder
    campaignId?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutreachTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    outreachType?: SortOrder
    status?: SortOrder
    contactMethod?: SortOrder
    aiResponse?: SortOrder
    responseHandlerId?: SortOrder
    campaignId?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutreachTaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    outreachType?: SortOrder
    status?: SortOrder
    contactMethod?: SortOrder
    aiResponse?: SortOrder
    responseHandlerId?: SortOrder
    campaignId?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOutreachTypeWithAggregatesFilter = {
    equals?: OutreachType
    in?: Enumerable<OutreachType>
    notIn?: Enumerable<OutreachType>
    not?: NestedEnumOutreachTypeWithAggregatesFilter | OutreachType
    _count?: NestedIntFilter
    _min?: NestedEnumOutreachTypeFilter
    _max?: NestedEnumOutreachTypeFilter
  }

  export type EnumOutreachStatusWithAggregatesFilter = {
    equals?: OutreachStatus
    in?: Enumerable<OutreachStatus>
    notIn?: Enumerable<OutreachStatus>
    not?: NestedEnumOutreachStatusWithAggregatesFilter | OutreachStatus
    _count?: NestedIntFilter
    _min?: NestedEnumOutreachStatusFilter
    _max?: NestedEnumOutreachStatusFilter
  }

  export type EnumContactMethodWithAggregatesFilter = {
    equals?: ContactMethod
    in?: Enumerable<ContactMethod>
    notIn?: Enumerable<ContactMethod>
    not?: NestedEnumContactMethodWithAggregatesFilter | ContactMethod
    _count?: NestedIntFilter
    _min?: NestedEnumContactMethodFilter
    _max?: NestedEnumContactMethodFilter
  }

  export type EnumSignalTypeFilter = {
    equals?: SignalType
    in?: Enumerable<SignalType>
    notIn?: Enumerable<SignalType>
    not?: NestedEnumSignalTypeFilter | SignalType
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type EnumTrendImpactFilter = {
    equals?: TrendImpact
    in?: Enumerable<TrendImpact>
    notIn?: Enumerable<TrendImpact>
    not?: NestedEnumTrendImpactFilter | TrendImpact
  }

  export type TrendSignalCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    source?: SortOrder
    signalType?: SortOrder
    confidence?: SortOrder
    rawData?: SortOrder
    impact?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrendSignalAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type TrendSignalMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    source?: SortOrder
    signalType?: SortOrder
    confidence?: SortOrder
    impact?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrendSignalMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    source?: SortOrder
    signalType?: SortOrder
    confidence?: SortOrder
    impact?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrendSignalSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type EnumSignalTypeWithAggregatesFilter = {
    equals?: SignalType
    in?: Enumerable<SignalType>
    notIn?: Enumerable<SignalType>
    not?: NestedEnumSignalTypeWithAggregatesFilter | SignalType
    _count?: NestedIntFilter
    _min?: NestedEnumSignalTypeFilter
    _max?: NestedEnumSignalTypeFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type EnumTrendImpactWithAggregatesFilter = {
    equals?: TrendImpact
    in?: Enumerable<TrendImpact>
    notIn?: Enumerable<TrendImpact>
    not?: NestedEnumTrendImpactWithAggregatesFilter | TrendImpact
    _count?: NestedIntFilter
    _min?: NestedEnumTrendImpactFilter
    _max?: NestedEnumTrendImpactFilter
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type IntegrationCredentialUserIdPlatformAccountIdentifierCompoundUniqueInput = {
    userId: string
    platform: string
    accountIdentifier: string
  }

  export type IntegrationCredentialCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    accountIdentifier?: SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrder
    tokenType?: SortOrder
    expiry?: SortOrder
    scopes?: SortOrder
    metadata?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationCredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    accountIdentifier?: SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrder
    tokenType?: SortOrder
    expiry?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationCredentialMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    accountIdentifier?: SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrder
    tokenType?: SortOrder
    expiry?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetricCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    source?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    dimension?: SortOrder
    campaignId?: SortOrder
    projectId?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type MetricAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type MetricMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    source?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    dimension?: SortOrder
    campaignId?: SortOrder
    projectId?: SortOrder
    timestamp?: SortOrder
  }

  export type MetricMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    source?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    dimension?: SortOrder
    campaignId?: SortOrder
    projectId?: SortOrder
    timestamp?: SortOrder
  }

  export type MetricSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PersonalizationProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    behaviorCluster?: SortOrder
    interestAffinity?: SortOrder
    engagementScore?: SortOrder
    contentPreferences?: SortOrder
    activeHours?: SortOrder
    devicePreference?: SortOrder
    clickPatterns?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonalizationProfileAvgOrderByAggregateInput = {
    engagementScore?: SortOrder
  }

  export type PersonalizationProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    behaviorCluster?: SortOrder
    engagementScore?: SortOrder
    devicePreference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonalizationProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    behaviorCluster?: SortOrder
    engagementScore?: SortOrder
    devicePreference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonalizationProfileSumOrderByAggregateInput = {
    engagementScore?: SortOrder
  }

  export type EnumFeedbackChannelFilter = {
    equals?: FeedbackChannel
    in?: Enumerable<FeedbackChannel>
    notIn?: Enumerable<FeedbackChannel>
    not?: NestedEnumFeedbackChannelFilter | FeedbackChannel
  }

  export type EnumSentimentFilter = {
    equals?: Sentiment
    in?: Enumerable<Sentiment>
    notIn?: Enumerable<Sentiment>
    not?: NestedEnumSentimentFilter | Sentiment
  }

  export type EnumFeedbackSourceFilter = {
    equals?: FeedbackSource
    in?: Enumerable<FeedbackSource>
    notIn?: Enumerable<FeedbackSource>
    not?: NestedEnumFeedbackSourceFilter | FeedbackSource
  }

  export type GeneratedContentRelationFilter = {
    is?: GeneratedContentWhereInput | null
    isNot?: GeneratedContentWhereInput | null
  }

  export type OutreachTaskRelationFilter = {
    is?: OutreachTaskWhereInput | null
    isNot?: OutreachTaskWhereInput | null
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    channel?: SortOrder
    content?: SortOrder
    sentiment?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    userId?: SortOrder
    contentId?: SortOrder
    outreachTaskId?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    channel?: SortOrder
    content?: SortOrder
    sentiment?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    userId?: SortOrder
    contentId?: SortOrder
    outreachTaskId?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    channel?: SortOrder
    content?: SortOrder
    sentiment?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    userId?: SortOrder
    contentId?: SortOrder
    outreachTaskId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFeedbackChannelWithAggregatesFilter = {
    equals?: FeedbackChannel
    in?: Enumerable<FeedbackChannel>
    notIn?: Enumerable<FeedbackChannel>
    not?: NestedEnumFeedbackChannelWithAggregatesFilter | FeedbackChannel
    _count?: NestedIntFilter
    _min?: NestedEnumFeedbackChannelFilter
    _max?: NestedEnumFeedbackChannelFilter
  }

  export type EnumSentimentWithAggregatesFilter = {
    equals?: Sentiment
    in?: Enumerable<Sentiment>
    notIn?: Enumerable<Sentiment>
    not?: NestedEnumSentimentWithAggregatesFilter | Sentiment
    _count?: NestedIntFilter
    _min?: NestedEnumSentimentFilter
    _max?: NestedEnumSentimentFilter
  }

  export type EnumFeedbackSourceWithAggregatesFilter = {
    equals?: FeedbackSource
    in?: Enumerable<FeedbackSource>
    notIn?: Enumerable<FeedbackSource>
    not?: NestedEnumFeedbackSourceWithAggregatesFilter | FeedbackSource
    _count?: NestedIntFilter
    _min?: NestedEnumFeedbackSourceFilter
    _max?: NestedEnumFeedbackSourceFilter
  }

  export type ProjectCreateNestedManyWithoutMembersInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutMembersInput>, Enumerable<ProjectUncheckedCreateWithoutMembersInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutMembersInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type ProjectCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutOwnerInput>, Enumerable<ProjectUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutOwnerInput>
    createMany?: ProjectCreateManyOwnerInputEnvelope
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type TaskCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<Enumerable<TaskCreateWithoutAssigneeInput>, Enumerable<TaskUncheckedCreateWithoutAssigneeInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutAssigneeInput>
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: Enumerable<TaskWhereUniqueInput>
  }

  export type TaskCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<TaskCreateWithoutCreatorInput>, Enumerable<TaskUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutCreatorInput>
    createMany?: TaskCreateManyCreatorInputEnvelope
    connect?: Enumerable<TaskWhereUniqueInput>
  }

  export type MessageCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<MessageCreateWithoutUserInput>, Enumerable<MessageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutUserInput>
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type DocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutUserInput>, Enumerable<DocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutUserInput>
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type CampaignCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutOwnerInput>, Enumerable<CampaignUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutOwnerInput>
    createMany?: CampaignCreateManyOwnerInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type AIAgentCreateNestedManyWithoutManagerInput = {
    create?: XOR<Enumerable<AIAgentCreateWithoutManagerInput>, Enumerable<AIAgentUncheckedCreateWithoutManagerInput>>
    connectOrCreate?: Enumerable<AIAgentCreateOrConnectWithoutManagerInput>
    createMany?: AIAgentCreateManyManagerInputEnvelope
    connect?: Enumerable<AIAgentWhereUniqueInput>
  }

  export type FeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutUserInput>, Enumerable<FeedbackUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutUserInput>
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: Enumerable<FeedbackWhereUniqueInput>
  }

  export type PersonalizationProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonalizationProfileCreateWithoutUserInput, PersonalizationProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalizationProfileCreateOrConnectWithoutUserInput
    connect?: PersonalizationProfileWhereUniqueInput
  }

  export type OutreachTaskCreateNestedManyWithoutResponseHandlerInput = {
    create?: XOR<Enumerable<OutreachTaskCreateWithoutResponseHandlerInput>, Enumerable<OutreachTaskUncheckedCreateWithoutResponseHandlerInput>>
    connectOrCreate?: Enumerable<OutreachTaskCreateOrConnectWithoutResponseHandlerInput>
    createMany?: OutreachTaskCreateManyResponseHandlerInputEnvelope
    connect?: Enumerable<OutreachTaskWhereUniqueInput>
  }

  export type GeneratedContentCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<GeneratedContentCreateWithoutCreatorInput>, Enumerable<GeneratedContentUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<GeneratedContentCreateOrConnectWithoutCreatorInput>
    createMany?: GeneratedContentCreateManyCreatorInputEnvelope
    connect?: Enumerable<GeneratedContentWhereUniqueInput>
  }

  export type IntegrationCredentialCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<IntegrationCredentialCreateWithoutUserInput>, Enumerable<IntegrationCredentialUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IntegrationCredentialCreateOrConnectWithoutUserInput>
    createMany?: IntegrationCredentialCreateManyUserInputEnvelope
    connect?: Enumerable<IntegrationCredentialWhereUniqueInput>
  }

  export type ProjectUncheckedCreateNestedManyWithoutMembersInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutMembersInput>, Enumerable<ProjectUncheckedCreateWithoutMembersInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutMembersInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type ProjectUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutOwnerInput>, Enumerable<ProjectUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutOwnerInput>
    createMany?: ProjectCreateManyOwnerInputEnvelope
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type TaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<Enumerable<TaskCreateWithoutAssigneeInput>, Enumerable<TaskUncheckedCreateWithoutAssigneeInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutAssigneeInput>
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: Enumerable<TaskWhereUniqueInput>
  }

  export type TaskUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<TaskCreateWithoutCreatorInput>, Enumerable<TaskUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutCreatorInput>
    createMany?: TaskCreateManyCreatorInputEnvelope
    connect?: Enumerable<TaskWhereUniqueInput>
  }

  export type MessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<MessageCreateWithoutUserInput>, Enumerable<MessageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutUserInput>
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutUserInput>, Enumerable<DocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutUserInput>
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type CampaignUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutOwnerInput>, Enumerable<CampaignUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutOwnerInput>
    createMany?: CampaignCreateManyOwnerInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type AIAgentUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<Enumerable<AIAgentCreateWithoutManagerInput>, Enumerable<AIAgentUncheckedCreateWithoutManagerInput>>
    connectOrCreate?: Enumerable<AIAgentCreateOrConnectWithoutManagerInput>
    createMany?: AIAgentCreateManyManagerInputEnvelope
    connect?: Enumerable<AIAgentWhereUniqueInput>
  }

  export type FeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutUserInput>, Enumerable<FeedbackUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutUserInput>
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: Enumerable<FeedbackWhereUniqueInput>
  }

  export type PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonalizationProfileCreateWithoutUserInput, PersonalizationProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalizationProfileCreateOrConnectWithoutUserInput
    connect?: PersonalizationProfileWhereUniqueInput
  }

  export type OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput = {
    create?: XOR<Enumerable<OutreachTaskCreateWithoutResponseHandlerInput>, Enumerable<OutreachTaskUncheckedCreateWithoutResponseHandlerInput>>
    connectOrCreate?: Enumerable<OutreachTaskCreateOrConnectWithoutResponseHandlerInput>
    createMany?: OutreachTaskCreateManyResponseHandlerInputEnvelope
    connect?: Enumerable<OutreachTaskWhereUniqueInput>
  }

  export type GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<GeneratedContentCreateWithoutCreatorInput>, Enumerable<GeneratedContentUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<GeneratedContentCreateOrConnectWithoutCreatorInput>
    createMany?: GeneratedContentCreateManyCreatorInputEnvelope
    connect?: Enumerable<GeneratedContentWhereUniqueInput>
  }

  export type IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<IntegrationCredentialCreateWithoutUserInput>, Enumerable<IntegrationCredentialUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IntegrationCredentialCreateOrConnectWithoutUserInput>
    createMany?: IntegrationCredentialCreateManyUserInputEnvelope
    connect?: Enumerable<IntegrationCredentialWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProjectUpdateManyWithoutMembersNestedInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutMembersInput>, Enumerable<ProjectUncheckedCreateWithoutMembersInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutMembersInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutMembersInput>
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutMembersInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutMembersInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type ProjectUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutOwnerInput>, Enumerable<ProjectUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: ProjectCreateManyOwnerInputEnvelope
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type TaskUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<Enumerable<TaskCreateWithoutAssigneeInput>, Enumerable<TaskUncheckedCreateWithoutAssigneeInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutAssigneeInput>
    upsert?: Enumerable<TaskUpsertWithWhereUniqueWithoutAssigneeInput>
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: Enumerable<TaskWhereUniqueInput>
    disconnect?: Enumerable<TaskWhereUniqueInput>
    delete?: Enumerable<TaskWhereUniqueInput>
    connect?: Enumerable<TaskWhereUniqueInput>
    update?: Enumerable<TaskUpdateWithWhereUniqueWithoutAssigneeInput>
    updateMany?: Enumerable<TaskUpdateManyWithWhereWithoutAssigneeInput>
    deleteMany?: Enumerable<TaskScalarWhereInput>
  }

  export type TaskUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<TaskCreateWithoutCreatorInput>, Enumerable<TaskUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<TaskUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: TaskCreateManyCreatorInputEnvelope
    set?: Enumerable<TaskWhereUniqueInput>
    disconnect?: Enumerable<TaskWhereUniqueInput>
    delete?: Enumerable<TaskWhereUniqueInput>
    connect?: Enumerable<TaskWhereUniqueInput>
    update?: Enumerable<TaskUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<TaskUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<TaskScalarWhereInput>
  }

  export type MessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<MessageCreateWithoutUserInput>, Enumerable<MessageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: MessageCreateManyUserInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type DocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutUserInput>, Enumerable<DocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type CampaignUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutOwnerInput>, Enumerable<CampaignUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: CampaignCreateManyOwnerInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type AIAgentUpdateManyWithoutManagerNestedInput = {
    create?: XOR<Enumerable<AIAgentCreateWithoutManagerInput>, Enumerable<AIAgentUncheckedCreateWithoutManagerInput>>
    connectOrCreate?: Enumerable<AIAgentCreateOrConnectWithoutManagerInput>
    upsert?: Enumerable<AIAgentUpsertWithWhereUniqueWithoutManagerInput>
    createMany?: AIAgentCreateManyManagerInputEnvelope
    set?: Enumerable<AIAgentWhereUniqueInput>
    disconnect?: Enumerable<AIAgentWhereUniqueInput>
    delete?: Enumerable<AIAgentWhereUniqueInput>
    connect?: Enumerable<AIAgentWhereUniqueInput>
    update?: Enumerable<AIAgentUpdateWithWhereUniqueWithoutManagerInput>
    updateMany?: Enumerable<AIAgentUpdateManyWithWhereWithoutManagerInput>
    deleteMany?: Enumerable<AIAgentScalarWhereInput>
  }

  export type FeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutUserInput>, Enumerable<FeedbackUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FeedbackUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: Enumerable<FeedbackWhereUniqueInput>
    disconnect?: Enumerable<FeedbackWhereUniqueInput>
    delete?: Enumerable<FeedbackWhereUniqueInput>
    connect?: Enumerable<FeedbackWhereUniqueInput>
    update?: Enumerable<FeedbackUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FeedbackUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FeedbackScalarWhereInput>
  }

  export type PersonalizationProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonalizationProfileCreateWithoutUserInput, PersonalizationProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalizationProfileCreateOrConnectWithoutUserInput
    upsert?: PersonalizationProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonalizationProfileWhereUniqueInput
    update?: XOR<PersonalizationProfileUpdateWithoutUserInput, PersonalizationProfileUncheckedUpdateWithoutUserInput>
  }

  export type OutreachTaskUpdateManyWithoutResponseHandlerNestedInput = {
    create?: XOR<Enumerable<OutreachTaskCreateWithoutResponseHandlerInput>, Enumerable<OutreachTaskUncheckedCreateWithoutResponseHandlerInput>>
    connectOrCreate?: Enumerable<OutreachTaskCreateOrConnectWithoutResponseHandlerInput>
    upsert?: Enumerable<OutreachTaskUpsertWithWhereUniqueWithoutResponseHandlerInput>
    createMany?: OutreachTaskCreateManyResponseHandlerInputEnvelope
    set?: Enumerable<OutreachTaskWhereUniqueInput>
    disconnect?: Enumerable<OutreachTaskWhereUniqueInput>
    delete?: Enumerable<OutreachTaskWhereUniqueInput>
    connect?: Enumerable<OutreachTaskWhereUniqueInput>
    update?: Enumerable<OutreachTaskUpdateWithWhereUniqueWithoutResponseHandlerInput>
    updateMany?: Enumerable<OutreachTaskUpdateManyWithWhereWithoutResponseHandlerInput>
    deleteMany?: Enumerable<OutreachTaskScalarWhereInput>
  }

  export type GeneratedContentUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<GeneratedContentCreateWithoutCreatorInput>, Enumerable<GeneratedContentUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<GeneratedContentCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<GeneratedContentUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: GeneratedContentCreateManyCreatorInputEnvelope
    set?: Enumerable<GeneratedContentWhereUniqueInput>
    disconnect?: Enumerable<GeneratedContentWhereUniqueInput>
    delete?: Enumerable<GeneratedContentWhereUniqueInput>
    connect?: Enumerable<GeneratedContentWhereUniqueInput>
    update?: Enumerable<GeneratedContentUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<GeneratedContentUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<GeneratedContentScalarWhereInput>
  }

  export type IntegrationCredentialUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<IntegrationCredentialCreateWithoutUserInput>, Enumerable<IntegrationCredentialUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IntegrationCredentialCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<IntegrationCredentialUpsertWithWhereUniqueWithoutUserInput>
    createMany?: IntegrationCredentialCreateManyUserInputEnvelope
    set?: Enumerable<IntegrationCredentialWhereUniqueInput>
    disconnect?: Enumerable<IntegrationCredentialWhereUniqueInput>
    delete?: Enumerable<IntegrationCredentialWhereUniqueInput>
    connect?: Enumerable<IntegrationCredentialWhereUniqueInput>
    update?: Enumerable<IntegrationCredentialUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<IntegrationCredentialUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<IntegrationCredentialScalarWhereInput>
  }

  export type ProjectUncheckedUpdateManyWithoutMembersNestedInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutMembersInput>, Enumerable<ProjectUncheckedCreateWithoutMembersInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutMembersInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutMembersInput>
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutMembersInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutMembersInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type ProjectUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutOwnerInput>, Enumerable<ProjectUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: ProjectCreateManyOwnerInputEnvelope
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<Enumerable<TaskCreateWithoutAssigneeInput>, Enumerable<TaskUncheckedCreateWithoutAssigneeInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutAssigneeInput>
    upsert?: Enumerable<TaskUpsertWithWhereUniqueWithoutAssigneeInput>
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: Enumerable<TaskWhereUniqueInput>
    disconnect?: Enumerable<TaskWhereUniqueInput>
    delete?: Enumerable<TaskWhereUniqueInput>
    connect?: Enumerable<TaskWhereUniqueInput>
    update?: Enumerable<TaskUpdateWithWhereUniqueWithoutAssigneeInput>
    updateMany?: Enumerable<TaskUpdateManyWithWhereWithoutAssigneeInput>
    deleteMany?: Enumerable<TaskScalarWhereInput>
  }

  export type TaskUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<TaskCreateWithoutCreatorInput>, Enumerable<TaskUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<TaskUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: TaskCreateManyCreatorInputEnvelope
    set?: Enumerable<TaskWhereUniqueInput>
    disconnect?: Enumerable<TaskWhereUniqueInput>
    delete?: Enumerable<TaskWhereUniqueInput>
    connect?: Enumerable<TaskWhereUniqueInput>
    update?: Enumerable<TaskUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<TaskUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<TaskScalarWhereInput>
  }

  export type MessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<MessageCreateWithoutUserInput>, Enumerable<MessageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: MessageCreateManyUserInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutUserInput>, Enumerable<DocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type CampaignUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutOwnerInput>, Enumerable<CampaignUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: CampaignCreateManyOwnerInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type AIAgentUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<Enumerable<AIAgentCreateWithoutManagerInput>, Enumerable<AIAgentUncheckedCreateWithoutManagerInput>>
    connectOrCreate?: Enumerable<AIAgentCreateOrConnectWithoutManagerInput>
    upsert?: Enumerable<AIAgentUpsertWithWhereUniqueWithoutManagerInput>
    createMany?: AIAgentCreateManyManagerInputEnvelope
    set?: Enumerable<AIAgentWhereUniqueInput>
    disconnect?: Enumerable<AIAgentWhereUniqueInput>
    delete?: Enumerable<AIAgentWhereUniqueInput>
    connect?: Enumerable<AIAgentWhereUniqueInput>
    update?: Enumerable<AIAgentUpdateWithWhereUniqueWithoutManagerInput>
    updateMany?: Enumerable<AIAgentUpdateManyWithWhereWithoutManagerInput>
    deleteMany?: Enumerable<AIAgentScalarWhereInput>
  }

  export type FeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutUserInput>, Enumerable<FeedbackUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FeedbackUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: Enumerable<FeedbackWhereUniqueInput>
    disconnect?: Enumerable<FeedbackWhereUniqueInput>
    delete?: Enumerable<FeedbackWhereUniqueInput>
    connect?: Enumerable<FeedbackWhereUniqueInput>
    update?: Enumerable<FeedbackUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FeedbackUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FeedbackScalarWhereInput>
  }

  export type PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonalizationProfileCreateWithoutUserInput, PersonalizationProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalizationProfileCreateOrConnectWithoutUserInput
    upsert?: PersonalizationProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonalizationProfileWhereUniqueInput
    update?: XOR<PersonalizationProfileUpdateWithoutUserInput, PersonalizationProfileUncheckedUpdateWithoutUserInput>
  }

  export type OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput = {
    create?: XOR<Enumerable<OutreachTaskCreateWithoutResponseHandlerInput>, Enumerable<OutreachTaskUncheckedCreateWithoutResponseHandlerInput>>
    connectOrCreate?: Enumerable<OutreachTaskCreateOrConnectWithoutResponseHandlerInput>
    upsert?: Enumerable<OutreachTaskUpsertWithWhereUniqueWithoutResponseHandlerInput>
    createMany?: OutreachTaskCreateManyResponseHandlerInputEnvelope
    set?: Enumerable<OutreachTaskWhereUniqueInput>
    disconnect?: Enumerable<OutreachTaskWhereUniqueInput>
    delete?: Enumerable<OutreachTaskWhereUniqueInput>
    connect?: Enumerable<OutreachTaskWhereUniqueInput>
    update?: Enumerable<OutreachTaskUpdateWithWhereUniqueWithoutResponseHandlerInput>
    updateMany?: Enumerable<OutreachTaskUpdateManyWithWhereWithoutResponseHandlerInput>
    deleteMany?: Enumerable<OutreachTaskScalarWhereInput>
  }

  export type GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<GeneratedContentCreateWithoutCreatorInput>, Enumerable<GeneratedContentUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<GeneratedContentCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<GeneratedContentUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: GeneratedContentCreateManyCreatorInputEnvelope
    set?: Enumerable<GeneratedContentWhereUniqueInput>
    disconnect?: Enumerable<GeneratedContentWhereUniqueInput>
    delete?: Enumerable<GeneratedContentWhereUniqueInput>
    connect?: Enumerable<GeneratedContentWhereUniqueInput>
    update?: Enumerable<GeneratedContentUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<GeneratedContentUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<GeneratedContentScalarWhereInput>
  }

  export type IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<IntegrationCredentialCreateWithoutUserInput>, Enumerable<IntegrationCredentialUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IntegrationCredentialCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<IntegrationCredentialUpsertWithWhereUniqueWithoutUserInput>
    createMany?: IntegrationCredentialCreateManyUserInputEnvelope
    set?: Enumerable<IntegrationCredentialWhereUniqueInput>
    disconnect?: Enumerable<IntegrationCredentialWhereUniqueInput>
    delete?: Enumerable<IntegrationCredentialWhereUniqueInput>
    connect?: Enumerable<IntegrationCredentialWhereUniqueInput>
    update?: Enumerable<IntegrationCredentialUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<IntegrationCredentialUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<IntegrationCredentialScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutOwnedProjectsInput = {
    create?: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutProjectsInput = {
    create?: XOR<Enumerable<UserCreateWithoutProjectsInput>, Enumerable<UserUncheckedCreateWithoutProjectsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutProjectsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<TaskCreateWithoutProjectInput>, Enumerable<TaskUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutProjectInput>
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: Enumerable<TaskWhereUniqueInput>
  }

  export type MessageCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<MessageCreateWithoutProjectInput>, Enumerable<MessageUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutProjectInput>
    createMany?: MessageCreateManyProjectInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type DocumentCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutProjectInput>, Enumerable<DocumentUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutProjectInput>
    createMany?: DocumentCreateManyProjectInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type CampaignCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutProjectInput>, Enumerable<CampaignUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutProjectInput>
    createMany?: CampaignCreateManyProjectInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type AIAgentCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<AIAgentCreateWithoutProjectInput>, Enumerable<AIAgentUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<AIAgentCreateOrConnectWithoutProjectInput>
    createMany?: AIAgentCreateManyProjectInputEnvelope
    connect?: Enumerable<AIAgentWhereUniqueInput>
  }

  export type MetricCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<MetricCreateWithoutProjectInput>, Enumerable<MetricUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<MetricCreateOrConnectWithoutProjectInput>
    createMany?: MetricCreateManyProjectInputEnvelope
    connect?: Enumerable<MetricWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<Enumerable<UserCreateWithoutProjectsInput>, Enumerable<UserUncheckedCreateWithoutProjectsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutProjectsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<TaskCreateWithoutProjectInput>, Enumerable<TaskUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutProjectInput>
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: Enumerable<TaskWhereUniqueInput>
  }

  export type MessageUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<MessageCreateWithoutProjectInput>, Enumerable<MessageUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutProjectInput>
    createMany?: MessageCreateManyProjectInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutProjectInput>, Enumerable<DocumentUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutProjectInput>
    createMany?: DocumentCreateManyProjectInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type CampaignUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutProjectInput>, Enumerable<CampaignUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutProjectInput>
    createMany?: CampaignCreateManyProjectInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type AIAgentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<AIAgentCreateWithoutProjectInput>, Enumerable<AIAgentUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<AIAgentCreateOrConnectWithoutProjectInput>
    createMany?: AIAgentCreateManyProjectInputEnvelope
    connect?: Enumerable<AIAgentWhereUniqueInput>
  }

  export type MetricUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<MetricCreateWithoutProjectInput>, Enumerable<MetricUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<MetricCreateOrConnectWithoutProjectInput>
    createMany?: MetricCreateManyProjectInputEnvelope
    connect?: Enumerable<MetricWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedProjectsInput
    upsert?: UserUpsertWithoutOwnedProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOwnedProjectsInput, UserUncheckedUpdateWithoutOwnedProjectsInput>
  }

  export type UserUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutProjectsInput>, Enumerable<UserUncheckedCreateWithoutProjectsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutProjectsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutProjectsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<TaskCreateWithoutProjectInput>, Enumerable<TaskUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<TaskUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: Enumerable<TaskWhereUniqueInput>
    disconnect?: Enumerable<TaskWhereUniqueInput>
    delete?: Enumerable<TaskWhereUniqueInput>
    connect?: Enumerable<TaskWhereUniqueInput>
    update?: Enumerable<TaskUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<TaskUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<TaskScalarWhereInput>
  }

  export type MessageUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<MessageCreateWithoutProjectInput>, Enumerable<MessageUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: MessageCreateManyProjectInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type DocumentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutProjectInput>, Enumerable<DocumentUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: DocumentCreateManyProjectInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type CampaignUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutProjectInput>, Enumerable<CampaignUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: CampaignCreateManyProjectInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type AIAgentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<AIAgentCreateWithoutProjectInput>, Enumerable<AIAgentUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<AIAgentCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<AIAgentUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: AIAgentCreateManyProjectInputEnvelope
    set?: Enumerable<AIAgentWhereUniqueInput>
    disconnect?: Enumerable<AIAgentWhereUniqueInput>
    delete?: Enumerable<AIAgentWhereUniqueInput>
    connect?: Enumerable<AIAgentWhereUniqueInput>
    update?: Enumerable<AIAgentUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<AIAgentUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<AIAgentScalarWhereInput>
  }

  export type MetricUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<MetricCreateWithoutProjectInput>, Enumerable<MetricUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<MetricCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<MetricUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: MetricCreateManyProjectInputEnvelope
    set?: Enumerable<MetricWhereUniqueInput>
    disconnect?: Enumerable<MetricWhereUniqueInput>
    delete?: Enumerable<MetricWhereUniqueInput>
    connect?: Enumerable<MetricWhereUniqueInput>
    update?: Enumerable<MetricUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<MetricUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<MetricScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutProjectsInput>, Enumerable<UserUncheckedCreateWithoutProjectsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutProjectsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutProjectsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<TaskCreateWithoutProjectInput>, Enumerable<TaskUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<TaskCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<TaskUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: Enumerable<TaskWhereUniqueInput>
    disconnect?: Enumerable<TaskWhereUniqueInput>
    delete?: Enumerable<TaskWhereUniqueInput>
    connect?: Enumerable<TaskWhereUniqueInput>
    update?: Enumerable<TaskUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<TaskUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<TaskScalarWhereInput>
  }

  export type MessageUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<MessageCreateWithoutProjectInput>, Enumerable<MessageUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: MessageCreateManyProjectInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutProjectInput>, Enumerable<DocumentUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: DocumentCreateManyProjectInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type CampaignUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutProjectInput>, Enumerable<CampaignUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: CampaignCreateManyProjectInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type AIAgentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<AIAgentCreateWithoutProjectInput>, Enumerable<AIAgentUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<AIAgentCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<AIAgentUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: AIAgentCreateManyProjectInputEnvelope
    set?: Enumerable<AIAgentWhereUniqueInput>
    disconnect?: Enumerable<AIAgentWhereUniqueInput>
    delete?: Enumerable<AIAgentWhereUniqueInput>
    connect?: Enumerable<AIAgentWhereUniqueInput>
    update?: Enumerable<AIAgentUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<AIAgentUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<AIAgentScalarWhereInput>
  }

  export type MetricUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<MetricCreateWithoutProjectInput>, Enumerable<MetricUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<MetricCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<MetricUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: MetricCreateManyProjectInputEnvelope
    set?: Enumerable<MetricWhereUniqueInput>
    disconnect?: Enumerable<MetricWhereUniqueInput>
    delete?: Enumerable<MetricWhereUniqueInput>
    connect?: Enumerable<MetricWhereUniqueInput>
    update?: Enumerable<MetricUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<MetricUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<MetricScalarWhereInput>
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTasksInput = {
    create?: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTasksInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: TaskStatus
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: Priority
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProjectUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneWithoutTasksNestedInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    upsert?: UserUpsertWithoutTasksInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedTasksNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTasksInput
    upsert?: UserUpsertWithoutCreatedTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCreatedTasksInput, UserUncheckedUpdateWithoutCreatedTasksInput>
  }

  export type ProjectCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ProjectCreateWithoutMessagesInput, ProjectUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMessagesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ProjectCreateWithoutMessagesInput, ProjectUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMessagesInput
    upsert?: ProjectUpsertWithoutMessagesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutMessagesInput, ProjectUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type ProjectCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    upsert?: ProjectUpsertWithoutDocumentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type ProjectCreateNestedOneWithoutAiAgentsInput = {
    create?: XOR<ProjectCreateWithoutAiAgentsInput, ProjectUncheckedCreateWithoutAiAgentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAiAgentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutManagedAgentsInput = {
    create?: XOR<UserCreateWithoutManagedAgentsInput, UserUncheckedCreateWithoutManagedAgentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedAgentsInput
    connect?: UserWhereUniqueInput
  }

  export type GeneratedContentCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<GeneratedContentCreateWithoutAgentInput>, Enumerable<GeneratedContentUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<GeneratedContentCreateOrConnectWithoutAgentInput>
    createMany?: GeneratedContentCreateManyAgentInputEnvelope
    connect?: Enumerable<GeneratedContentWhereUniqueInput>
  }

  export type CampaignCreateNestedManyWithoutAgentsInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAgentsInput>, Enumerable<CampaignUncheckedCreateWithoutAgentsInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAgentsInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type TrendSignalCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<TrendSignalCreateWithoutAgentInput>, Enumerable<TrendSignalUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<TrendSignalCreateOrConnectWithoutAgentInput>
    createMany?: TrendSignalCreateManyAgentInputEnvelope
    connect?: Enumerable<TrendSignalWhereUniqueInput>
  }

  export type AgentExecutionSessionCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<AgentExecutionSessionCreateWithoutAgentInput>, Enumerable<AgentExecutionSessionUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<AgentExecutionSessionCreateOrConnectWithoutAgentInput>
    createMany?: AgentExecutionSessionCreateManyAgentInputEnvelope
    connect?: Enumerable<AgentExecutionSessionWhereUniqueInput>
  }

  export type GeneratedContentUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<GeneratedContentCreateWithoutAgentInput>, Enumerable<GeneratedContentUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<GeneratedContentCreateOrConnectWithoutAgentInput>
    createMany?: GeneratedContentCreateManyAgentInputEnvelope
    connect?: Enumerable<GeneratedContentWhereUniqueInput>
  }

  export type CampaignUncheckedCreateNestedManyWithoutAgentsInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAgentsInput>, Enumerable<CampaignUncheckedCreateWithoutAgentsInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAgentsInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type TrendSignalUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<TrendSignalCreateWithoutAgentInput>, Enumerable<TrendSignalUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<TrendSignalCreateOrConnectWithoutAgentInput>
    createMany?: TrendSignalCreateManyAgentInputEnvelope
    connect?: Enumerable<TrendSignalWhereUniqueInput>
  }

  export type AgentExecutionSessionUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<AgentExecutionSessionCreateWithoutAgentInput>, Enumerable<AgentExecutionSessionUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<AgentExecutionSessionCreateOrConnectWithoutAgentInput>
    createMany?: AgentExecutionSessionCreateManyAgentInputEnvelope
    connect?: Enumerable<AgentExecutionSessionWhereUniqueInput>
  }

  export type EnumAgentTypeFieldUpdateOperationsInput = {
    set?: AgentType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumAgentStatusFieldUpdateOperationsInput = {
    set?: AgentStatus
  }

  export type ProjectUpdateOneRequiredWithoutAiAgentsNestedInput = {
    create?: XOR<ProjectCreateWithoutAiAgentsInput, ProjectUncheckedCreateWithoutAiAgentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAiAgentsInput
    upsert?: ProjectUpsertWithoutAiAgentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutAiAgentsInput, ProjectUncheckedUpdateWithoutAiAgentsInput>
  }

  export type UserUpdateOneRequiredWithoutManagedAgentsNestedInput = {
    create?: XOR<UserCreateWithoutManagedAgentsInput, UserUncheckedCreateWithoutManagedAgentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedAgentsInput
    upsert?: UserUpsertWithoutManagedAgentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutManagedAgentsInput, UserUncheckedUpdateWithoutManagedAgentsInput>
  }

  export type GeneratedContentUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<GeneratedContentCreateWithoutAgentInput>, Enumerable<GeneratedContentUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<GeneratedContentCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<GeneratedContentUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: GeneratedContentCreateManyAgentInputEnvelope
    set?: Enumerable<GeneratedContentWhereUniqueInput>
    disconnect?: Enumerable<GeneratedContentWhereUniqueInput>
    delete?: Enumerable<GeneratedContentWhereUniqueInput>
    connect?: Enumerable<GeneratedContentWhereUniqueInput>
    update?: Enumerable<GeneratedContentUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<GeneratedContentUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<GeneratedContentScalarWhereInput>
  }

  export type CampaignUpdateManyWithoutAgentsNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAgentsInput>, Enumerable<CampaignUncheckedCreateWithoutAgentsInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAgentsInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutAgentsInput>
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutAgentsInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutAgentsInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type TrendSignalUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<TrendSignalCreateWithoutAgentInput>, Enumerable<TrendSignalUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<TrendSignalCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<TrendSignalUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: TrendSignalCreateManyAgentInputEnvelope
    set?: Enumerable<TrendSignalWhereUniqueInput>
    disconnect?: Enumerable<TrendSignalWhereUniqueInput>
    delete?: Enumerable<TrendSignalWhereUniqueInput>
    connect?: Enumerable<TrendSignalWhereUniqueInput>
    update?: Enumerable<TrendSignalUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<TrendSignalUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<TrendSignalScalarWhereInput>
  }

  export type AgentExecutionSessionUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<AgentExecutionSessionCreateWithoutAgentInput>, Enumerable<AgentExecutionSessionUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<AgentExecutionSessionCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<AgentExecutionSessionUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: AgentExecutionSessionCreateManyAgentInputEnvelope
    set?: Enumerable<AgentExecutionSessionWhereUniqueInput>
    disconnect?: Enumerable<AgentExecutionSessionWhereUniqueInput>
    delete?: Enumerable<AgentExecutionSessionWhereUniqueInput>
    connect?: Enumerable<AgentExecutionSessionWhereUniqueInput>
    update?: Enumerable<AgentExecutionSessionUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<AgentExecutionSessionUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<AgentExecutionSessionScalarWhereInput>
  }

  export type GeneratedContentUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<GeneratedContentCreateWithoutAgentInput>, Enumerable<GeneratedContentUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<GeneratedContentCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<GeneratedContentUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: GeneratedContentCreateManyAgentInputEnvelope
    set?: Enumerable<GeneratedContentWhereUniqueInput>
    disconnect?: Enumerable<GeneratedContentWhereUniqueInput>
    delete?: Enumerable<GeneratedContentWhereUniqueInput>
    connect?: Enumerable<GeneratedContentWhereUniqueInput>
    update?: Enumerable<GeneratedContentUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<GeneratedContentUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<GeneratedContentScalarWhereInput>
  }

  export type CampaignUncheckedUpdateManyWithoutAgentsNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAgentsInput>, Enumerable<CampaignUncheckedCreateWithoutAgentsInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAgentsInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutAgentsInput>
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutAgentsInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutAgentsInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type TrendSignalUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<TrendSignalCreateWithoutAgentInput>, Enumerable<TrendSignalUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<TrendSignalCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<TrendSignalUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: TrendSignalCreateManyAgentInputEnvelope
    set?: Enumerable<TrendSignalWhereUniqueInput>
    disconnect?: Enumerable<TrendSignalWhereUniqueInput>
    delete?: Enumerable<TrendSignalWhereUniqueInput>
    connect?: Enumerable<TrendSignalWhereUniqueInput>
    update?: Enumerable<TrendSignalUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<TrendSignalUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<TrendSignalScalarWhereInput>
  }

  export type AgentExecutionSessionUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<AgentExecutionSessionCreateWithoutAgentInput>, Enumerable<AgentExecutionSessionUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<AgentExecutionSessionCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<AgentExecutionSessionUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: AgentExecutionSessionCreateManyAgentInputEnvelope
    set?: Enumerable<AgentExecutionSessionWhereUniqueInput>
    disconnect?: Enumerable<AgentExecutionSessionWhereUniqueInput>
    delete?: Enumerable<AgentExecutionSessionWhereUniqueInput>
    connect?: Enumerable<AgentExecutionSessionWhereUniqueInput>
    update?: Enumerable<AgentExecutionSessionUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<AgentExecutionSessionUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<AgentExecutionSessionScalarWhereInput>
  }

  export type AIAgentCreateNestedOneWithoutExecutionSessionsInput = {
    create?: XOR<AIAgentCreateWithoutExecutionSessionsInput, AIAgentUncheckedCreateWithoutExecutionSessionsInput>
    connectOrCreate?: AIAgentCreateOrConnectWithoutExecutionSessionsInput
    connect?: AIAgentWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AIAgentUpdateOneRequiredWithoutExecutionSessionsNestedInput = {
    create?: XOR<AIAgentCreateWithoutExecutionSessionsInput, AIAgentUncheckedCreateWithoutExecutionSessionsInput>
    connectOrCreate?: AIAgentCreateOrConnectWithoutExecutionSessionsInput
    upsert?: AIAgentUpsertWithoutExecutionSessionsInput
    connect?: AIAgentWhereUniqueInput
    update?: XOR<AIAgentUpdateWithoutExecutionSessionsInput, AIAgentUncheckedUpdateWithoutExecutionSessionsInput>
  }

  export type UserCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<ProjectCreateWithoutCampaignsInput, ProjectUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCampaignsInput
    connect?: ProjectWhereUniqueInput
  }

  export type AIAgentCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<Enumerable<AIAgentCreateWithoutCampaignsInput>, Enumerable<AIAgentUncheckedCreateWithoutCampaignsInput>>
    connectOrCreate?: Enumerable<AIAgentCreateOrConnectWithoutCampaignsInput>
    connect?: Enumerable<AIAgentWhereUniqueInput>
  }

  export type GeneratedContentCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<GeneratedContentCreateWithoutCampaignInput>, Enumerable<GeneratedContentUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<GeneratedContentCreateOrConnectWithoutCampaignInput>
    createMany?: GeneratedContentCreateManyCampaignInputEnvelope
    connect?: Enumerable<GeneratedContentWhereUniqueInput>
  }

  export type OutreachTaskCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<OutreachTaskCreateWithoutCampaignInput>, Enumerable<OutreachTaskUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<OutreachTaskCreateOrConnectWithoutCampaignInput>
    createMany?: OutreachTaskCreateManyCampaignInputEnvelope
    connect?: Enumerable<OutreachTaskWhereUniqueInput>
  }

  export type MetricCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<MetricCreateWithoutCampaignInput>, Enumerable<MetricUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<MetricCreateOrConnectWithoutCampaignInput>
    createMany?: MetricCreateManyCampaignInputEnvelope
    connect?: Enumerable<MetricWhereUniqueInput>
  }

  export type AIAgentUncheckedCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<Enumerable<AIAgentCreateWithoutCampaignsInput>, Enumerable<AIAgentUncheckedCreateWithoutCampaignsInput>>
    connectOrCreate?: Enumerable<AIAgentCreateOrConnectWithoutCampaignsInput>
    connect?: Enumerable<AIAgentWhereUniqueInput>
  }

  export type GeneratedContentUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<GeneratedContentCreateWithoutCampaignInput>, Enumerable<GeneratedContentUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<GeneratedContentCreateOrConnectWithoutCampaignInput>
    createMany?: GeneratedContentCreateManyCampaignInputEnvelope
    connect?: Enumerable<GeneratedContentWhereUniqueInput>
  }

  export type OutreachTaskUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<OutreachTaskCreateWithoutCampaignInput>, Enumerable<OutreachTaskUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<OutreachTaskCreateOrConnectWithoutCampaignInput>
    createMany?: OutreachTaskCreateManyCampaignInputEnvelope
    connect?: Enumerable<OutreachTaskWhereUniqueInput>
  }

  export type MetricUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<MetricCreateWithoutCampaignInput>, Enumerable<MetricUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<MetricCreateOrConnectWithoutCampaignInput>
    createMany?: MetricCreateManyCampaignInputEnvelope
    connect?: Enumerable<MetricWhereUniqueInput>
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: CampaignStatus
  }

  export type EnumCampaignTypeFieldUpdateOperationsInput = {
    set?: CampaignType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    upsert?: UserUpsertWithoutCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
  }

  export type ProjectUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<ProjectCreateWithoutCampaignsInput, ProjectUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCampaignsInput
    upsert?: ProjectUpsertWithoutCampaignsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutCampaignsInput, ProjectUncheckedUpdateWithoutCampaignsInput>
  }

  export type AIAgentUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<Enumerable<AIAgentCreateWithoutCampaignsInput>, Enumerable<AIAgentUncheckedCreateWithoutCampaignsInput>>
    connectOrCreate?: Enumerable<AIAgentCreateOrConnectWithoutCampaignsInput>
    upsert?: Enumerable<AIAgentUpsertWithWhereUniqueWithoutCampaignsInput>
    set?: Enumerable<AIAgentWhereUniqueInput>
    disconnect?: Enumerable<AIAgentWhereUniqueInput>
    delete?: Enumerable<AIAgentWhereUniqueInput>
    connect?: Enumerable<AIAgentWhereUniqueInput>
    update?: Enumerable<AIAgentUpdateWithWhereUniqueWithoutCampaignsInput>
    updateMany?: Enumerable<AIAgentUpdateManyWithWhereWithoutCampaignsInput>
    deleteMany?: Enumerable<AIAgentScalarWhereInput>
  }

  export type GeneratedContentUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<GeneratedContentCreateWithoutCampaignInput>, Enumerable<GeneratedContentUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<GeneratedContentCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<GeneratedContentUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: GeneratedContentCreateManyCampaignInputEnvelope
    set?: Enumerable<GeneratedContentWhereUniqueInput>
    disconnect?: Enumerable<GeneratedContentWhereUniqueInput>
    delete?: Enumerable<GeneratedContentWhereUniqueInput>
    connect?: Enumerable<GeneratedContentWhereUniqueInput>
    update?: Enumerable<GeneratedContentUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<GeneratedContentUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<GeneratedContentScalarWhereInput>
  }

  export type OutreachTaskUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<OutreachTaskCreateWithoutCampaignInput>, Enumerable<OutreachTaskUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<OutreachTaskCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<OutreachTaskUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: OutreachTaskCreateManyCampaignInputEnvelope
    set?: Enumerable<OutreachTaskWhereUniqueInput>
    disconnect?: Enumerable<OutreachTaskWhereUniqueInput>
    delete?: Enumerable<OutreachTaskWhereUniqueInput>
    connect?: Enumerable<OutreachTaskWhereUniqueInput>
    update?: Enumerable<OutreachTaskUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<OutreachTaskUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<OutreachTaskScalarWhereInput>
  }

  export type MetricUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<MetricCreateWithoutCampaignInput>, Enumerable<MetricUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<MetricCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<MetricUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: MetricCreateManyCampaignInputEnvelope
    set?: Enumerable<MetricWhereUniqueInput>
    disconnect?: Enumerable<MetricWhereUniqueInput>
    delete?: Enumerable<MetricWhereUniqueInput>
    connect?: Enumerable<MetricWhereUniqueInput>
    update?: Enumerable<MetricUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<MetricUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<MetricScalarWhereInput>
  }

  export type AIAgentUncheckedUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<Enumerable<AIAgentCreateWithoutCampaignsInput>, Enumerable<AIAgentUncheckedCreateWithoutCampaignsInput>>
    connectOrCreate?: Enumerable<AIAgentCreateOrConnectWithoutCampaignsInput>
    upsert?: Enumerable<AIAgentUpsertWithWhereUniqueWithoutCampaignsInput>
    set?: Enumerable<AIAgentWhereUniqueInput>
    disconnect?: Enumerable<AIAgentWhereUniqueInput>
    delete?: Enumerable<AIAgentWhereUniqueInput>
    connect?: Enumerable<AIAgentWhereUniqueInput>
    update?: Enumerable<AIAgentUpdateWithWhereUniqueWithoutCampaignsInput>
    updateMany?: Enumerable<AIAgentUpdateManyWithWhereWithoutCampaignsInput>
    deleteMany?: Enumerable<AIAgentScalarWhereInput>
  }

  export type GeneratedContentUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<GeneratedContentCreateWithoutCampaignInput>, Enumerable<GeneratedContentUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<GeneratedContentCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<GeneratedContentUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: GeneratedContentCreateManyCampaignInputEnvelope
    set?: Enumerable<GeneratedContentWhereUniqueInput>
    disconnect?: Enumerable<GeneratedContentWhereUniqueInput>
    delete?: Enumerable<GeneratedContentWhereUniqueInput>
    connect?: Enumerable<GeneratedContentWhereUniqueInput>
    update?: Enumerable<GeneratedContentUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<GeneratedContentUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<GeneratedContentScalarWhereInput>
  }

  export type OutreachTaskUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<OutreachTaskCreateWithoutCampaignInput>, Enumerable<OutreachTaskUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<OutreachTaskCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<OutreachTaskUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: OutreachTaskCreateManyCampaignInputEnvelope
    set?: Enumerable<OutreachTaskWhereUniqueInput>
    disconnect?: Enumerable<OutreachTaskWhereUniqueInput>
    delete?: Enumerable<OutreachTaskWhereUniqueInput>
    connect?: Enumerable<OutreachTaskWhereUniqueInput>
    update?: Enumerable<OutreachTaskUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<OutreachTaskUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<OutreachTaskScalarWhereInput>
  }

  export type MetricUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<MetricCreateWithoutCampaignInput>, Enumerable<MetricUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<MetricCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<MetricUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: MetricCreateManyCampaignInputEnvelope
    set?: Enumerable<MetricWhereUniqueInput>
    disconnect?: Enumerable<MetricWhereUniqueInput>
    delete?: Enumerable<MetricWhereUniqueInput>
    connect?: Enumerable<MetricWhereUniqueInput>
    update?: Enumerable<MetricUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<MetricUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<MetricScalarWhereInput>
  }

  export type AIAgentCreateNestedOneWithoutGeneratedContentInput = {
    create?: XOR<AIAgentCreateWithoutGeneratedContentInput, AIAgentUncheckedCreateWithoutGeneratedContentInput>
    connectOrCreate?: AIAgentCreateOrConnectWithoutGeneratedContentInput
    connect?: AIAgentWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutGeneratedContentInput = {
    create?: XOR<CampaignCreateWithoutGeneratedContentInput, CampaignUncheckedCreateWithoutGeneratedContentInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutGeneratedContentInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedContentInput = {
    create?: XOR<UserCreateWithoutCreatedContentInput, UserUncheckedCreateWithoutCreatedContentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedContentInput
    connect?: UserWhereUniqueInput
  }

  export type FeedbackCreateNestedManyWithoutContent_relInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutContent_relInput>, Enumerable<FeedbackUncheckedCreateWithoutContent_relInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutContent_relInput>
    createMany?: FeedbackCreateManyContent_relInputEnvelope
    connect?: Enumerable<FeedbackWhereUniqueInput>
  }

  export type FeedbackUncheckedCreateNestedManyWithoutContent_relInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutContent_relInput>, Enumerable<FeedbackUncheckedCreateWithoutContent_relInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutContent_relInput>
    createMany?: FeedbackCreateManyContent_relInputEnvelope
    connect?: Enumerable<FeedbackWhereUniqueInput>
  }

  export type EnumContentTypeFieldUpdateOperationsInput = {
    set?: ContentType
  }

  export type NullableEnumPlatformFieldUpdateOperationsInput = {
    set?: Platform | null
  }

  export type EnumContentStatusFieldUpdateOperationsInput = {
    set?: ContentStatus
  }

  export type AIAgentUpdateOneRequiredWithoutGeneratedContentNestedInput = {
    create?: XOR<AIAgentCreateWithoutGeneratedContentInput, AIAgentUncheckedCreateWithoutGeneratedContentInput>
    connectOrCreate?: AIAgentCreateOrConnectWithoutGeneratedContentInput
    upsert?: AIAgentUpsertWithoutGeneratedContentInput
    connect?: AIAgentWhereUniqueInput
    update?: XOR<AIAgentUpdateWithoutGeneratedContentInput, AIAgentUncheckedUpdateWithoutGeneratedContentInput>
  }

  export type CampaignUpdateOneWithoutGeneratedContentNestedInput = {
    create?: XOR<CampaignCreateWithoutGeneratedContentInput, CampaignUncheckedCreateWithoutGeneratedContentInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutGeneratedContentInput
    upsert?: CampaignUpsertWithoutGeneratedContentInput
    disconnect?: boolean
    delete?: boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutGeneratedContentInput, CampaignUncheckedUpdateWithoutGeneratedContentInput>
  }

  export type UserUpdateOneWithoutCreatedContentNestedInput = {
    create?: XOR<UserCreateWithoutCreatedContentInput, UserUncheckedCreateWithoutCreatedContentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedContentInput
    upsert?: UserUpsertWithoutCreatedContentInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCreatedContentInput, UserUncheckedUpdateWithoutCreatedContentInput>
  }

  export type FeedbackUpdateManyWithoutContent_relNestedInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutContent_relInput>, Enumerable<FeedbackUncheckedCreateWithoutContent_relInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutContent_relInput>
    upsert?: Enumerable<FeedbackUpsertWithWhereUniqueWithoutContent_relInput>
    createMany?: FeedbackCreateManyContent_relInputEnvelope
    set?: Enumerable<FeedbackWhereUniqueInput>
    disconnect?: Enumerable<FeedbackWhereUniqueInput>
    delete?: Enumerable<FeedbackWhereUniqueInput>
    connect?: Enumerable<FeedbackWhereUniqueInput>
    update?: Enumerable<FeedbackUpdateWithWhereUniqueWithoutContent_relInput>
    updateMany?: Enumerable<FeedbackUpdateManyWithWhereWithoutContent_relInput>
    deleteMany?: Enumerable<FeedbackScalarWhereInput>
  }

  export type FeedbackUncheckedUpdateManyWithoutContent_relNestedInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutContent_relInput>, Enumerable<FeedbackUncheckedCreateWithoutContent_relInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutContent_relInput>
    upsert?: Enumerable<FeedbackUpsertWithWhereUniqueWithoutContent_relInput>
    createMany?: FeedbackCreateManyContent_relInputEnvelope
    set?: Enumerable<FeedbackWhereUniqueInput>
    disconnect?: Enumerable<FeedbackWhereUniqueInput>
    delete?: Enumerable<FeedbackWhereUniqueInput>
    connect?: Enumerable<FeedbackWhereUniqueInput>
    update?: Enumerable<FeedbackUpdateWithWhereUniqueWithoutContent_relInput>
    updateMany?: Enumerable<FeedbackUpdateManyWithWhereWithoutContent_relInput>
    deleteMany?: Enumerable<FeedbackScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutOutreachResponsesInput = {
    create?: XOR<UserCreateWithoutOutreachResponsesInput, UserUncheckedCreateWithoutOutreachResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOutreachResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutOutreachTasksInput = {
    create?: XOR<CampaignCreateWithoutOutreachTasksInput, CampaignUncheckedCreateWithoutOutreachTasksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutOutreachTasksInput
    connect?: CampaignWhereUniqueInput
  }

  export type FeedbackCreateNestedManyWithoutOutreachTaskInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutOutreachTaskInput>, Enumerable<FeedbackUncheckedCreateWithoutOutreachTaskInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutOutreachTaskInput>
    createMany?: FeedbackCreateManyOutreachTaskInputEnvelope
    connect?: Enumerable<FeedbackWhereUniqueInput>
  }

  export type FeedbackUncheckedCreateNestedManyWithoutOutreachTaskInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutOutreachTaskInput>, Enumerable<FeedbackUncheckedCreateWithoutOutreachTaskInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutOutreachTaskInput>
    createMany?: FeedbackCreateManyOutreachTaskInputEnvelope
    connect?: Enumerable<FeedbackWhereUniqueInput>
  }

  export type EnumOutreachTypeFieldUpdateOperationsInput = {
    set?: OutreachType
  }

  export type EnumOutreachStatusFieldUpdateOperationsInput = {
    set?: OutreachStatus
  }

  export type EnumContactMethodFieldUpdateOperationsInput = {
    set?: ContactMethod
  }

  export type UserUpdateOneWithoutOutreachResponsesNestedInput = {
    create?: XOR<UserCreateWithoutOutreachResponsesInput, UserUncheckedCreateWithoutOutreachResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOutreachResponsesInput
    upsert?: UserUpsertWithoutOutreachResponsesInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOutreachResponsesInput, UserUncheckedUpdateWithoutOutreachResponsesInput>
  }

  export type CampaignUpdateOneRequiredWithoutOutreachTasksNestedInput = {
    create?: XOR<CampaignCreateWithoutOutreachTasksInput, CampaignUncheckedCreateWithoutOutreachTasksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutOutreachTasksInput
    upsert?: CampaignUpsertWithoutOutreachTasksInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutOutreachTasksInput, CampaignUncheckedUpdateWithoutOutreachTasksInput>
  }

  export type FeedbackUpdateManyWithoutOutreachTaskNestedInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutOutreachTaskInput>, Enumerable<FeedbackUncheckedCreateWithoutOutreachTaskInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutOutreachTaskInput>
    upsert?: Enumerable<FeedbackUpsertWithWhereUniqueWithoutOutreachTaskInput>
    createMany?: FeedbackCreateManyOutreachTaskInputEnvelope
    set?: Enumerable<FeedbackWhereUniqueInput>
    disconnect?: Enumerable<FeedbackWhereUniqueInput>
    delete?: Enumerable<FeedbackWhereUniqueInput>
    connect?: Enumerable<FeedbackWhereUniqueInput>
    update?: Enumerable<FeedbackUpdateWithWhereUniqueWithoutOutreachTaskInput>
    updateMany?: Enumerable<FeedbackUpdateManyWithWhereWithoutOutreachTaskInput>
    deleteMany?: Enumerable<FeedbackScalarWhereInput>
  }

  export type FeedbackUncheckedUpdateManyWithoutOutreachTaskNestedInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutOutreachTaskInput>, Enumerable<FeedbackUncheckedCreateWithoutOutreachTaskInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutOutreachTaskInput>
    upsert?: Enumerable<FeedbackUpsertWithWhereUniqueWithoutOutreachTaskInput>
    createMany?: FeedbackCreateManyOutreachTaskInputEnvelope
    set?: Enumerable<FeedbackWhereUniqueInput>
    disconnect?: Enumerable<FeedbackWhereUniqueInput>
    delete?: Enumerable<FeedbackWhereUniqueInput>
    connect?: Enumerable<FeedbackWhereUniqueInput>
    update?: Enumerable<FeedbackUpdateWithWhereUniqueWithoutOutreachTaskInput>
    updateMany?: Enumerable<FeedbackUpdateManyWithWhereWithoutOutreachTaskInput>
    deleteMany?: Enumerable<FeedbackScalarWhereInput>
  }

  export type AIAgentCreateNestedOneWithoutTrendSignalsInput = {
    create?: XOR<AIAgentCreateWithoutTrendSignalsInput, AIAgentUncheckedCreateWithoutTrendSignalsInput>
    connectOrCreate?: AIAgentCreateOrConnectWithoutTrendSignalsInput
    connect?: AIAgentWhereUniqueInput
  }

  export type EnumSignalTypeFieldUpdateOperationsInput = {
    set?: SignalType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumTrendImpactFieldUpdateOperationsInput = {
    set?: TrendImpact
  }

  export type AIAgentUpdateOneRequiredWithoutTrendSignalsNestedInput = {
    create?: XOR<AIAgentCreateWithoutTrendSignalsInput, AIAgentUncheckedCreateWithoutTrendSignalsInput>
    connectOrCreate?: AIAgentCreateOrConnectWithoutTrendSignalsInput
    upsert?: AIAgentUpsertWithoutTrendSignalsInput
    connect?: AIAgentWhereUniqueInput
    update?: XOR<AIAgentUpdateWithoutTrendSignalsInput, AIAgentUncheckedUpdateWithoutTrendSignalsInput>
  }

  export type IntegrationCredentialCreatescopesInput = {
    set: Enumerable<string>
  }

  export type UserCreateNestedOneWithoutIntegrationCredentialsInput = {
    create?: XOR<UserCreateWithoutIntegrationCredentialsInput, UserUncheckedCreateWithoutIntegrationCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIntegrationCredentialsInput
    connect?: UserWhereUniqueInput
  }

  export type IntegrationCredentialUpdatescopesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type UserUpdateOneRequiredWithoutIntegrationCredentialsNestedInput = {
    create?: XOR<UserCreateWithoutIntegrationCredentialsInput, UserUncheckedCreateWithoutIntegrationCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIntegrationCredentialsInput
    upsert?: UserUpsertWithoutIntegrationCredentialsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIntegrationCredentialsInput, UserUncheckedUpdateWithoutIntegrationCredentialsInput>
  }

  export type CampaignCreateNestedOneWithoutMetricsInput = {
    create?: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMetricsInput
    connect?: CampaignWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutMetricsInput = {
    create?: XOR<ProjectCreateWithoutMetricsInput, ProjectUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMetricsInput
    connect?: ProjectWhereUniqueInput
  }

  export type CampaignUpdateOneWithoutMetricsNestedInput = {
    create?: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMetricsInput
    upsert?: CampaignUpsertWithoutMetricsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutMetricsInput, CampaignUncheckedUpdateWithoutMetricsInput>
  }

  export type ProjectUpdateOneWithoutMetricsNestedInput = {
    create?: XOR<ProjectCreateWithoutMetricsInput, ProjectUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMetricsInput
    upsert?: ProjectUpsertWithoutMetricsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutMetricsInput, ProjectUncheckedUpdateWithoutMetricsInput>
  }

  export type UserCreateNestedOneWithoutPersonalizationProfileInput = {
    create?: XOR<UserCreateWithoutPersonalizationProfileInput, UserUncheckedCreateWithoutPersonalizationProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalizationProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPersonalizationProfileNestedInput = {
    create?: XOR<UserCreateWithoutPersonalizationProfileInput, UserUncheckedCreateWithoutPersonalizationProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalizationProfileInput
    upsert?: UserUpsertWithoutPersonalizationProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPersonalizationProfileInput, UserUncheckedUpdateWithoutPersonalizationProfileInput>
  }

  export type UserCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackInput
    connect?: UserWhereUniqueInput
  }

  export type GeneratedContentCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<GeneratedContentCreateWithoutFeedbackInput, GeneratedContentUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: GeneratedContentCreateOrConnectWithoutFeedbackInput
    connect?: GeneratedContentWhereUniqueInput
  }

  export type OutreachTaskCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<OutreachTaskCreateWithoutFeedbackInput, OutreachTaskUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: OutreachTaskCreateOrConnectWithoutFeedbackInput
    connect?: OutreachTaskWhereUniqueInput
  }

  export type EnumFeedbackChannelFieldUpdateOperationsInput = {
    set?: FeedbackChannel
  }

  export type EnumSentimentFieldUpdateOperationsInput = {
    set?: Sentiment
  }

  export type EnumFeedbackSourceFieldUpdateOperationsInput = {
    set?: FeedbackSource
  }

  export type UserUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackInput
    upsert?: UserUpsertWithoutFeedbackInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFeedbackInput, UserUncheckedUpdateWithoutFeedbackInput>
  }

  export type GeneratedContentUpdateOneWithoutFeedbackNestedInput = {
    create?: XOR<GeneratedContentCreateWithoutFeedbackInput, GeneratedContentUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: GeneratedContentCreateOrConnectWithoutFeedbackInput
    upsert?: GeneratedContentUpsertWithoutFeedbackInput
    disconnect?: boolean
    delete?: boolean
    connect?: GeneratedContentWhereUniqueInput
    update?: XOR<GeneratedContentUpdateWithoutFeedbackInput, GeneratedContentUncheckedUpdateWithoutFeedbackInput>
  }

  export type OutreachTaskUpdateOneWithoutFeedbackNestedInput = {
    create?: XOR<OutreachTaskCreateWithoutFeedbackInput, OutreachTaskUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: OutreachTaskCreateOrConnectWithoutFeedbackInput
    upsert?: OutreachTaskUpsertWithoutFeedbackInput
    disconnect?: boolean
    delete?: boolean
    connect?: OutreachTaskWhereUniqueInput
    update?: XOR<OutreachTaskUpdateWithoutFeedbackInput, OutreachTaskUncheckedUpdateWithoutFeedbackInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumTaskStatusFilter = {
    equals?: TaskStatus
    in?: Enumerable<TaskStatus>
    notIn?: Enumerable<TaskStatus>
    not?: NestedEnumTaskStatusFilter | TaskStatus
  }

  export type NestedEnumPriorityFilter = {
    equals?: Priority
    in?: Enumerable<Priority>
    notIn?: Enumerable<Priority>
    not?: NestedEnumPriorityFilter | Priority
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumTaskStatusWithAggregatesFilter = {
    equals?: TaskStatus
    in?: Enumerable<TaskStatus>
    notIn?: Enumerable<TaskStatus>
    not?: NestedEnumTaskStatusWithAggregatesFilter | TaskStatus
    _count?: NestedIntFilter
    _min?: NestedEnumTaskStatusFilter
    _max?: NestedEnumTaskStatusFilter
  }

  export type NestedEnumPriorityWithAggregatesFilter = {
    equals?: Priority
    in?: Enumerable<Priority>
    notIn?: Enumerable<Priority>
    not?: NestedEnumPriorityWithAggregatesFilter | Priority
    _count?: NestedIntFilter
    _min?: NestedEnumPriorityFilter
    _max?: NestedEnumPriorityFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumAgentTypeFilter = {
    equals?: AgentType
    in?: Enumerable<AgentType>
    notIn?: Enumerable<AgentType>
    not?: NestedEnumAgentTypeFilter | AgentType
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumAgentStatusFilter = {
    equals?: AgentStatus
    in?: Enumerable<AgentStatus>
    notIn?: Enumerable<AgentStatus>
    not?: NestedEnumAgentStatusFilter | AgentStatus
  }

  export type NestedEnumAgentTypeWithAggregatesFilter = {
    equals?: AgentType
    in?: Enumerable<AgentType>
    notIn?: Enumerable<AgentType>
    not?: NestedEnumAgentTypeWithAggregatesFilter | AgentType
    _count?: NestedIntFilter
    _min?: NestedEnumAgentTypeFilter
    _max?: NestedEnumAgentTypeFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumAgentStatusWithAggregatesFilter = {
    equals?: AgentStatus
    in?: Enumerable<AgentStatus>
    notIn?: Enumerable<AgentStatus>
    not?: NestedEnumAgentStatusWithAggregatesFilter | AgentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumAgentStatusFilter
    _max?: NestedEnumAgentStatusFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedEnumCampaignStatusFilter = {
    equals?: CampaignStatus
    in?: Enumerable<CampaignStatus>
    notIn?: Enumerable<CampaignStatus>
    not?: NestedEnumCampaignStatusFilter | CampaignStatus
  }

  export type NestedEnumCampaignTypeFilter = {
    equals?: CampaignType
    in?: Enumerable<CampaignType>
    notIn?: Enumerable<CampaignType>
    not?: NestedEnumCampaignTypeFilter | CampaignType
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter = {
    equals?: CampaignStatus
    in?: Enumerable<CampaignStatus>
    notIn?: Enumerable<CampaignStatus>
    not?: NestedEnumCampaignStatusWithAggregatesFilter | CampaignStatus
    _count?: NestedIntFilter
    _min?: NestedEnumCampaignStatusFilter
    _max?: NestedEnumCampaignStatusFilter
  }

  export type NestedEnumCampaignTypeWithAggregatesFilter = {
    equals?: CampaignType
    in?: Enumerable<CampaignType>
    notIn?: Enumerable<CampaignType>
    not?: NestedEnumCampaignTypeWithAggregatesFilter | CampaignType
    _count?: NestedIntFilter
    _min?: NestedEnumCampaignTypeFilter
    _max?: NestedEnumCampaignTypeFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedEnumContentTypeFilter = {
    equals?: ContentType
    in?: Enumerable<ContentType>
    notIn?: Enumerable<ContentType>
    not?: NestedEnumContentTypeFilter | ContentType
  }

  export type NestedEnumPlatformNullableFilter = {
    equals?: Platform | null
    in?: Enumerable<Platform> | null
    notIn?: Enumerable<Platform> | null
    not?: NestedEnumPlatformNullableFilter | Platform | null
  }

  export type NestedEnumContentStatusFilter = {
    equals?: ContentStatus
    in?: Enumerable<ContentStatus>
    notIn?: Enumerable<ContentStatus>
    not?: NestedEnumContentStatusFilter | ContentStatus
  }

  export type NestedEnumContentTypeWithAggregatesFilter = {
    equals?: ContentType
    in?: Enumerable<ContentType>
    notIn?: Enumerable<ContentType>
    not?: NestedEnumContentTypeWithAggregatesFilter | ContentType
    _count?: NestedIntFilter
    _min?: NestedEnumContentTypeFilter
    _max?: NestedEnumContentTypeFilter
  }

  export type NestedEnumPlatformNullableWithAggregatesFilter = {
    equals?: Platform | null
    in?: Enumerable<Platform> | null
    notIn?: Enumerable<Platform> | null
    not?: NestedEnumPlatformNullableWithAggregatesFilter | Platform | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumPlatformNullableFilter
    _max?: NestedEnumPlatformNullableFilter
  }

  export type NestedEnumContentStatusWithAggregatesFilter = {
    equals?: ContentStatus
    in?: Enumerable<ContentStatus>
    notIn?: Enumerable<ContentStatus>
    not?: NestedEnumContentStatusWithAggregatesFilter | ContentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumContentStatusFilter
    _max?: NestedEnumContentStatusFilter
  }

  export type NestedEnumOutreachTypeFilter = {
    equals?: OutreachType
    in?: Enumerable<OutreachType>
    notIn?: Enumerable<OutreachType>
    not?: NestedEnumOutreachTypeFilter | OutreachType
  }

  export type NestedEnumOutreachStatusFilter = {
    equals?: OutreachStatus
    in?: Enumerable<OutreachStatus>
    notIn?: Enumerable<OutreachStatus>
    not?: NestedEnumOutreachStatusFilter | OutreachStatus
  }

  export type NestedEnumContactMethodFilter = {
    equals?: ContactMethod
    in?: Enumerable<ContactMethod>
    notIn?: Enumerable<ContactMethod>
    not?: NestedEnumContactMethodFilter | ContactMethod
  }

  export type NestedEnumOutreachTypeWithAggregatesFilter = {
    equals?: OutreachType
    in?: Enumerable<OutreachType>
    notIn?: Enumerable<OutreachType>
    not?: NestedEnumOutreachTypeWithAggregatesFilter | OutreachType
    _count?: NestedIntFilter
    _min?: NestedEnumOutreachTypeFilter
    _max?: NestedEnumOutreachTypeFilter
  }

  export type NestedEnumOutreachStatusWithAggregatesFilter = {
    equals?: OutreachStatus
    in?: Enumerable<OutreachStatus>
    notIn?: Enumerable<OutreachStatus>
    not?: NestedEnumOutreachStatusWithAggregatesFilter | OutreachStatus
    _count?: NestedIntFilter
    _min?: NestedEnumOutreachStatusFilter
    _max?: NestedEnumOutreachStatusFilter
  }

  export type NestedEnumContactMethodWithAggregatesFilter = {
    equals?: ContactMethod
    in?: Enumerable<ContactMethod>
    notIn?: Enumerable<ContactMethod>
    not?: NestedEnumContactMethodWithAggregatesFilter | ContactMethod
    _count?: NestedIntFilter
    _min?: NestedEnumContactMethodFilter
    _max?: NestedEnumContactMethodFilter
  }

  export type NestedEnumSignalTypeFilter = {
    equals?: SignalType
    in?: Enumerable<SignalType>
    notIn?: Enumerable<SignalType>
    not?: NestedEnumSignalTypeFilter | SignalType
  }

  export type NestedEnumTrendImpactFilter = {
    equals?: TrendImpact
    in?: Enumerable<TrendImpact>
    notIn?: Enumerable<TrendImpact>
    not?: NestedEnumTrendImpactFilter | TrendImpact
  }

  export type NestedEnumSignalTypeWithAggregatesFilter = {
    equals?: SignalType
    in?: Enumerable<SignalType>
    notIn?: Enumerable<SignalType>
    not?: NestedEnumSignalTypeWithAggregatesFilter | SignalType
    _count?: NestedIntFilter
    _min?: NestedEnumSignalTypeFilter
    _max?: NestedEnumSignalTypeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedEnumTrendImpactWithAggregatesFilter = {
    equals?: TrendImpact
    in?: Enumerable<TrendImpact>
    notIn?: Enumerable<TrendImpact>
    not?: NestedEnumTrendImpactWithAggregatesFilter | TrendImpact
    _count?: NestedIntFilter
    _min?: NestedEnumTrendImpactFilter
    _max?: NestedEnumTrendImpactFilter
  }

  export type NestedEnumFeedbackChannelFilter = {
    equals?: FeedbackChannel
    in?: Enumerable<FeedbackChannel>
    notIn?: Enumerable<FeedbackChannel>
    not?: NestedEnumFeedbackChannelFilter | FeedbackChannel
  }

  export type NestedEnumSentimentFilter = {
    equals?: Sentiment
    in?: Enumerable<Sentiment>
    notIn?: Enumerable<Sentiment>
    not?: NestedEnumSentimentFilter | Sentiment
  }

  export type NestedEnumFeedbackSourceFilter = {
    equals?: FeedbackSource
    in?: Enumerable<FeedbackSource>
    notIn?: Enumerable<FeedbackSource>
    not?: NestedEnumFeedbackSourceFilter | FeedbackSource
  }

  export type NestedEnumFeedbackChannelWithAggregatesFilter = {
    equals?: FeedbackChannel
    in?: Enumerable<FeedbackChannel>
    notIn?: Enumerable<FeedbackChannel>
    not?: NestedEnumFeedbackChannelWithAggregatesFilter | FeedbackChannel
    _count?: NestedIntFilter
    _min?: NestedEnumFeedbackChannelFilter
    _max?: NestedEnumFeedbackChannelFilter
  }

  export type NestedEnumSentimentWithAggregatesFilter = {
    equals?: Sentiment
    in?: Enumerable<Sentiment>
    notIn?: Enumerable<Sentiment>
    not?: NestedEnumSentimentWithAggregatesFilter | Sentiment
    _count?: NestedIntFilter
    _min?: NestedEnumSentimentFilter
    _max?: NestedEnumSentimentFilter
  }

  export type NestedEnumFeedbackSourceWithAggregatesFilter = {
    equals?: FeedbackSource
    in?: Enumerable<FeedbackSource>
    notIn?: Enumerable<FeedbackSource>
    not?: NestedEnumFeedbackSourceWithAggregatesFilter | FeedbackSource
    _count?: NestedIntFilter
    _min?: NestedEnumFeedbackSourceFilter
    _max?: NestedEnumFeedbackSourceFilter
  }

  export type ProjectCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    campaigns?: CampaignCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentCreateNestedManyWithoutProjectInput
    metrics?: MetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutProjectInput
    metrics?: MetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type ProjectCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserCreateNestedManyWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    campaigns?: CampaignCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentCreateNestedManyWithoutProjectInput
    metrics?: MetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutProjectsInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutProjectInput
    metrics?: MetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectCreateManyOwnerInputEnvelope = {
    data: Enumerable<ProjectCreateManyOwnerInput>
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: TaskStatus
    priority?: Priority
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutCreatedTasksInput
  }

  export type TaskUncheckedCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: TaskStatus
    priority?: Priority
    dueDate?: Date | string | null
    projectId: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskCreateManyAssigneeInputEnvelope = {
    data: Enumerable<TaskCreateManyAssigneeInput>
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: TaskStatus
    priority?: Priority
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    assignee?: UserCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: TaskStatus
    priority?: Priority
    dueDate?: Date | string | null
    projectId: string
    assigneeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput>
  }

  export type TaskCreateManyCreatorInputEnvelope = {
    data: Enumerable<TaskCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateManyUserInputEnvelope = {
    data: Enumerable<MessageCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutUserInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentCreateManyUserInputEnvelope = {
    data: Enumerable<DocumentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutCampaignsInput
    agents?: AIAgentCreateNestedManyWithoutCampaignsInput
    generatedContent?: GeneratedContentCreateNestedManyWithoutCampaignInput
    outreachTasks?: OutreachTaskCreateNestedManyWithoutCampaignInput
    metrics?: MetricCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AIAgentUncheckedCreateNestedManyWithoutCampaignsInput
    generatedContent?: GeneratedContentUncheckedCreateNestedManyWithoutCampaignInput
    outreachTasks?: OutreachTaskUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: MetricUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutOwnerInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutOwnerInput, CampaignUncheckedCreateWithoutOwnerInput>
  }

  export type CampaignCreateManyOwnerInputEnvelope = {
    data: Enumerable<CampaignCreateManyOwnerInput>
    skipDuplicates?: boolean
  }

  export type AIAgentCreateWithoutManagerInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAiAgentsInput
    generatedContent?: GeneratedContentCreateNestedManyWithoutAgentInput
    campaigns?: CampaignCreateNestedManyWithoutAgentsInput
    trendSignals?: TrendSignalCreateNestedManyWithoutAgentInput
    executionSessions?: AgentExecutionSessionCreateNestedManyWithoutAgentInput
  }

  export type AIAgentUncheckedCreateWithoutManagerInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedContent?: GeneratedContentUncheckedCreateNestedManyWithoutAgentInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutAgentsInput
    trendSignals?: TrendSignalUncheckedCreateNestedManyWithoutAgentInput
    executionSessions?: AgentExecutionSessionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AIAgentCreateOrConnectWithoutManagerInput = {
    where: AIAgentWhereUniqueInput
    create: XOR<AIAgentCreateWithoutManagerInput, AIAgentUncheckedCreateWithoutManagerInput>
  }

  export type AIAgentCreateManyManagerInputEnvelope = {
    data: Enumerable<AIAgentCreateManyManagerInput>
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutUserInput = {
    id?: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    createdAt?: Date | string
    content_rel?: GeneratedContentCreateNestedOneWithoutFeedbackInput
    outreachTask?: OutreachTaskCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutUserInput = {
    id?: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    contentId?: string | null
    outreachTaskId?: string | null
    createdAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackCreateManyUserInputEnvelope = {
    data: Enumerable<FeedbackCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PersonalizationProfileCreateWithoutUserInput = {
    id?: string
    behaviorCluster: string
    interestAffinity: JsonNullValueInput | InputJsonValue
    engagementScore: number
    contentPreferences: JsonNullValueInput | InputJsonValue
    activeHours?: NullableJsonNullValueInput | InputJsonValue
    devicePreference?: string | null
    clickPatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalizationProfileUncheckedCreateWithoutUserInput = {
    id?: string
    behaviorCluster: string
    interestAffinity: JsonNullValueInput | InputJsonValue
    engagementScore: number
    contentPreferences: JsonNullValueInput | InputJsonValue
    activeHours?: NullableJsonNullValueInput | InputJsonValue
    devicePreference?: string | null
    clickPatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalizationProfileCreateOrConnectWithoutUserInput = {
    where: PersonalizationProfileWhereUniqueInput
    create: XOR<PersonalizationProfileCreateWithoutUserInput, PersonalizationProfileUncheckedCreateWithoutUserInput>
  }

  export type OutreachTaskCreateWithoutResponseHandlerInput = {
    id?: string
    title: string
    description?: string | null
    outreachType: OutreachType
    status?: OutreachStatus
    leadInfo: JsonNullValueInput | InputJsonValue
    contactMethod: ContactMethod
    aiResponse?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutOutreachTasksInput
    feedback?: FeedbackCreateNestedManyWithoutOutreachTaskInput
  }

  export type OutreachTaskUncheckedCreateWithoutResponseHandlerInput = {
    id?: string
    title: string
    description?: string | null
    outreachType: OutreachType
    status?: OutreachStatus
    leadInfo: JsonNullValueInput | InputJsonValue
    contactMethod: ContactMethod
    aiResponse?: string | null
    campaignId: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feedback?: FeedbackUncheckedCreateNestedManyWithoutOutreachTaskInput
  }

  export type OutreachTaskCreateOrConnectWithoutResponseHandlerInput = {
    where: OutreachTaskWhereUniqueInput
    create: XOR<OutreachTaskCreateWithoutResponseHandlerInput, OutreachTaskUncheckedCreateWithoutResponseHandlerInput>
  }

  export type OutreachTaskCreateManyResponseHandlerInputEnvelope = {
    data: Enumerable<OutreachTaskCreateManyResponseHandlerInput>
    skipDuplicates?: boolean
  }

  export type GeneratedContentCreateWithoutCreatorInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AIAgentCreateNestedOneWithoutGeneratedContentInput
    campaign?: CampaignCreateNestedOneWithoutGeneratedContentInput
    feedback?: FeedbackCreateNestedManyWithoutContent_relInput
  }

  export type GeneratedContentUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    agentId: string
    campaignId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feedback?: FeedbackUncheckedCreateNestedManyWithoutContent_relInput
  }

  export type GeneratedContentCreateOrConnectWithoutCreatorInput = {
    where: GeneratedContentWhereUniqueInput
    create: XOR<GeneratedContentCreateWithoutCreatorInput, GeneratedContentUncheckedCreateWithoutCreatorInput>
  }

  export type GeneratedContentCreateManyCreatorInputEnvelope = {
    data: Enumerable<GeneratedContentCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type IntegrationCredentialCreateWithoutUserInput = {
    id?: string
    platform: string
    accountIdentifier?: string | null
    authToken: string
    refreshToken?: string | null
    tokenType?: string | null
    expiry?: Date | string | null
    scopes?: IntegrationCredentialCreatescopesInput | Enumerable<string>
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCredentialUncheckedCreateWithoutUserInput = {
    id?: string
    platform: string
    accountIdentifier?: string | null
    authToken: string
    refreshToken?: string | null
    tokenType?: string | null
    expiry?: Date | string | null
    scopes?: IntegrationCredentialCreatescopesInput | Enumerable<string>
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCredentialCreateOrConnectWithoutUserInput = {
    where: IntegrationCredentialWhereUniqueInput
    create: XOR<IntegrationCredentialCreateWithoutUserInput, IntegrationCredentialUncheckedCreateWithoutUserInput>
  }

  export type IntegrationCredentialCreateManyUserInputEnvelope = {
    data: Enumerable<IntegrationCredentialCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateManyWithWhereWithoutMembersInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: Enumerable<ProjectScalarWhereInput>
    OR?: Enumerable<ProjectScalarWhereInput>
    NOT?: Enumerable<ProjectScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    ownerId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutOwnerInput, ProjectUncheckedUpdateWithoutOwnerInput>
    create: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutOwnerInput, ProjectUncheckedUpdateWithoutOwnerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutOwnerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutOwnedProjectsInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
  }

  export type TaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutTasksInput>
  }

  export type TaskScalarWhereInput = {
    AND?: Enumerable<TaskScalarWhereInput>
    OR?: Enumerable<TaskScalarWhereInput>
    NOT?: Enumerable<TaskScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    status?: EnumTaskStatusFilter | TaskStatus
    priority?: EnumPriorityFilter | Priority
    dueDate?: DateTimeNullableFilter | Date | string | null
    projectId?: StringFilter | string
    assigneeId?: StringNullableFilter | string | null
    creatorId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCreatorInput, TaskUncheckedUpdateWithoutCreatorInput>
    create: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCreatorInput, TaskUncheckedUpdateWithoutCreatorInput>
  }

  export type TaskUpdateManyWithWhereWithoutCreatorInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCreatedTasksInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutMessagesInput>
  }

  export type MessageScalarWhereInput = {
    AND?: Enumerable<MessageScalarWhereInput>
    OR?: Enumerable<MessageScalarWhereInput>
    NOT?: Enumerable<MessageScalarWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    projectId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: Enumerable<DocumentScalarWhereInput>
    OR?: Enumerable<DocumentScalarWhereInput>
    NOT?: Enumerable<DocumentScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    fileUrl?: StringFilter | string
    fileType?: StringFilter | string
    fileSize?: IntFilter | number
    projectId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CampaignUpsertWithWhereUniqueWithoutOwnerInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutOwnerInput, CampaignUncheckedUpdateWithoutOwnerInput>
    create: XOR<CampaignCreateWithoutOwnerInput, CampaignUncheckedCreateWithoutOwnerInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutOwnerInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutOwnerInput, CampaignUncheckedUpdateWithoutOwnerInput>
  }

  export type CampaignUpdateManyWithWhereWithoutOwnerInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: Enumerable<CampaignScalarWhereInput>
    OR?: Enumerable<CampaignScalarWhereInput>
    NOT?: Enumerable<CampaignScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    status?: EnumCampaignStatusFilter | CampaignStatus
    campaignType?: EnumCampaignTypeFilter | CampaignType
    goals?: JsonFilter
    targeting?: JsonFilter
    budget?: FloatNullableFilter | number | null
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    ownerId?: StringFilter | string
    projectId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AIAgentUpsertWithWhereUniqueWithoutManagerInput = {
    where: AIAgentWhereUniqueInput
    update: XOR<AIAgentUpdateWithoutManagerInput, AIAgentUncheckedUpdateWithoutManagerInput>
    create: XOR<AIAgentCreateWithoutManagerInput, AIAgentUncheckedCreateWithoutManagerInput>
  }

  export type AIAgentUpdateWithWhereUniqueWithoutManagerInput = {
    where: AIAgentWhereUniqueInput
    data: XOR<AIAgentUpdateWithoutManagerInput, AIAgentUncheckedUpdateWithoutManagerInput>
  }

  export type AIAgentUpdateManyWithWhereWithoutManagerInput = {
    where: AIAgentScalarWhereInput
    data: XOR<AIAgentUpdateManyMutationInput, AIAgentUncheckedUpdateManyWithoutManagedAgentsInput>
  }

  export type AIAgentScalarWhereInput = {
    AND?: Enumerable<AIAgentScalarWhereInput>
    OR?: Enumerable<AIAgentScalarWhereInput>
    NOT?: Enumerable<AIAgentScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    agentType?: EnumAgentTypeFilter | AgentType
    configuration?: JsonFilter
    lastRunAt?: DateTimeNullableFilter | Date | string | null
    nextRunAt?: DateTimeNullableFilter | Date | string | null
    scheduleExpression?: StringNullableFilter | string | null
    scheduleEnabled?: BoolFilter | boolean
    status?: EnumAgentStatusFilter | AgentStatus
    projectId?: StringFilter | string
    managerId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutUserInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutFeedbackInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: Enumerable<FeedbackScalarWhereInput>
    OR?: Enumerable<FeedbackScalarWhereInput>
    NOT?: Enumerable<FeedbackScalarWhereInput>
    id?: StringFilter | string
    channel?: EnumFeedbackChannelFilter | FeedbackChannel
    content?: StringFilter | string
    sentiment?: EnumSentimentFilter | Sentiment
    sourceType?: EnumFeedbackSourceFilter | FeedbackSource
    sourceId?: StringFilter | string
    userId?: StringFilter | string
    contentId?: StringNullableFilter | string | null
    outreachTaskId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type PersonalizationProfileUpsertWithoutUserInput = {
    update: XOR<PersonalizationProfileUpdateWithoutUserInput, PersonalizationProfileUncheckedUpdateWithoutUserInput>
    create: XOR<PersonalizationProfileCreateWithoutUserInput, PersonalizationProfileUncheckedCreateWithoutUserInput>
  }

  export type PersonalizationProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    behaviorCluster?: StringFieldUpdateOperationsInput | string
    interestAffinity?: JsonNullValueInput | InputJsonValue
    engagementScore?: FloatFieldUpdateOperationsInput | number
    contentPreferences?: JsonNullValueInput | InputJsonValue
    activeHours?: NullableJsonNullValueInput | InputJsonValue
    devicePreference?: NullableStringFieldUpdateOperationsInput | string | null
    clickPatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalizationProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    behaviorCluster?: StringFieldUpdateOperationsInput | string
    interestAffinity?: JsonNullValueInput | InputJsonValue
    engagementScore?: FloatFieldUpdateOperationsInput | number
    contentPreferences?: JsonNullValueInput | InputJsonValue
    activeHours?: NullableJsonNullValueInput | InputJsonValue
    devicePreference?: NullableStringFieldUpdateOperationsInput | string | null
    clickPatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutreachTaskUpsertWithWhereUniqueWithoutResponseHandlerInput = {
    where: OutreachTaskWhereUniqueInput
    update: XOR<OutreachTaskUpdateWithoutResponseHandlerInput, OutreachTaskUncheckedUpdateWithoutResponseHandlerInput>
    create: XOR<OutreachTaskCreateWithoutResponseHandlerInput, OutreachTaskUncheckedCreateWithoutResponseHandlerInput>
  }

  export type OutreachTaskUpdateWithWhereUniqueWithoutResponseHandlerInput = {
    where: OutreachTaskWhereUniqueInput
    data: XOR<OutreachTaskUpdateWithoutResponseHandlerInput, OutreachTaskUncheckedUpdateWithoutResponseHandlerInput>
  }

  export type OutreachTaskUpdateManyWithWhereWithoutResponseHandlerInput = {
    where: OutreachTaskScalarWhereInput
    data: XOR<OutreachTaskUpdateManyMutationInput, OutreachTaskUncheckedUpdateManyWithoutOutreachResponsesInput>
  }

  export type OutreachTaskScalarWhereInput = {
    AND?: Enumerable<OutreachTaskScalarWhereInput>
    OR?: Enumerable<OutreachTaskScalarWhereInput>
    NOT?: Enumerable<OutreachTaskScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    outreachType?: EnumOutreachTypeFilter | OutreachType
    status?: EnumOutreachStatusFilter | OutreachStatus
    leadInfo?: JsonFilter
    contactMethod?: EnumContactMethodFilter | ContactMethod
    aiResponse?: StringNullableFilter | string | null
    responseHandlerId?: StringNullableFilter | string | null
    campaignId?: StringFilter | string
    scheduledAt?: DateTimeNullableFilter | Date | string | null
    completedAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type GeneratedContentUpsertWithWhereUniqueWithoutCreatorInput = {
    where: GeneratedContentWhereUniqueInput
    update: XOR<GeneratedContentUpdateWithoutCreatorInput, GeneratedContentUncheckedUpdateWithoutCreatorInput>
    create: XOR<GeneratedContentCreateWithoutCreatorInput, GeneratedContentUncheckedCreateWithoutCreatorInput>
  }

  export type GeneratedContentUpdateWithWhereUniqueWithoutCreatorInput = {
    where: GeneratedContentWhereUniqueInput
    data: XOR<GeneratedContentUpdateWithoutCreatorInput, GeneratedContentUncheckedUpdateWithoutCreatorInput>
  }

  export type GeneratedContentUpdateManyWithWhereWithoutCreatorInput = {
    where: GeneratedContentScalarWhereInput
    data: XOR<GeneratedContentUpdateManyMutationInput, GeneratedContentUncheckedUpdateManyWithoutCreatedContentInput>
  }

  export type GeneratedContentScalarWhereInput = {
    AND?: Enumerable<GeneratedContentScalarWhereInput>
    OR?: Enumerable<GeneratedContentScalarWhereInput>
    NOT?: Enumerable<GeneratedContentScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    content?: StringFilter | string
    contentType?: EnumContentTypeFilter | ContentType
    platform?: EnumPlatformNullableFilter | Platform | null
    status?: EnumContentStatusFilter | ContentStatus
    metadata?: JsonNullableFilter
    agentId?: StringFilter | string
    campaignId?: StringNullableFilter | string | null
    creatorId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntegrationCredentialUpsertWithWhereUniqueWithoutUserInput = {
    where: IntegrationCredentialWhereUniqueInput
    update: XOR<IntegrationCredentialUpdateWithoutUserInput, IntegrationCredentialUncheckedUpdateWithoutUserInput>
    create: XOR<IntegrationCredentialCreateWithoutUserInput, IntegrationCredentialUncheckedCreateWithoutUserInput>
  }

  export type IntegrationCredentialUpdateWithWhereUniqueWithoutUserInput = {
    where: IntegrationCredentialWhereUniqueInput
    data: XOR<IntegrationCredentialUpdateWithoutUserInput, IntegrationCredentialUncheckedUpdateWithoutUserInput>
  }

  export type IntegrationCredentialUpdateManyWithWhereWithoutUserInput = {
    where: IntegrationCredentialScalarWhereInput
    data: XOR<IntegrationCredentialUpdateManyMutationInput, IntegrationCredentialUncheckedUpdateManyWithoutIntegrationCredentialsInput>
  }

  export type IntegrationCredentialScalarWhereInput = {
    AND?: Enumerable<IntegrationCredentialScalarWhereInput>
    OR?: Enumerable<IntegrationCredentialScalarWhereInput>
    NOT?: Enumerable<IntegrationCredentialScalarWhereInput>
    id?: StringFilter | string
    platform?: StringFilter | string
    accountIdentifier?: StringNullableFilter | string | null
    authToken?: StringFilter | string
    refreshToken?: StringNullableFilter | string | null
    tokenType?: StringNullableFilter | string | null
    expiry?: DateTimeNullableFilter | Date | string | null
    scopes?: StringNullableListFilter
    metadata?: JsonNullableFilter
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserCreateWithoutOwnedProjectsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutMembersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    messages?: MessageCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentCreateNestedManyWithoutManagerInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedProjectsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutMembersInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentUncheckedCreateNestedManyWithoutManagerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    messages?: MessageCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentCreateNestedManyWithoutManagerInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentUncheckedCreateNestedManyWithoutManagerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type TaskCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: TaskStatus
    priority?: Priority
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee?: UserCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutCreatedTasksInput
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: TaskStatus
    priority?: Priority
    dueDate?: Date | string | null
    assigneeId?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: Enumerable<TaskCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutProjectInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutProjectInput = {
    id?: string
    content: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutProjectInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutProjectInput, MessageUncheckedCreateWithoutProjectInput>
  }

  export type MessageCreateManyProjectInputEnvelope = {
    data: Enumerable<MessageCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput>
  }

  export type DocumentCreateManyProjectInputEnvelope = {
    data: Enumerable<DocumentCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutCampaignsInput
    agents?: AIAgentCreateNestedManyWithoutCampaignsInput
    generatedContent?: GeneratedContentCreateNestedManyWithoutCampaignInput
    outreachTasks?: OutreachTaskCreateNestedManyWithoutCampaignInput
    metrics?: MetricCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AIAgentUncheckedCreateNestedManyWithoutCampaignsInput
    generatedContent?: GeneratedContentUncheckedCreateNestedManyWithoutCampaignInput
    outreachTasks?: OutreachTaskUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: MetricUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutProjectInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutProjectInput, CampaignUncheckedCreateWithoutProjectInput>
  }

  export type CampaignCreateManyProjectInputEnvelope = {
    data: Enumerable<CampaignCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type AIAgentCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    manager: UserCreateNestedOneWithoutManagedAgentsInput
    generatedContent?: GeneratedContentCreateNestedManyWithoutAgentInput
    campaigns?: CampaignCreateNestedManyWithoutAgentsInput
    trendSignals?: TrendSignalCreateNestedManyWithoutAgentInput
    executionSessions?: AgentExecutionSessionCreateNestedManyWithoutAgentInput
  }

  export type AIAgentUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedContent?: GeneratedContentUncheckedCreateNestedManyWithoutAgentInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutAgentsInput
    trendSignals?: TrendSignalUncheckedCreateNestedManyWithoutAgentInput
    executionSessions?: AgentExecutionSessionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AIAgentCreateOrConnectWithoutProjectInput = {
    where: AIAgentWhereUniqueInput
    create: XOR<AIAgentCreateWithoutProjectInput, AIAgentUncheckedCreateWithoutProjectInput>
  }

  export type AIAgentCreateManyProjectInputEnvelope = {
    data: Enumerable<AIAgentCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type MetricCreateWithoutProjectInput = {
    id?: string
    name: string
    source: string
    value: number
    unit?: string | null
    dimension?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    campaign?: CampaignCreateNestedOneWithoutMetricsInput
  }

  export type MetricUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    source: string
    value: number
    unit?: string | null
    dimension?: string | null
    campaignId?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricCreateOrConnectWithoutProjectInput = {
    where: MetricWhereUniqueInput
    create: XOR<MetricCreateWithoutProjectInput, MetricUncheckedCreateWithoutProjectInput>
  }

  export type MetricCreateManyProjectInputEnvelope = {
    data: Enumerable<MetricCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedProjectsInput = {
    update: XOR<UserUpdateWithoutOwnedProjectsInput, UserUncheckedUpdateWithoutOwnedProjectsInput>
    create: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
  }

  export type UserUpdateWithoutOwnedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutMembersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutMembersNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUncheckedUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutProjectsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutProjectsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateManyWithWhereWithoutProjectsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutMembersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    name?: StringFilter | string
    password?: StringFilter | string
    role?: EnumRoleFilter | Role
    avatar?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutTasksInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutProjectInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutProjectInput, MessageUncheckedUpdateWithoutProjectInput>
    create: XOR<MessageCreateWithoutProjectInput, MessageUncheckedCreateWithoutProjectInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutProjectInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutProjectInput, MessageUncheckedUpdateWithoutProjectInput>
  }

  export type MessageUpdateManyWithWhereWithoutProjectInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutMessagesInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutProjectInput, DocumentUncheckedUpdateWithoutProjectInput>
    create: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutProjectInput, DocumentUncheckedUpdateWithoutProjectInput>
  }

  export type DocumentUpdateManyWithWhereWithoutProjectInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutProjectInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutProjectInput, CampaignUncheckedUpdateWithoutProjectInput>
    create: XOR<CampaignCreateWithoutProjectInput, CampaignUncheckedCreateWithoutProjectInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutProjectInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutProjectInput, CampaignUncheckedUpdateWithoutProjectInput>
  }

  export type CampaignUpdateManyWithWhereWithoutProjectInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type AIAgentUpsertWithWhereUniqueWithoutProjectInput = {
    where: AIAgentWhereUniqueInput
    update: XOR<AIAgentUpdateWithoutProjectInput, AIAgentUncheckedUpdateWithoutProjectInput>
    create: XOR<AIAgentCreateWithoutProjectInput, AIAgentUncheckedCreateWithoutProjectInput>
  }

  export type AIAgentUpdateWithWhereUniqueWithoutProjectInput = {
    where: AIAgentWhereUniqueInput
    data: XOR<AIAgentUpdateWithoutProjectInput, AIAgentUncheckedUpdateWithoutProjectInput>
  }

  export type AIAgentUpdateManyWithWhereWithoutProjectInput = {
    where: AIAgentScalarWhereInput
    data: XOR<AIAgentUpdateManyMutationInput, AIAgentUncheckedUpdateManyWithoutAiAgentsInput>
  }

  export type MetricUpsertWithWhereUniqueWithoutProjectInput = {
    where: MetricWhereUniqueInput
    update: XOR<MetricUpdateWithoutProjectInput, MetricUncheckedUpdateWithoutProjectInput>
    create: XOR<MetricCreateWithoutProjectInput, MetricUncheckedCreateWithoutProjectInput>
  }

  export type MetricUpdateWithWhereUniqueWithoutProjectInput = {
    where: MetricWhereUniqueInput
    data: XOR<MetricUpdateWithoutProjectInput, MetricUncheckedUpdateWithoutProjectInput>
  }

  export type MetricUpdateManyWithWhereWithoutProjectInput = {
    where: MetricScalarWhereInput
    data: XOR<MetricUpdateManyMutationInput, MetricUncheckedUpdateManyWithoutMetricsInput>
  }

  export type MetricScalarWhereInput = {
    AND?: Enumerable<MetricScalarWhereInput>
    OR?: Enumerable<MetricScalarWhereInput>
    NOT?: Enumerable<MetricScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    source?: StringFilter | string
    value?: FloatFilter | number
    unit?: StringNullableFilter | string | null
    dimension?: StringNullableFilter | string | null
    campaignId?: StringNullableFilter | string | null
    projectId?: StringNullableFilter | string | null
    timestamp?: DateTimeFilter | Date | string
    metadata?: JsonNullableFilter
  }

  export type ProjectCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: UserCreateNestedManyWithoutProjectsInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    campaigns?: CampaignCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentCreateNestedManyWithoutProjectInput
    metrics?: MetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutProjectsInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutProjectInput
    metrics?: MetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutTasksInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    messages?: MessageCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentCreateNestedManyWithoutManagerInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentUncheckedCreateNestedManyWithoutManagerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutCreatedTasksInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    messages?: MessageCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentCreateNestedManyWithoutManagerInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedTasksInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentUncheckedCreateNestedManyWithoutManagerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: UserUpdateManyWithoutProjectsNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUpdateManyWithoutProjectNestedInput
    metrics?: MetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutProjectsNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutProjectNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutTasksInput = {
    update: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
  }

  export type UserUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUncheckedUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCreatedTasksInput = {
    update: XOR<UserUpdateWithoutCreatedTasksInput, UserUncheckedUpdateWithoutCreatedTasksInput>
    create: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
  }

  export type UserUpdateWithoutCreatedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUncheckedUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: UserCreateNestedManyWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    campaigns?: CampaignCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentCreateNestedManyWithoutProjectInput
    metrics?: MetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutProjectsInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutProjectInput
    metrics?: MetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMessagesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMessagesInput, ProjectUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentCreateNestedManyWithoutManagerInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentUncheckedCreateNestedManyWithoutManagerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type ProjectUpsertWithoutMessagesInput = {
    update: XOR<ProjectUpdateWithoutMessagesInput, ProjectUncheckedUpdateWithoutMessagesInput>
    create: XOR<ProjectCreateWithoutMessagesInput, ProjectUncheckedCreateWithoutMessagesInput>
  }

  export type ProjectUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: UserUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUpdateManyWithoutProjectNestedInput
    metrics?: MetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutProjectNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUncheckedUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: UserCreateNestedManyWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    campaigns?: CampaignCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentCreateNestedManyWithoutProjectInput
    metrics?: MetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutProjectsInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutProjectInput
    metrics?: MetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDocumentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    messages?: MessageCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentCreateNestedManyWithoutManagerInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentUncheckedCreateNestedManyWithoutManagerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type ProjectUpsertWithoutDocumentsInput = {
    update: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
  }

  export type ProjectUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: UserUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUpdateManyWithoutProjectNestedInput
    metrics?: MetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutProjectNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUncheckedUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutAiAgentsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: UserCreateNestedManyWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    campaigns?: CampaignCreateNestedManyWithoutProjectInput
    metrics?: MetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAiAgentsInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutProjectsInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutProjectInput
    metrics?: MetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAiAgentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAiAgentsInput, ProjectUncheckedCreateWithoutAiAgentsInput>
  }

  export type UserCreateWithoutManagedAgentsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    messages?: MessageCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutOwnerInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutManagedAgentsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOwnerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutManagedAgentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagedAgentsInput, UserUncheckedCreateWithoutManagedAgentsInput>
  }

  export type GeneratedContentCreateWithoutAgentInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutGeneratedContentInput
    creator?: UserCreateNestedOneWithoutCreatedContentInput
    feedback?: FeedbackCreateNestedManyWithoutContent_relInput
  }

  export type GeneratedContentUncheckedCreateWithoutAgentInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: string | null
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feedback?: FeedbackUncheckedCreateNestedManyWithoutContent_relInput
  }

  export type GeneratedContentCreateOrConnectWithoutAgentInput = {
    where: GeneratedContentWhereUniqueInput
    create: XOR<GeneratedContentCreateWithoutAgentInput, GeneratedContentUncheckedCreateWithoutAgentInput>
  }

  export type GeneratedContentCreateManyAgentInputEnvelope = {
    data: Enumerable<GeneratedContentCreateManyAgentInput>
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutAgentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutCampaignsInput
    project: ProjectCreateNestedOneWithoutCampaignsInput
    generatedContent?: GeneratedContentCreateNestedManyWithoutCampaignInput
    outreachTasks?: OutreachTaskCreateNestedManyWithoutCampaignInput
    metrics?: MetricCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutAgentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    ownerId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedContent?: GeneratedContentUncheckedCreateNestedManyWithoutCampaignInput
    outreachTasks?: OutreachTaskUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: MetricUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutAgentsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutAgentsInput, CampaignUncheckedCreateWithoutAgentsInput>
  }

  export type TrendSignalCreateWithoutAgentInput = {
    id?: string
    title: string
    description: string
    source: string
    signalType: SignalType
    confidence: number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    impact?: TrendImpact
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrendSignalUncheckedCreateWithoutAgentInput = {
    id?: string
    title: string
    description: string
    source: string
    signalType: SignalType
    confidence: number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    impact?: TrendImpact
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrendSignalCreateOrConnectWithoutAgentInput = {
    where: TrendSignalWhereUniqueInput
    create: XOR<TrendSignalCreateWithoutAgentInput, TrendSignalUncheckedCreateWithoutAgentInput>
  }

  export type TrendSignalCreateManyAgentInputEnvelope = {
    data: Enumerable<TrendSignalCreateManyAgentInput>
    skipDuplicates?: boolean
  }

  export type AgentExecutionSessionCreateWithoutAgentInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    success?: boolean | null
    duration?: number | null
    outputSummary?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AgentExecutionSessionUncheckedCreateWithoutAgentInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    success?: boolean | null
    duration?: number | null
    outputSummary?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AgentExecutionSessionCreateOrConnectWithoutAgentInput = {
    where: AgentExecutionSessionWhereUniqueInput
    create: XOR<AgentExecutionSessionCreateWithoutAgentInput, AgentExecutionSessionUncheckedCreateWithoutAgentInput>
  }

  export type AgentExecutionSessionCreateManyAgentInputEnvelope = {
    data: Enumerable<AgentExecutionSessionCreateManyAgentInput>
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutAiAgentsInput = {
    update: XOR<ProjectUpdateWithoutAiAgentsInput, ProjectUncheckedUpdateWithoutAiAgentsInput>
    create: XOR<ProjectCreateWithoutAiAgentsInput, ProjectUncheckedCreateWithoutAiAgentsInput>
  }

  export type ProjectUpdateWithoutAiAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: UserUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUpdateManyWithoutProjectNestedInput
    metrics?: MetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAiAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutProjectNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutManagedAgentsInput = {
    update: XOR<UserUpdateWithoutManagedAgentsInput, UserUncheckedUpdateWithoutManagedAgentsInput>
    create: XOR<UserCreateWithoutManagedAgentsInput, UserUncheckedCreateWithoutManagedAgentsInput>
  }

  export type UserUpdateWithoutManagedAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutOwnerNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutManagedAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOwnerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GeneratedContentUpsertWithWhereUniqueWithoutAgentInput = {
    where: GeneratedContentWhereUniqueInput
    update: XOR<GeneratedContentUpdateWithoutAgentInput, GeneratedContentUncheckedUpdateWithoutAgentInput>
    create: XOR<GeneratedContentCreateWithoutAgentInput, GeneratedContentUncheckedCreateWithoutAgentInput>
  }

  export type GeneratedContentUpdateWithWhereUniqueWithoutAgentInput = {
    where: GeneratedContentWhereUniqueInput
    data: XOR<GeneratedContentUpdateWithoutAgentInput, GeneratedContentUncheckedUpdateWithoutAgentInput>
  }

  export type GeneratedContentUpdateManyWithWhereWithoutAgentInput = {
    where: GeneratedContentScalarWhereInput
    data: XOR<GeneratedContentUpdateManyMutationInput, GeneratedContentUncheckedUpdateManyWithoutGeneratedContentInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutAgentsInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutAgentsInput, CampaignUncheckedUpdateWithoutAgentsInput>
    create: XOR<CampaignCreateWithoutAgentsInput, CampaignUncheckedCreateWithoutAgentsInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutAgentsInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutAgentsInput, CampaignUncheckedUpdateWithoutAgentsInput>
  }

  export type CampaignUpdateManyWithWhereWithoutAgentsInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type TrendSignalUpsertWithWhereUniqueWithoutAgentInput = {
    where: TrendSignalWhereUniqueInput
    update: XOR<TrendSignalUpdateWithoutAgentInput, TrendSignalUncheckedUpdateWithoutAgentInput>
    create: XOR<TrendSignalCreateWithoutAgentInput, TrendSignalUncheckedCreateWithoutAgentInput>
  }

  export type TrendSignalUpdateWithWhereUniqueWithoutAgentInput = {
    where: TrendSignalWhereUniqueInput
    data: XOR<TrendSignalUpdateWithoutAgentInput, TrendSignalUncheckedUpdateWithoutAgentInput>
  }

  export type TrendSignalUpdateManyWithWhereWithoutAgentInput = {
    where: TrendSignalScalarWhereInput
    data: XOR<TrendSignalUpdateManyMutationInput, TrendSignalUncheckedUpdateManyWithoutTrendSignalsInput>
  }

  export type TrendSignalScalarWhereInput = {
    AND?: Enumerable<TrendSignalScalarWhereInput>
    OR?: Enumerable<TrendSignalScalarWhereInput>
    NOT?: Enumerable<TrendSignalScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringFilter | string
    source?: StringFilter | string
    signalType?: EnumSignalTypeFilter | SignalType
    confidence?: FloatFilter | number
    rawData?: JsonNullableFilter
    impact?: EnumTrendImpactFilter | TrendImpact
    agentId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AgentExecutionSessionUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentExecutionSessionWhereUniqueInput
    update: XOR<AgentExecutionSessionUpdateWithoutAgentInput, AgentExecutionSessionUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentExecutionSessionCreateWithoutAgentInput, AgentExecutionSessionUncheckedCreateWithoutAgentInput>
  }

  export type AgentExecutionSessionUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentExecutionSessionWhereUniqueInput
    data: XOR<AgentExecutionSessionUpdateWithoutAgentInput, AgentExecutionSessionUncheckedUpdateWithoutAgentInput>
  }

  export type AgentExecutionSessionUpdateManyWithWhereWithoutAgentInput = {
    where: AgentExecutionSessionScalarWhereInput
    data: XOR<AgentExecutionSessionUpdateManyMutationInput, AgentExecutionSessionUncheckedUpdateManyWithoutExecutionSessionsInput>
  }

  export type AgentExecutionSessionScalarWhereInput = {
    AND?: Enumerable<AgentExecutionSessionScalarWhereInput>
    OR?: Enumerable<AgentExecutionSessionScalarWhereInput>
    NOT?: Enumerable<AgentExecutionSessionScalarWhereInput>
    id?: StringFilter | string
    agentId?: StringFilter | string
    startedAt?: DateTimeFilter | Date | string
    completedAt?: DateTimeNullableFilter | Date | string | null
    success?: BoolNullableFilter | boolean | null
    duration?: IntNullableFilter | number | null
    outputSummary?: StringNullableFilter | string | null
    logs?: JsonNullableFilter
    context?: JsonNullableFilter
    metrics?: JsonNullableFilter
    errorMessage?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type AIAgentCreateWithoutExecutionSessionsInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAiAgentsInput
    manager: UserCreateNestedOneWithoutManagedAgentsInput
    generatedContent?: GeneratedContentCreateNestedManyWithoutAgentInput
    campaigns?: CampaignCreateNestedManyWithoutAgentsInput
    trendSignals?: TrendSignalCreateNestedManyWithoutAgentInput
  }

  export type AIAgentUncheckedCreateWithoutExecutionSessionsInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    projectId: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedContent?: GeneratedContentUncheckedCreateNestedManyWithoutAgentInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutAgentsInput
    trendSignals?: TrendSignalUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AIAgentCreateOrConnectWithoutExecutionSessionsInput = {
    where: AIAgentWhereUniqueInput
    create: XOR<AIAgentCreateWithoutExecutionSessionsInput, AIAgentUncheckedCreateWithoutExecutionSessionsInput>
  }

  export type AIAgentUpsertWithoutExecutionSessionsInput = {
    update: XOR<AIAgentUpdateWithoutExecutionSessionsInput, AIAgentUncheckedUpdateWithoutExecutionSessionsInput>
    create: XOR<AIAgentCreateWithoutExecutionSessionsInput, AIAgentUncheckedCreateWithoutExecutionSessionsInput>
  }

  export type AIAgentUpdateWithoutExecutionSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAiAgentsNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedAgentsNestedInput
    generatedContent?: GeneratedContentUpdateManyWithoutAgentNestedInput
    campaigns?: CampaignUpdateManyWithoutAgentsNestedInput
    trendSignals?: TrendSignalUpdateManyWithoutAgentNestedInput
  }

  export type AIAgentUncheckedUpdateWithoutExecutionSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    projectId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedContent?: GeneratedContentUncheckedUpdateManyWithoutAgentNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutAgentsNestedInput
    trendSignals?: TrendSignalUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserCreateWithoutCampaignsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    messages?: MessageCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    managedAgents?: AIAgentCreateNestedManyWithoutManagerInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCampaignsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    managedAgents?: AIAgentUncheckedCreateNestedManyWithoutManagerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
  }

  export type ProjectCreateWithoutCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: UserCreateNestedManyWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentCreateNestedManyWithoutProjectInput
    metrics?: MetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutProjectsInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutProjectInput
    metrics?: MetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCampaignsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCampaignsInput, ProjectUncheckedCreateWithoutCampaignsInput>
  }

  export type AIAgentCreateWithoutCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAiAgentsInput
    manager: UserCreateNestedOneWithoutManagedAgentsInput
    generatedContent?: GeneratedContentCreateNestedManyWithoutAgentInput
    trendSignals?: TrendSignalCreateNestedManyWithoutAgentInput
    executionSessions?: AgentExecutionSessionCreateNestedManyWithoutAgentInput
  }

  export type AIAgentUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    projectId: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedContent?: GeneratedContentUncheckedCreateNestedManyWithoutAgentInput
    trendSignals?: TrendSignalUncheckedCreateNestedManyWithoutAgentInput
    executionSessions?: AgentExecutionSessionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AIAgentCreateOrConnectWithoutCampaignsInput = {
    where: AIAgentWhereUniqueInput
    create: XOR<AIAgentCreateWithoutCampaignsInput, AIAgentUncheckedCreateWithoutCampaignsInput>
  }

  export type GeneratedContentCreateWithoutCampaignInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AIAgentCreateNestedOneWithoutGeneratedContentInput
    creator?: UserCreateNestedOneWithoutCreatedContentInput
    feedback?: FeedbackCreateNestedManyWithoutContent_relInput
  }

  export type GeneratedContentUncheckedCreateWithoutCampaignInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    agentId: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feedback?: FeedbackUncheckedCreateNestedManyWithoutContent_relInput
  }

  export type GeneratedContentCreateOrConnectWithoutCampaignInput = {
    where: GeneratedContentWhereUniqueInput
    create: XOR<GeneratedContentCreateWithoutCampaignInput, GeneratedContentUncheckedCreateWithoutCampaignInput>
  }

  export type GeneratedContentCreateManyCampaignInputEnvelope = {
    data: Enumerable<GeneratedContentCreateManyCampaignInput>
    skipDuplicates?: boolean
  }

  export type OutreachTaskCreateWithoutCampaignInput = {
    id?: string
    title: string
    description?: string | null
    outreachType: OutreachType
    status?: OutreachStatus
    leadInfo: JsonNullValueInput | InputJsonValue
    contactMethod: ContactMethod
    aiResponse?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responseHandler?: UserCreateNestedOneWithoutOutreachResponsesInput
    feedback?: FeedbackCreateNestedManyWithoutOutreachTaskInput
  }

  export type OutreachTaskUncheckedCreateWithoutCampaignInput = {
    id?: string
    title: string
    description?: string | null
    outreachType: OutreachType
    status?: OutreachStatus
    leadInfo: JsonNullValueInput | InputJsonValue
    contactMethod: ContactMethod
    aiResponse?: string | null
    responseHandlerId?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feedback?: FeedbackUncheckedCreateNestedManyWithoutOutreachTaskInput
  }

  export type OutreachTaskCreateOrConnectWithoutCampaignInput = {
    where: OutreachTaskWhereUniqueInput
    create: XOR<OutreachTaskCreateWithoutCampaignInput, OutreachTaskUncheckedCreateWithoutCampaignInput>
  }

  export type OutreachTaskCreateManyCampaignInputEnvelope = {
    data: Enumerable<OutreachTaskCreateManyCampaignInput>
    skipDuplicates?: boolean
  }

  export type MetricCreateWithoutCampaignInput = {
    id?: string
    name: string
    source: string
    value: number
    unit?: string | null
    dimension?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectCreateNestedOneWithoutMetricsInput
  }

  export type MetricUncheckedCreateWithoutCampaignInput = {
    id?: string
    name: string
    source: string
    value: number
    unit?: string | null
    dimension?: string | null
    projectId?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricCreateOrConnectWithoutCampaignInput = {
    where: MetricWhereUniqueInput
    create: XOR<MetricCreateWithoutCampaignInput, MetricUncheckedCreateWithoutCampaignInput>
  }

  export type MetricCreateManyCampaignInputEnvelope = {
    data: Enumerable<MetricCreateManyCampaignInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCampaignsInput = {
    update: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
  }

  export type UserUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    managedAgents?: AIAgentUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    managedAgents?: AIAgentUncheckedUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutCampaignsInput = {
    update: XOR<ProjectUpdateWithoutCampaignsInput, ProjectUncheckedUpdateWithoutCampaignsInput>
    create: XOR<ProjectCreateWithoutCampaignsInput, ProjectUncheckedCreateWithoutCampaignsInput>
  }

  export type ProjectUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: UserUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUpdateManyWithoutProjectNestedInput
    metrics?: MetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutProjectNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AIAgentUpsertWithWhereUniqueWithoutCampaignsInput = {
    where: AIAgentWhereUniqueInput
    update: XOR<AIAgentUpdateWithoutCampaignsInput, AIAgentUncheckedUpdateWithoutCampaignsInput>
    create: XOR<AIAgentCreateWithoutCampaignsInput, AIAgentUncheckedCreateWithoutCampaignsInput>
  }

  export type AIAgentUpdateWithWhereUniqueWithoutCampaignsInput = {
    where: AIAgentWhereUniqueInput
    data: XOR<AIAgentUpdateWithoutCampaignsInput, AIAgentUncheckedUpdateWithoutCampaignsInput>
  }

  export type AIAgentUpdateManyWithWhereWithoutCampaignsInput = {
    where: AIAgentScalarWhereInput
    data: XOR<AIAgentUpdateManyMutationInput, AIAgentUncheckedUpdateManyWithoutAgentsInput>
  }

  export type GeneratedContentUpsertWithWhereUniqueWithoutCampaignInput = {
    where: GeneratedContentWhereUniqueInput
    update: XOR<GeneratedContentUpdateWithoutCampaignInput, GeneratedContentUncheckedUpdateWithoutCampaignInput>
    create: XOR<GeneratedContentCreateWithoutCampaignInput, GeneratedContentUncheckedCreateWithoutCampaignInput>
  }

  export type GeneratedContentUpdateWithWhereUniqueWithoutCampaignInput = {
    where: GeneratedContentWhereUniqueInput
    data: XOR<GeneratedContentUpdateWithoutCampaignInput, GeneratedContentUncheckedUpdateWithoutCampaignInput>
  }

  export type GeneratedContentUpdateManyWithWhereWithoutCampaignInput = {
    where: GeneratedContentScalarWhereInput
    data: XOR<GeneratedContentUpdateManyMutationInput, GeneratedContentUncheckedUpdateManyWithoutGeneratedContentInput>
  }

  export type OutreachTaskUpsertWithWhereUniqueWithoutCampaignInput = {
    where: OutreachTaskWhereUniqueInput
    update: XOR<OutreachTaskUpdateWithoutCampaignInput, OutreachTaskUncheckedUpdateWithoutCampaignInput>
    create: XOR<OutreachTaskCreateWithoutCampaignInput, OutreachTaskUncheckedCreateWithoutCampaignInput>
  }

  export type OutreachTaskUpdateWithWhereUniqueWithoutCampaignInput = {
    where: OutreachTaskWhereUniqueInput
    data: XOR<OutreachTaskUpdateWithoutCampaignInput, OutreachTaskUncheckedUpdateWithoutCampaignInput>
  }

  export type OutreachTaskUpdateManyWithWhereWithoutCampaignInput = {
    where: OutreachTaskScalarWhereInput
    data: XOR<OutreachTaskUpdateManyMutationInput, OutreachTaskUncheckedUpdateManyWithoutOutreachTasksInput>
  }

  export type MetricUpsertWithWhereUniqueWithoutCampaignInput = {
    where: MetricWhereUniqueInput
    update: XOR<MetricUpdateWithoutCampaignInput, MetricUncheckedUpdateWithoutCampaignInput>
    create: XOR<MetricCreateWithoutCampaignInput, MetricUncheckedCreateWithoutCampaignInput>
  }

  export type MetricUpdateWithWhereUniqueWithoutCampaignInput = {
    where: MetricWhereUniqueInput
    data: XOR<MetricUpdateWithoutCampaignInput, MetricUncheckedUpdateWithoutCampaignInput>
  }

  export type MetricUpdateManyWithWhereWithoutCampaignInput = {
    where: MetricScalarWhereInput
    data: XOR<MetricUpdateManyMutationInput, MetricUncheckedUpdateManyWithoutMetricsInput>
  }

  export type AIAgentCreateWithoutGeneratedContentInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAiAgentsInput
    manager: UserCreateNestedOneWithoutManagedAgentsInput
    campaigns?: CampaignCreateNestedManyWithoutAgentsInput
    trendSignals?: TrendSignalCreateNestedManyWithoutAgentInput
    executionSessions?: AgentExecutionSessionCreateNestedManyWithoutAgentInput
  }

  export type AIAgentUncheckedCreateWithoutGeneratedContentInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    projectId: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutAgentsInput
    trendSignals?: TrendSignalUncheckedCreateNestedManyWithoutAgentInput
    executionSessions?: AgentExecutionSessionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AIAgentCreateOrConnectWithoutGeneratedContentInput = {
    where: AIAgentWhereUniqueInput
    create: XOR<AIAgentCreateWithoutGeneratedContentInput, AIAgentUncheckedCreateWithoutGeneratedContentInput>
  }

  export type CampaignCreateWithoutGeneratedContentInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutCampaignsInput
    project: ProjectCreateNestedOneWithoutCampaignsInput
    agents?: AIAgentCreateNestedManyWithoutCampaignsInput
    outreachTasks?: OutreachTaskCreateNestedManyWithoutCampaignInput
    metrics?: MetricCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutGeneratedContentInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    ownerId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AIAgentUncheckedCreateNestedManyWithoutCampaignsInput
    outreachTasks?: OutreachTaskUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: MetricUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutGeneratedContentInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutGeneratedContentInput, CampaignUncheckedCreateWithoutGeneratedContentInput>
  }

  export type UserCreateWithoutCreatedContentInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    messages?: MessageCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentCreateNestedManyWithoutManagerInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskCreateNestedManyWithoutResponseHandlerInput
    integrationCredentials?: IntegrationCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedContentInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentUncheckedCreateNestedManyWithoutManagerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput
    integrationCredentials?: IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedContentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedContentInput, UserUncheckedCreateWithoutCreatedContentInput>
  }

  export type FeedbackCreateWithoutContent_relInput = {
    id?: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFeedbackInput
    outreachTask?: OutreachTaskCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutContent_relInput = {
    id?: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    userId: string
    outreachTaskId?: string | null
    createdAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutContent_relInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutContent_relInput, FeedbackUncheckedCreateWithoutContent_relInput>
  }

  export type FeedbackCreateManyContent_relInputEnvelope = {
    data: Enumerable<FeedbackCreateManyContent_relInput>
    skipDuplicates?: boolean
  }

  export type AIAgentUpsertWithoutGeneratedContentInput = {
    update: XOR<AIAgentUpdateWithoutGeneratedContentInput, AIAgentUncheckedUpdateWithoutGeneratedContentInput>
    create: XOR<AIAgentCreateWithoutGeneratedContentInput, AIAgentUncheckedCreateWithoutGeneratedContentInput>
  }

  export type AIAgentUpdateWithoutGeneratedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAiAgentsNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedAgentsNestedInput
    campaigns?: CampaignUpdateManyWithoutAgentsNestedInput
    trendSignals?: TrendSignalUpdateManyWithoutAgentNestedInput
    executionSessions?: AgentExecutionSessionUpdateManyWithoutAgentNestedInput
  }

  export type AIAgentUncheckedUpdateWithoutGeneratedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    projectId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutAgentsNestedInput
    trendSignals?: TrendSignalUncheckedUpdateManyWithoutAgentNestedInput
    executionSessions?: AgentExecutionSessionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type CampaignUpsertWithoutGeneratedContentInput = {
    update: XOR<CampaignUpdateWithoutGeneratedContentInput, CampaignUncheckedUpdateWithoutGeneratedContentInput>
    create: XOR<CampaignCreateWithoutGeneratedContentInput, CampaignUncheckedCreateWithoutGeneratedContentInput>
  }

  export type CampaignUpdateWithoutGeneratedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    project?: ProjectUpdateOneRequiredWithoutCampaignsNestedInput
    agents?: AIAgentUpdateManyWithoutCampaignsNestedInput
    outreachTasks?: OutreachTaskUpdateManyWithoutCampaignNestedInput
    metrics?: MetricUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutGeneratedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AIAgentUncheckedUpdateManyWithoutCampaignsNestedInput
    outreachTasks?: OutreachTaskUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserUpsertWithoutCreatedContentInput = {
    update: XOR<UserUpdateWithoutCreatedContentInput, UserUncheckedUpdateWithoutCreatedContentInput>
    create: XOR<UserCreateWithoutCreatedContentInput, UserUncheckedCreateWithoutCreatedContentInput>
  }

  export type UserUpdateWithoutCreatedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUpdateManyWithoutResponseHandlerNestedInput
    integrationCredentials?: IntegrationCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUncheckedUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput
    integrationCredentials?: IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FeedbackUpsertWithWhereUniqueWithoutContent_relInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutContent_relInput, FeedbackUncheckedUpdateWithoutContent_relInput>
    create: XOR<FeedbackCreateWithoutContent_relInput, FeedbackUncheckedCreateWithoutContent_relInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutContent_relInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutContent_relInput, FeedbackUncheckedUpdateWithoutContent_relInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutContent_relInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutFeedbackInput>
  }

  export type UserCreateWithoutOutreachResponsesInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    messages?: MessageCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentCreateNestedManyWithoutManagerInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileCreateNestedOneWithoutUserInput
    createdContent?: GeneratedContentCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOutreachResponsesInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentUncheckedCreateNestedManyWithoutManagerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput
    createdContent?: GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOutreachResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOutreachResponsesInput, UserUncheckedCreateWithoutOutreachResponsesInput>
  }

  export type CampaignCreateWithoutOutreachTasksInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutCampaignsInput
    project: ProjectCreateNestedOneWithoutCampaignsInput
    agents?: AIAgentCreateNestedManyWithoutCampaignsInput
    generatedContent?: GeneratedContentCreateNestedManyWithoutCampaignInput
    metrics?: MetricCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutOutreachTasksInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    ownerId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AIAgentUncheckedCreateNestedManyWithoutCampaignsInput
    generatedContent?: GeneratedContentUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: MetricUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutOutreachTasksInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutOutreachTasksInput, CampaignUncheckedCreateWithoutOutreachTasksInput>
  }

  export type FeedbackCreateWithoutOutreachTaskInput = {
    id?: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFeedbackInput
    content_rel?: GeneratedContentCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutOutreachTaskInput = {
    id?: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    userId: string
    contentId?: string | null
    createdAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutOutreachTaskInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutOutreachTaskInput, FeedbackUncheckedCreateWithoutOutreachTaskInput>
  }

  export type FeedbackCreateManyOutreachTaskInputEnvelope = {
    data: Enumerable<FeedbackCreateManyOutreachTaskInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOutreachResponsesInput = {
    update: XOR<UserUpdateWithoutOutreachResponsesInput, UserUncheckedUpdateWithoutOutreachResponsesInput>
    create: XOR<UserCreateWithoutOutreachResponsesInput, UserUncheckedCreateWithoutOutreachResponsesInput>
  }

  export type UserUpdateWithoutOutreachResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUpdateOneWithoutUserNestedInput
    createdContent?: GeneratedContentUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOutreachResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUncheckedUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput
    createdContent?: GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignUpsertWithoutOutreachTasksInput = {
    update: XOR<CampaignUpdateWithoutOutreachTasksInput, CampaignUncheckedUpdateWithoutOutreachTasksInput>
    create: XOR<CampaignCreateWithoutOutreachTasksInput, CampaignUncheckedCreateWithoutOutreachTasksInput>
  }

  export type CampaignUpdateWithoutOutreachTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    project?: ProjectUpdateOneRequiredWithoutCampaignsNestedInput
    agents?: AIAgentUpdateManyWithoutCampaignsNestedInput
    generatedContent?: GeneratedContentUpdateManyWithoutCampaignNestedInput
    metrics?: MetricUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutOutreachTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AIAgentUncheckedUpdateManyWithoutCampaignsNestedInput
    generatedContent?: GeneratedContentUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type FeedbackUpsertWithWhereUniqueWithoutOutreachTaskInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutOutreachTaskInput, FeedbackUncheckedUpdateWithoutOutreachTaskInput>
    create: XOR<FeedbackCreateWithoutOutreachTaskInput, FeedbackUncheckedCreateWithoutOutreachTaskInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutOutreachTaskInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutOutreachTaskInput, FeedbackUncheckedUpdateWithoutOutreachTaskInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutOutreachTaskInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutFeedbackInput>
  }

  export type AIAgentCreateWithoutTrendSignalsInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAiAgentsInput
    manager: UserCreateNestedOneWithoutManagedAgentsInput
    generatedContent?: GeneratedContentCreateNestedManyWithoutAgentInput
    campaigns?: CampaignCreateNestedManyWithoutAgentsInput
    executionSessions?: AgentExecutionSessionCreateNestedManyWithoutAgentInput
  }

  export type AIAgentUncheckedCreateWithoutTrendSignalsInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    projectId: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedContent?: GeneratedContentUncheckedCreateNestedManyWithoutAgentInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutAgentsInput
    executionSessions?: AgentExecutionSessionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AIAgentCreateOrConnectWithoutTrendSignalsInput = {
    where: AIAgentWhereUniqueInput
    create: XOR<AIAgentCreateWithoutTrendSignalsInput, AIAgentUncheckedCreateWithoutTrendSignalsInput>
  }

  export type AIAgentUpsertWithoutTrendSignalsInput = {
    update: XOR<AIAgentUpdateWithoutTrendSignalsInput, AIAgentUncheckedUpdateWithoutTrendSignalsInput>
    create: XOR<AIAgentCreateWithoutTrendSignalsInput, AIAgentUncheckedCreateWithoutTrendSignalsInput>
  }

  export type AIAgentUpdateWithoutTrendSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAiAgentsNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedAgentsNestedInput
    generatedContent?: GeneratedContentUpdateManyWithoutAgentNestedInput
    campaigns?: CampaignUpdateManyWithoutAgentsNestedInput
    executionSessions?: AgentExecutionSessionUpdateManyWithoutAgentNestedInput
  }

  export type AIAgentUncheckedUpdateWithoutTrendSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    projectId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedContent?: GeneratedContentUncheckedUpdateManyWithoutAgentNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutAgentsNestedInput
    executionSessions?: AgentExecutionSessionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserCreateWithoutIntegrationCredentialsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    messages?: MessageCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentCreateNestedManyWithoutManagerInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutIntegrationCredentialsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentUncheckedCreateNestedManyWithoutManagerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    personalizationProfile?: PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutIntegrationCredentialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIntegrationCredentialsInput, UserUncheckedCreateWithoutIntegrationCredentialsInput>
  }

  export type UserUpsertWithoutIntegrationCredentialsInput = {
    update: XOR<UserUpdateWithoutIntegrationCredentialsInput, UserUncheckedUpdateWithoutIntegrationCredentialsInput>
    create: XOR<UserCreateWithoutIntegrationCredentialsInput, UserUncheckedCreateWithoutIntegrationCredentialsInput>
  }

  export type UserUpdateWithoutIntegrationCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutIntegrationCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUncheckedUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CampaignCreateWithoutMetricsInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutCampaignsInput
    project: ProjectCreateNestedOneWithoutCampaignsInput
    agents?: AIAgentCreateNestedManyWithoutCampaignsInput
    generatedContent?: GeneratedContentCreateNestedManyWithoutCampaignInput
    outreachTasks?: OutreachTaskCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutMetricsInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    ownerId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AIAgentUncheckedCreateNestedManyWithoutCampaignsInput
    generatedContent?: GeneratedContentUncheckedCreateNestedManyWithoutCampaignInput
    outreachTasks?: OutreachTaskUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMetricsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
  }

  export type ProjectCreateWithoutMetricsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: UserCreateNestedManyWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    campaigns?: CampaignCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMetricsInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutProjectsInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutProjectInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMetricsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMetricsInput, ProjectUncheckedCreateWithoutMetricsInput>
  }

  export type CampaignUpsertWithoutMetricsInput = {
    update: XOR<CampaignUpdateWithoutMetricsInput, CampaignUncheckedUpdateWithoutMetricsInput>
    create: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
  }

  export type CampaignUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    project?: ProjectUpdateOneRequiredWithoutCampaignsNestedInput
    agents?: AIAgentUpdateManyWithoutCampaignsNestedInput
    generatedContent?: GeneratedContentUpdateManyWithoutCampaignNestedInput
    outreachTasks?: OutreachTaskUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AIAgentUncheckedUpdateManyWithoutCampaignsNestedInput
    generatedContent?: GeneratedContentUncheckedUpdateManyWithoutCampaignNestedInput
    outreachTasks?: OutreachTaskUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type ProjectUpsertWithoutMetricsInput = {
    update: XOR<ProjectUpdateWithoutMetricsInput, ProjectUncheckedUpdateWithoutMetricsInput>
    create: XOR<ProjectCreateWithoutMetricsInput, ProjectUncheckedCreateWithoutMetricsInput>
  }

  export type ProjectUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: UserUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutPersonalizationProfileInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    messages?: MessageCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentCreateNestedManyWithoutManagerInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    outreachResponses?: OutreachTaskCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPersonalizationProfileInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentUncheckedCreateNestedManyWithoutManagerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    outreachResponses?: OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPersonalizationProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonalizationProfileInput, UserUncheckedCreateWithoutPersonalizationProfileInput>
  }

  export type UserUpsertWithoutPersonalizationProfileInput = {
    update: XOR<UserUpdateWithoutPersonalizationProfileInput, UserUncheckedUpdateWithoutPersonalizationProfileInput>
    create: XOR<UserCreateWithoutPersonalizationProfileInput, UserUncheckedCreateWithoutPersonalizationProfileInput>
  }

  export type UserUpdateWithoutPersonalizationProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    outreachResponses?: OutreachTaskUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonalizationProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUncheckedUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    outreachResponses?: OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFeedbackInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    messages?: MessageCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentCreateNestedManyWithoutManagerInput
    personalizationProfile?: PersonalizationProfileCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbackInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: Role
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutMembersInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOwnerInput
    managedAgents?: AIAgentUncheckedCreateNestedManyWithoutManagerInput
    personalizationProfile?: PersonalizationProfileUncheckedCreateNestedOneWithoutUserInput
    outreachResponses?: OutreachTaskUncheckedCreateNestedManyWithoutResponseHandlerInput
    createdContent?: GeneratedContentUncheckedCreateNestedManyWithoutCreatorInput
    integrationCredentials?: IntegrationCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbackInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
  }

  export type GeneratedContentCreateWithoutFeedbackInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AIAgentCreateNestedOneWithoutGeneratedContentInput
    campaign?: CampaignCreateNestedOneWithoutGeneratedContentInput
    creator?: UserCreateNestedOneWithoutCreatedContentInput
  }

  export type GeneratedContentUncheckedCreateWithoutFeedbackInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    agentId: string
    campaignId?: string | null
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GeneratedContentCreateOrConnectWithoutFeedbackInput = {
    where: GeneratedContentWhereUniqueInput
    create: XOR<GeneratedContentCreateWithoutFeedbackInput, GeneratedContentUncheckedCreateWithoutFeedbackInput>
  }

  export type OutreachTaskCreateWithoutFeedbackInput = {
    id?: string
    title: string
    description?: string | null
    outreachType: OutreachType
    status?: OutreachStatus
    leadInfo: JsonNullValueInput | InputJsonValue
    contactMethod: ContactMethod
    aiResponse?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responseHandler?: UserCreateNestedOneWithoutOutreachResponsesInput
    campaign: CampaignCreateNestedOneWithoutOutreachTasksInput
  }

  export type OutreachTaskUncheckedCreateWithoutFeedbackInput = {
    id?: string
    title: string
    description?: string | null
    outreachType: OutreachType
    status?: OutreachStatus
    leadInfo: JsonNullValueInput | InputJsonValue
    contactMethod: ContactMethod
    aiResponse?: string | null
    responseHandlerId?: string | null
    campaignId: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutreachTaskCreateOrConnectWithoutFeedbackInput = {
    where: OutreachTaskWhereUniqueInput
    create: XOR<OutreachTaskCreateWithoutFeedbackInput, OutreachTaskUncheckedCreateWithoutFeedbackInput>
  }

  export type UserUpsertWithoutFeedbackInput = {
    update: XOR<UserUpdateWithoutFeedbackInput, UserUncheckedUpdateWithoutFeedbackInput>
    create: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
  }

  export type UserUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUpdateManyWithoutManagerNestedInput
    personalizationProfile?: PersonalizationProfileUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutMembersNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUncheckedUpdateManyWithoutManagerNestedInput
    personalizationProfile?: PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GeneratedContentUpsertWithoutFeedbackInput = {
    update: XOR<GeneratedContentUpdateWithoutFeedbackInput, GeneratedContentUncheckedUpdateWithoutFeedbackInput>
    create: XOR<GeneratedContentCreateWithoutFeedbackInput, GeneratedContentUncheckedCreateWithoutFeedbackInput>
  }

  export type GeneratedContentUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AIAgentUpdateOneRequiredWithoutGeneratedContentNestedInput
    campaign?: CampaignUpdateOneWithoutGeneratedContentNestedInput
    creator?: UserUpdateOneWithoutCreatedContentNestedInput
  }

  export type GeneratedContentUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    agentId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutreachTaskUpsertWithoutFeedbackInput = {
    update: XOR<OutreachTaskUpdateWithoutFeedbackInput, OutreachTaskUncheckedUpdateWithoutFeedbackInput>
    create: XOR<OutreachTaskCreateWithoutFeedbackInput, OutreachTaskUncheckedCreateWithoutFeedbackInput>
  }

  export type OutreachTaskUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    outreachType?: EnumOutreachTypeFieldUpdateOperationsInput | OutreachType
    status?: EnumOutreachStatusFieldUpdateOperationsInput | OutreachStatus
    leadInfo?: JsonNullValueInput | InputJsonValue
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseHandler?: UserUpdateOneWithoutOutreachResponsesNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutOutreachTasksNestedInput
  }

  export type OutreachTaskUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    outreachType?: EnumOutreachTypeFieldUpdateOperationsInput | OutreachType
    status?: EnumOutreachStatusFieldUpdateOperationsInput | OutreachStatus
    leadInfo?: JsonNullValueInput | InputJsonValue
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    responseHandlerId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: TaskStatus
    priority?: Priority
    dueDate?: Date | string | null
    projectId: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: TaskStatus
    priority?: Priority
    dueDate?: Date | string | null
    projectId: string
    assigneeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyUserInput = {
    id?: string
    content: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIAgentCreateManyManagerInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackCreateManyUserInput = {
    id?: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    contentId?: string | null
    outreachTaskId?: string | null
    createdAt?: Date | string
  }

  export type OutreachTaskCreateManyResponseHandlerInput = {
    id?: string
    title: string
    description?: string | null
    outreachType: OutreachType
    status?: OutreachStatus
    leadInfo: JsonNullValueInput | InputJsonValue
    contactMethod: ContactMethod
    aiResponse?: string | null
    campaignId: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GeneratedContentCreateManyCreatorInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    agentId: string
    campaignId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCredentialCreateManyUserInput = {
    id?: string
    platform: string
    accountIdentifier?: string | null
    authToken: string
    refreshToken?: string | null
    tokenType?: string | null
    expiry?: Date | string | null
    scopes?: IntegrationCredentialCreatescopesInput | Enumerable<string>
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUpdateManyWithoutProjectNestedInput
    metrics?: MetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutProjectNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUpdateManyWithoutProjectNestedInput
    metrics?: MetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutProjectNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutProjectNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutOwnedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    assignee?: UserUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutCreatedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCampaignsNestedInput
    agents?: AIAgentUpdateManyWithoutCampaignsNestedInput
    generatedContent?: GeneratedContentUpdateManyWithoutCampaignNestedInput
    outreachTasks?: OutreachTaskUpdateManyWithoutCampaignNestedInput
    metrics?: MetricUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AIAgentUncheckedUpdateManyWithoutCampaignsNestedInput
    generatedContent?: GeneratedContentUncheckedUpdateManyWithoutCampaignNestedInput
    outreachTasks?: OutreachTaskUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAiAgentsNestedInput
    generatedContent?: GeneratedContentUpdateManyWithoutAgentNestedInput
    campaigns?: CampaignUpdateManyWithoutAgentsNestedInput
    trendSignals?: TrendSignalUpdateManyWithoutAgentNestedInput
    executionSessions?: AgentExecutionSessionUpdateManyWithoutAgentNestedInput
  }

  export type AIAgentUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedContent?: GeneratedContentUncheckedUpdateManyWithoutAgentNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutAgentsNestedInput
    trendSignals?: TrendSignalUncheckedUpdateManyWithoutAgentNestedInput
    executionSessions?: AgentExecutionSessionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AIAgentUncheckedUpdateManyWithoutManagedAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumFeedbackChannelFieldUpdateOperationsInput | FeedbackChannel
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: EnumSentimentFieldUpdateOperationsInput | Sentiment
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | FeedbackSource
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content_rel?: GeneratedContentUpdateOneWithoutFeedbackNestedInput
    outreachTask?: OutreachTaskUpdateOneWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumFeedbackChannelFieldUpdateOperationsInput | FeedbackChannel
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: EnumSentimentFieldUpdateOperationsInput | Sentiment
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | FeedbackSource
    sourceId?: StringFieldUpdateOperationsInput | string
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    outreachTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumFeedbackChannelFieldUpdateOperationsInput | FeedbackChannel
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: EnumSentimentFieldUpdateOperationsInput | Sentiment
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | FeedbackSource
    sourceId?: StringFieldUpdateOperationsInput | string
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    outreachTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutreachTaskUpdateWithoutResponseHandlerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    outreachType?: EnumOutreachTypeFieldUpdateOperationsInput | OutreachType
    status?: EnumOutreachStatusFieldUpdateOperationsInput | OutreachStatus
    leadInfo?: JsonNullValueInput | InputJsonValue
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutOutreachTasksNestedInput
    feedback?: FeedbackUpdateManyWithoutOutreachTaskNestedInput
  }

  export type OutreachTaskUncheckedUpdateWithoutResponseHandlerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    outreachType?: EnumOutreachTypeFieldUpdateOperationsInput | OutreachType
    status?: EnumOutreachStatusFieldUpdateOperationsInput | OutreachStatus
    leadInfo?: JsonNullValueInput | InputJsonValue
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUncheckedUpdateManyWithoutOutreachTaskNestedInput
  }

  export type OutreachTaskUncheckedUpdateManyWithoutOutreachResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    outreachType?: EnumOutreachTypeFieldUpdateOperationsInput | OutreachType
    status?: EnumOutreachStatusFieldUpdateOperationsInput | OutreachStatus
    leadInfo?: JsonNullValueInput | InputJsonValue
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedContentUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AIAgentUpdateOneRequiredWithoutGeneratedContentNestedInput
    campaign?: CampaignUpdateOneWithoutGeneratedContentNestedInput
    feedback?: FeedbackUpdateManyWithoutContent_relNestedInput
  }

  export type GeneratedContentUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    agentId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUncheckedUpdateManyWithoutContent_relNestedInput
  }

  export type GeneratedContentUncheckedUpdateManyWithoutCreatedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    agentId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCredentialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    accountIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scopes?: IntegrationCredentialUpdatescopesInput | Enumerable<string>
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCredentialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    accountIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scopes?: IntegrationCredentialUpdatescopesInput | Enumerable<string>
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCredentialUncheckedUpdateManyWithoutIntegrationCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    accountIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scopes?: IntegrationCredentialUpdatescopesInput | Enumerable<string>
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: TaskStatus
    priority?: Priority
    dueDate?: Date | string | null
    assigneeId?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyProjectInput = {
    id?: string
    content: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: CampaignStatus
    campaignType: CampaignType
    goals: JsonNullValueInput | InputJsonValue
    targeting: JsonNullValueInput | InputJsonValue
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIAgentCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    agentType: AgentType
    configuration: JsonNullValueInput | InputJsonValue
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    scheduleExpression?: string | null
    scheduleEnabled?: boolean
    status?: AgentStatus
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetricCreateManyProjectInput = {
    id?: string
    name: string
    source: string
    value: number
    unit?: string | null
    dimension?: string | null
    campaignId?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOwnerNestedInput
    managedAgents?: AIAgentUncheckedUpdateManyWithoutManagerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    personalizationProfile?: PersonalizationProfileUncheckedUpdateOneWithoutUserNestedInput
    outreachResponses?: OutreachTaskUncheckedUpdateManyWithoutResponseHandlerNestedInput
    createdContent?: GeneratedContentUncheckedUpdateManyWithoutCreatorNestedInput
    integrationCredentials?: IntegrationCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    agents?: AIAgentUpdateManyWithoutCampaignsNestedInput
    generatedContent?: GeneratedContentUpdateManyWithoutCampaignNestedInput
    outreachTasks?: OutreachTaskUpdateManyWithoutCampaignNestedInput
    metrics?: MetricUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AIAgentUncheckedUpdateManyWithoutCampaignsNestedInput
    generatedContent?: GeneratedContentUncheckedUpdateManyWithoutCampaignNestedInput
    outreachTasks?: OutreachTaskUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type AIAgentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneRequiredWithoutManagedAgentsNestedInput
    generatedContent?: GeneratedContentUpdateManyWithoutAgentNestedInput
    campaigns?: CampaignUpdateManyWithoutAgentsNestedInput
    trendSignals?: TrendSignalUpdateManyWithoutAgentNestedInput
    executionSessions?: AgentExecutionSessionUpdateManyWithoutAgentNestedInput
  }

  export type AIAgentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedContent?: GeneratedContentUncheckedUpdateManyWithoutAgentNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutAgentsNestedInput
    trendSignals?: TrendSignalUncheckedUpdateManyWithoutAgentNestedInput
    executionSessions?: AgentExecutionSessionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AIAgentUncheckedUpdateManyWithoutAiAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dimension?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    campaign?: CampaignUpdateOneWithoutMetricsNestedInput
  }

  export type MetricUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dimension?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricUncheckedUpdateManyWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dimension?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GeneratedContentCreateManyAgentInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: string | null
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrendSignalCreateManyAgentInput = {
    id?: string
    title: string
    description: string
    source: string
    signalType: SignalType
    confidence: number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    impact?: TrendImpact
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentExecutionSessionCreateManyAgentInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    success?: boolean | null
    duration?: number | null
    outputSummary?: string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type GeneratedContentUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutGeneratedContentNestedInput
    creator?: UserUpdateOneWithoutCreatedContentNestedInput
    feedback?: FeedbackUpdateManyWithoutContent_relNestedInput
  }

  export type GeneratedContentUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUncheckedUpdateManyWithoutContent_relNestedInput
  }

  export type GeneratedContentUncheckedUpdateManyWithoutGeneratedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    project?: ProjectUpdateOneRequiredWithoutCampaignsNestedInput
    generatedContent?: GeneratedContentUpdateManyWithoutCampaignNestedInput
    outreachTasks?: OutreachTaskUpdateManyWithoutCampaignNestedInput
    metrics?: MetricUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | CampaignStatus
    campaignType?: EnumCampaignTypeFieldUpdateOperationsInput | CampaignType
    goals?: JsonNullValueInput | InputJsonValue
    targeting?: JsonNullValueInput | InputJsonValue
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedContent?: GeneratedContentUncheckedUpdateManyWithoutCampaignNestedInput
    outreachTasks?: OutreachTaskUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type TrendSignalUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSignalTypeFieldUpdateOperationsInput | SignalType
    confidence?: FloatFieldUpdateOperationsInput | number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    impact?: EnumTrendImpactFieldUpdateOperationsInput | TrendImpact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrendSignalUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSignalTypeFieldUpdateOperationsInput | SignalType
    confidence?: FloatFieldUpdateOperationsInput | number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    impact?: EnumTrendImpactFieldUpdateOperationsInput | TrendImpact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrendSignalUncheckedUpdateManyWithoutTrendSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSignalTypeFieldUpdateOperationsInput | SignalType
    confidence?: FloatFieldUpdateOperationsInput | number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    impact?: EnumTrendImpactFieldUpdateOperationsInput | TrendImpact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentExecutionSessionUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentExecutionSessionUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentExecutionSessionUncheckedUpdateManyWithoutExecutionSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableJsonNullValueInput | InputJsonValue
    context?: NullableJsonNullValueInput | InputJsonValue
    metrics?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedContentCreateManyCampaignInput = {
    id?: string
    title: string
    content: string
    contentType: ContentType
    platform?: Platform | null
    status?: ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    agentId: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutreachTaskCreateManyCampaignInput = {
    id?: string
    title: string
    description?: string | null
    outreachType: OutreachType
    status?: OutreachStatus
    leadInfo: JsonNullValueInput | InputJsonValue
    contactMethod: ContactMethod
    aiResponse?: string | null
    responseHandlerId?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetricCreateManyCampaignInput = {
    id?: string
    name: string
    source: string
    value: number
    unit?: string | null
    dimension?: string | null
    projectId?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AIAgentUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAiAgentsNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedAgentsNestedInput
    generatedContent?: GeneratedContentUpdateManyWithoutAgentNestedInput
    trendSignals?: TrendSignalUpdateManyWithoutAgentNestedInput
    executionSessions?: AgentExecutionSessionUpdateManyWithoutAgentNestedInput
  }

  export type AIAgentUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    projectId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedContent?: GeneratedContentUncheckedUpdateManyWithoutAgentNestedInput
    trendSignals?: TrendSignalUncheckedUpdateManyWithoutAgentNestedInput
    executionSessions?: AgentExecutionSessionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AIAgentUncheckedUpdateManyWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | AgentType
    configuration?: JsonNullValueInput | InputJsonValue
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleExpression?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAgentStatusFieldUpdateOperationsInput | AgentStatus
    projectId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedContentUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AIAgentUpdateOneRequiredWithoutGeneratedContentNestedInput
    creator?: UserUpdateOneWithoutCreatedContentNestedInput
    feedback?: FeedbackUpdateManyWithoutContent_relNestedInput
  }

  export type GeneratedContentUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | ContentType
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | Platform | null
    status?: EnumContentStatusFieldUpdateOperationsInput | ContentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    agentId?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUncheckedUpdateManyWithoutContent_relNestedInput
  }

  export type OutreachTaskUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    outreachType?: EnumOutreachTypeFieldUpdateOperationsInput | OutreachType
    status?: EnumOutreachStatusFieldUpdateOperationsInput | OutreachStatus
    leadInfo?: JsonNullValueInput | InputJsonValue
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseHandler?: UserUpdateOneWithoutOutreachResponsesNestedInput
    feedback?: FeedbackUpdateManyWithoutOutreachTaskNestedInput
  }

  export type OutreachTaskUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    outreachType?: EnumOutreachTypeFieldUpdateOperationsInput | OutreachType
    status?: EnumOutreachStatusFieldUpdateOperationsInput | OutreachStatus
    leadInfo?: JsonNullValueInput | InputJsonValue
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    responseHandlerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUncheckedUpdateManyWithoutOutreachTaskNestedInput
  }

  export type OutreachTaskUncheckedUpdateManyWithoutOutreachTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    outreachType?: EnumOutreachTypeFieldUpdateOperationsInput | OutreachType
    status?: EnumOutreachStatusFieldUpdateOperationsInput | OutreachStatus
    leadInfo?: JsonNullValueInput | InputJsonValue
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    responseHandlerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dimension?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneWithoutMetricsNestedInput
  }

  export type MetricUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dimension?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FeedbackCreateManyContent_relInput = {
    id?: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    userId: string
    outreachTaskId?: string | null
    createdAt?: Date | string
  }

  export type FeedbackUpdateWithoutContent_relInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumFeedbackChannelFieldUpdateOperationsInput | FeedbackChannel
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: EnumSentimentFieldUpdateOperationsInput | Sentiment
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | FeedbackSource
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbackNestedInput
    outreachTask?: OutreachTaskUpdateOneWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutContent_relInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumFeedbackChannelFieldUpdateOperationsInput | FeedbackChannel
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: EnumSentimentFieldUpdateOperationsInput | Sentiment
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | FeedbackSource
    sourceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    outreachTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateManyOutreachTaskInput = {
    id?: string
    channel: FeedbackChannel
    content: string
    sentiment: Sentiment
    sourceType: FeedbackSource
    sourceId: string
    userId: string
    contentId?: string | null
    createdAt?: Date | string
  }

  export type FeedbackUpdateWithoutOutreachTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumFeedbackChannelFieldUpdateOperationsInput | FeedbackChannel
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: EnumSentimentFieldUpdateOperationsInput | Sentiment
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | FeedbackSource
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbackNestedInput
    content_rel?: GeneratedContentUpdateOneWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutOutreachTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumFeedbackChannelFieldUpdateOperationsInput | FeedbackChannel
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: EnumSentimentFieldUpdateOperationsInput | Sentiment
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | FeedbackSource
    sourceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}